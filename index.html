<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>New webpage</title>
        <style>
            * {
                -webkit-user-select: none; /* Safari */
                -moz-user-select: none; /* Firefox */
                -ms-user-select: none; /* Internet Explorer/Edge */
                user-select: none; /* Standard */
            }

            #progress-container {
                width: 100%;
                background-color: #f3f3f3;
                padding: 0;
                position: fixed;
                top: 0;
                left: 0;
                z-index: 1000;
            }
            #progress-bar {
                width: 0;
                height: 10px; /* Adjust the height as needed */
                background-color: #4caf50;
            }

            body {
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: #2c3e50;
                margin: 0;
                flex-direction: column;
                font-family: Arial, Helvetica, sans-serif;
            }

            canvas {
                position: absolute;
            }
            #webgl-fog {
                opacity: 0.5;
            }

            .loader {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            h1 {
                color: #ecf0f1;
                margin-bottom: 20px;
            }

            h3 {
                text-align: left;
                color: #ecf0f1;
                margin-left: 20px;
            }

            .dots {
                display: flex;
                justify-content: space-around;
                width: 100px;
            }

            .dot {
                width: 15px;
                height: 15px;
                background-color: #ecf0f1;
                border-radius: 50%;
                animation: loader-animation 1.2s infinite ease-in-out both;
            }

            @keyframes loader-animation {
                0%,
                80%,
                100% {
                    transform: scale(0);
                }
                40% {
                    transform: scale(1);
                }
            }

            .dot:nth-child(1) {
                animation-delay: -0.32s;
            }
            .dot:nth-child(2) {
                animation-delay: -0.16s;
            }
            .dot:nth-child(3) {
                animation-delay: 0s;
            }
            .dot:nth-child(4) {
                animation-delay: 0.16s;
            }
            .dot:nth-child(5) {
                animation-delay: 0.32s;
            }
            .dot:nth-child(6) {
                animation-delay: 0.48s;
            }
            .dot:nth-child(7) {
                animation-delay: 0.64s;
            }
            .dot:nth-child(8) {
                animation-delay: 0.8s;
            }

            footer {
                position: absolute;
                bottom: 20px;
                width: calc(100% - 40px);
                background-color: rgba(0, 0, 0, 0.5);
                color: white;
                text-align: center;
                padding: 10px;
                margin: 0 20px;
                box-sizing: border-box;
            }

            .tip {
                position: relative;
                height: 40px;
                overflow: hidden;
            }

            .tip div {
                position: absolute;
                width: 100%;
                opacity: 0;
                animation: fade 50s linear infinite;
            }

            /*
                t = time
                a = amount of tips
            */
            .tip div:nth-child(1) {
                animation-delay: 0s;
            }
            .tip div:nth-child(2) {
                animation-delay: 10s; /* t/a */
            }
            .tip div:nth-child(3) {
                animation-delay: 20s; /* (t/a)*2 */
            }
            .tip div:nth-child(4) {
                animation-delay: 30s; /* (t/a)*3 */
            }
            .tip div:nth-child(5) {
                animation-delay: 40s; /* (t/a)*4 */
            }

            @keyframes fade {
                0% {
                    opacity: 0;
                }
                10% {
                    /* (100/a)/2 */
                    opacity: 0;
                }
                20% {
                    /* 100/a */
                    opacity: 1;
                }
                30% {
                    /* ((100/a)/2)*3 */
                    opacity: 0;
                }
                100% {
                    opacity: 0;
                }
            }
        </style>
    </head>
    <body onload="init();">
        <div id="progress-container" class="loading">
            <div id="progress-bar"></div>
        </div>
        <div class="loader loading">
            <h1>Loading data</h1>
            <div class="dots">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
        </div>
        <footer class="loading">
            <h3>Tip</h3>
            <div class="tip">
                <div>
                    Falling off the edge of the level causes you to lose health.
                </div>
                <div>
                    Fill your color bar up to the top for maximum color power!
                </div>
                <div>
                    This game has epic audio so turn up your speakers to the
                    max!
                </div>
                <div>
                    Death is inevitable. The inevitable can only be prolonged.
                    The prolonged is the procrastinated. Procrastination is
                    inevitable. Need I say more?
                </div>
                <div>I'm outta ideas here please help me!</div>
            </div>
        </footer>
        <canvas class="sketch"></canvas>
    </body>

    <!--PJs-->
    <script
        type="text/javascript"
        src="https://cdn.jsdelivr.net/gh/Khan/processing-js@master/processing.js"
    ></script>
    <script
        type="text/javascript"
        src="https://cdn.jsdelivr.net/gh/Mushy-Avocado/KA-exporter@v1.0.1/exporter.js"
    ></script>

    <!--Audio-->
    <script type>
        // Kick the program off with a pointless log
        console.log("---Loading data---");

        // Volume for various catagories
        let masterSongVolume = 1,
            masterSoundVolume = 1,
            masterVolume = 1;

        // Load all audio
        let audioNames =
            "cute1 cute2 cute3 cute4 cute5 happy1 happy2 splash1 splash2 underwater wilhelm dark1 dark2 dark3 dark4 egg1 egg2 bossfight cataclysmic_intro cave1 crumble1 crumble2 evil_talking garble landing hard_landing master_intro pitbull powerup talking1 dial_up".split(
                " "
            );

        let totalAudio = audioNames.length,
            loadedAudio = 0;
        for (let i = 0; i < totalAudio; i++) {
            let dScript = document.createElement("script");
            dScript.src =
                "https://cdn.jsdelivr.net/gh/CataclysmicCode/de_block_2/Audio/" +
                audioNames[i] +
                ".min.js";
            document.body.appendChild(dScript);
        }

        // Â© Leafers Studios 2024
        // https://www.khanacademy.org/computer-programming/song-player-elektronomia-sky-high/5456240516710400
        let sounds = {},
            songs = {};
        class Base64Sound {
            constructor(t, params) {
                this.audio = t;
                this.audioContext = new (AudioContext || webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                this.source = null;
                this.buffer = null;

                this.gainNode = this.audioContext.createGain();

                this.isPlaying = 0;
                this.startTime = 0;
                this.elapsedTime = 0;
                this.duration = 0;
                this.hasEnded = 0;
                this.isPaused = 0;

                this.loop = 0;
                this.onLoad = null;
                this.onEnd = null;
                this.nextSong = null;
                this.nextSound = null;
                this.fadeIn = false;
                this.fadeDuration = 1;
                this.volume = 1;
                this.ownVolume = 1;

                for (let param in params) {
                    this[param] = params[param];
                }

                this.setVolume(1);
                this.loadAudio();
            }

            _convertBase64ToArrayBuffer(t) {
                let l = t.split(",");
                let e = atob(l[1] ? l[1] : l[0]);
                for (var i = e.length, a = new Uint8Array(i), n = 0; n < i; n++)
                    a[n] = e.charCodeAt(n);
                return a.buffer;
            }

            loadAudio() {
                let e = this._convertBase64ToArrayBuffer(this.audio),
                    i = this;
                this.audioContext.decodeAudioData(
                    e,
                    function (t) {
                        i.buffer = t;
                        i.duration = t.duration;
                        loadedAudio++;
                        if (i.onLoad) i.onLoad();
                    },
                    function (t) {}
                );
            }

            togglePlayPause() {
                this.hasEnded
                    ? (this.play(), (this.hasEnded = 0))
                    : this.isPlaying
                    ? this.pause()
                    : !this.isPlaying && this.buffer && this.play();
            }

            play() {
                if (this.buffer) {
                    this.source = this.audioContext.createBufferSource();
                    this.source.buffer = this.buffer;
                    this.source.connect(this.gainNode);
                    this.gainNode.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);

                    let t = this.elapsedTime > 0 ? this.elapsedTime : 0;
                    this.startTime = this.audioContext.currentTime - t;
                    this.source.start(0, t);
                    this.isPlaying = 1;
                    this.hasEnded = 0;
                    this.isPaused = 0;

                    // Set initial volume
                    this.gainNode.gain.setValueAtTime(
                        this.fadeIn ? 0 : this.volume,
                        this.audioContext.currentTime
                    );
                    if (this.fadeIn) {
                        this.gainNode.gain.linearRampToValueAtTime(
                            this.volume,
                            this.audioContext.currentTime + this.fadeDuration
                        ); // Use fadeInDuration for fade in
                    }

                    let e = this;
                    this.source.onended = function () {
                        if (e.onEnd && e.isPlaying) e.onEnd();
                        if (e.nextSong && e.isPlaying && songs[e.nextSong])
                            songs[e.nextSong].play();
                        if (e.nextSound && e.isPlaying && sounds[e.nextSound])
                            sounds[e.nextSound].play();
                        e.isPaused ||
                            (e.loop
                                ? e.play()
                                : ((e.isPlaying = 0),
                                  (e.elapsedTime = 0),
                                  (e.hasEnded = 1)));
                    };
                }
            }

            stop() {
                this.isPlaying = 0;
                this.startTime = 0;
                this.elapsedTime = 0;
                this.hasEnded = 0;
                this.isPaused = 1;

                if (this.source) {
                    this.source.stop();
                }
            }

            pause() {
                this.isPlaying &&
                    (this.source.stop(),
                    (this.elapsedTime =
                        this.audioContext.currentTime - this.startTime),
                    (this.isPlaying = 0),
                    (this.isPaused = 1));
            }

            calculateVolume(volume) {
                this.volume =
                    volume *
                    this.ownVolume *
                    (this.isSong ? masterSongVolume : masterSoundVolume) *
                    masterVolume;
            }

            setVolume(volume) {
                this.calculateVolume(volume);
                let currentTime = this.audioContext.currentTime;
                this.gainNode.gain.setValueAtTime(
                    this.gainNode.gain.value,
                    currentTime
                );
                this.gainNode.gain.linearRampToValueAtTime(
                    this.volume,
                    currentTime + 0.01
                );
            }

            fadeOut(duration) {
                this.gainNode.gain.linearRampToValueAtTime(
                    0,
                    this.audioContext.currentTime +
                        (duration || this.fadeDuration)
                );
                let e = this;
                setTimeout(function () {
                    e.stop();
                }, duration * 1000);
            }
        }

        function parseAudio() {
            console.log("---Parsing audio---");

            let Sounds = [
                {
                    name: "cute1",
                    data: cute1,
                    ownVolume: 0.2,
                },
                {
                    name: "cute2",
                    data: cute2,
                    ownVolume: 0.2,
                },
                {
                    name: "cute3",
                    data: cute3,
                    ownVolume: 0.2,
                },
                {
                    name: "cute4",
                    data: cute4,
                    ownVolume: 0.2,
                },
                {
                    name: "cute5",
                    data: cute5,
                    ownVolume: 0.2,
                },
                {
                    name: "dial_up",
                    data: dial_up,
                },
                {
                    name: "wilhelm",
                    data: wilhelm,
                    ownVolume: 0.7,
                },
                {
                    name: "underwater",
                    data: underwater,
                    fadeIn: 1,
                    loop: 1,
                },
                {
                    name: "splash1",
                    data: splash1,
                    ownVolume: 0.5,
                },
                {
                    name: "splash2",
                    data: splash2,
                    ownVolume: 0.5,
                },
                {
                    name: "egg1",
                    data: egg1,
                },
                {
                    name: "egg2",
                    data: egg2,
                },
                {
                    name: "cave1",
                    data: cave1,
                },
                {
                    name: "crumble1",
                    data: crumble1,
                    ownVolume: 0.5,
                },
                {
                    name: "crumble2",
                    data: crumble2,
                    ownVolume: 0.5,
                },
                {
                    name: "evil_talking",
                    data: evil_talking,
                },
                {
                    name: "garble",
                    data: garble,
                },
                {
                    name: "landing",
                    data: landing,
                },
                {
                    name: "hard_landing",
                    data: hard_landing,
                },
                {
                    name: "pitbull",
                    data: pitbull,
                },
                {
                    name: "talking1",
                    data: talking1,
                },
            ];
            let Songs = [
                {
                    name: "dark1",
                    data: dark1,
                    nextSong: "dark2",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "dark2",
                    data: dark2,
                    nextSong: "dark3",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "dark3",
                    data: dark3,
                    nextSong: "dark4",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "dark4",
                    data: dark4,
                    nextSong: "dark1",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "happy1",
                    data: happy1,
                    fadeIn: 1,
                    fadeDuration: 5,
                    ownVolume: 0.4,
                },
                {
                    name: "happy2",
                    data: happy2,
                    ownVolume: 1.5,
                },
                {
                    name: "bossfight",
                    data: bossfight,
                },
                {
                    name: "cataclysmic_intro",
                    data: cataclysmic_intro,
                },
                {
                    name: "master_intro",
                    data: master_intro,
                },
                {
                    name: "powerup",
                    data: powerup,
                },
            ];

            for (let i = 0; i < Sounds.length; i++) {
                sounds[Sounds[i].name] = new Base64Sound(
                    Sounds[i].data,
                    Sounds[i]
                );
            }
            for (let i = 0; i < Songs.length; i++) {
                songs[Songs[i].name] = new Base64Sound(Songs[i].data, Songs[i]);
            }
        }

        function stopAllSounds() {
            for (let sound in sounds) {
                sounds[sound].stop();
            }
        }
        function stopAllSongs() {
            for (let song in songs) {
                songs[song].stop();
            }
        }
        function stopAllAudio() {
            stopAllSounds();
            stopAllSongs();
        }
        stopAllAudio();

        //link game sounds
        /*
        for(let i = 1; i <= 7; i++){
            let s = songs["gameplay"+(i !== 1 ? i : "")];
            s.n = ((i+1) % 8);
            s.onEnd = function(){
                songs["gameplay"+(this.n ? this.n : "")].play();
            };
        }*/
    </script>

    <!--Images-->
    <script type>
        // Not all images are loaded here, like the ones that were made as bitmaps. Just the assets that were loaded externally.
        let backgrounds = {
            Farm: [5, 6, 6, 6],
            Food: [3, 3, 4, 4, 4, 4, 5, 5],
            Forest: [4, 2, 7, 6, 6, 4, 4, 4],
            Industrial: [5, 6, 5, 6, 5, 6, 5, 5],
        };
        for (let b in backgrounds) {
            let back = backgrounds[b];
            for (let i = 0; i < back.length; i++) {
                for (let j = 0; j < back[i]; j++) {
                    let dScript = document.createElement("script");
                    dScript.src =
                        "Images/" + b + "/" + (i + 1) + "/" + (j + 1) + ".js";
                    document.body.appendChild(dScript);
                }
            }
        }

        function parseImages() {
            for (let b in backgrounds) {
                let back = backgrounds[b];
                for (let i = 0; i < back.length; i++) {
                    let num = back[i];
                    back[i] = [];
                    for (let j = 0; j < num; j++) {
                        base64String =
                            window[b + "_" + (i + 1) + "_" + (j + 1)];
                        imageSrc = "data:image/png;base64," + base64String;
                        img = document.createElement("img");
                        img.src = imageSrc;
                        back[i].push(img);
                    }
                }
            }
        }
    </script>

    <!--Loader-->
    <script type>
        document.addEventListener("DOMContentLoaded", () => {
            const progressBar = document.getElementById("progress-bar");

            function updateProgress(percentage) {
                progressBar.style.width = percentage + "%";
            }

            let totalResources = 0;
            let loadedResources = 0;

            function resourceLoaded() {
                loadedResources++;
                const percentLoaded = Math.round(
                    (loadedResources / totalResources) * 100
                );
                updateProgress(percentLoaded);
            }

            // Find all resources to be loaded
            const resources = document.querySelectorAll(
                "img, script, link[rel='stylesheet']"
            );
            totalResources = resources.length - 8;

            resources.forEach((resource) => {
                if (resource.complete) {
                    resourceLoaded();
                } else {
                    resource.addEventListener("load", resourceLoaded);
                    resource.addEventListener("error", resourceLoaded); // in case of loading error
                }
            });
        });
    </script>

    <!--Art Bitmaps-->
    <script type="text/javascript" src="art.js"></script>

    <!--Main-->
    <script type="application/javascript">
function program() {
/** Predefs **/
// [

smooth();
size(600, 600);

let instantLoad = true;

let entities = [],
    enemies = [],
    player,
    keys = {},
    levelW = 0,
    levelH = 0,
    ctx = canvas.getContext("2d");

// Constants
const blockW = 40,
    blockH = 40,
    GRAVITY = Math.PI / 10,
    PADDING_Y = height * 2, // Padding around the y axis of a level
    PADDING_X = width * 2, // Padding around the x axis of a level
    MAX_DIST = 20; // Maximum distance for the player's pathfinder to check

// ]

/** Camera **/
// [

let cam = {
    x: 0,
    y: 0,
    scale: 1,
    speed: 20,
    moveTo: function (obj) {
        this.x +=
            (obj.x +
                obj.w / 2 -
                this.x -
                width / (2 * this.scale)) /
            this.speed;
        this.y +=
            (obj.y +
                obj.h / 2 -
                this.y -
                height / (2 * this.scale)) /
            this.speed;
    },
};
window.cam = cam;

// ]

/** Functions **/
// [

// Screen size adjustments
function tx(x) {
    // Coded on 600 width, but it works on anything
    return (x / 600) * width;
}
function ty(y) {
    // Coded on 600 height, but it works on anything
    return (y / 600) * height;
}
function T(t) {
    // Minimum squashing
    return (t / 600) * min(width, height);
}
function Dist(d1, d2) {
    return d1 - d2 || 1;
}
function easeOut(d1, d2, speed) {
    return Dist(d1, d2) / speed;
}

// To grid
function toGrid(x, y, w = 0, h = 0) {
    return {
        x: min(
            max(floor((x + w / 2 + PADDING_X) / blockW), 0),
            blocks[0].length - 1
        ),
        y: min(
            max(floor((y + h / 2 + PADDING_Y) / blockH), 0),
            blocks.length - 1
        ),
    };
}
function collide(p1, p2) {
    return (
        p1.x + p1.w > p2.x &&
        p2.x + p2.w > p1.x &&
        p1.y + p1.h > p2.y &&
        p2.y + p2.h > p1.y
    );
}

// Random color
function randomColor() {
    return color(random(0, 255), random(0, 255), random(0, 255));
}

// ]

/** Mouse **/
// [

const mouse = {
    // Store mouse Status
    clicked: false,
    pressed: false, // Same as clicked
    released: false,

    // Mouse coordinates (not very useful lol)
    x: mouseX,
    y: mouseY,

    // Release the mouse
    release: function () {
        this.clicked = false;
        this.pressed = false;
        this.released = true;
    },

    // Use the mouse (for some action)
    use: function () {
        this.clicked = false;
        this.pressed = false;
        this.released = true;
    },

    // Update the mouse (call at the end of the draw loop)
    update: function () {
        this.x = mouseX;
        this.y = mouseY;
        this.released = false;
    },

    // Press the mouse
    press: function () {
        this.clicked = true;
        this.pressed = true;
    },
};

// ]

/** Art **/
// [

function createProcessingImage(base64String) {
    const dataUrl = "data:image/png;base64," + base64String;

    loadImage(dataUrl, (img) => {
        image(img, 0, 0);
    });
}

const Colors = {
    spiralRed: color(255, 0, 0),
    spiralBlue: color(0, 0, 255),
    spiralGreen: color(0, 255, 0),
    spiralYellow: color(255, 255, 0),
    spiralPurple: color(217, 0, 255),
    spiralOrange: color(255, 140, 0),
    spiralBrown: color(110, 81, 44),
};
const spiralColors = [
    ["red", color(255, 0, 0)],
    ["blue", color(0, 0, 255)],
    ["green", color(0, 255, 0)],
    ["yellow", color(255, 255, 0)],
    ["purple", color(217, 0, 255)],
    ["orange", color(255, 140, 0)],
    ["brown", color(110, 81, 44)],
];
const colors = {
    // white black and all shades of gray
    "-": color(-1, 0),
    "+": color(-1),
    0: color(231),
    1: color(207.9),
    2: color(184.8),
    3: color(161.7),
    4: color(138.6),
    5: color(115.5),
    6: color(92.4),
    7: color(69.3),
    8: color(46.2),
    9: color(23.1),
    ".": color(0),
    // pinki
    p: color(240, 40, 240),
    P: color(190, 40, 190),
    w: color(240, 80, 240),
    // yellow
    y: color(220, 220, 30),
    Y: color(170, 170, 30),
    W: color(230, 230, 70),
    // green
    g: color(30, 200, 30),
    G: color(30, 150, 30),
    t: color(30, 220, 30),
    // brown
    b: color(100, 50, 0),
    B: color(70, 40, 0),
    // orange
    o: color(255, 127.5, 0),
    O: color(220, 110, 0),
    T: color(255, 140, 70),
    // red
    r: color(255, 0, 0),
    R: color(222.5, 0, 0),
    e: color(100, 0, 0),
    E: color(255, 100, 100),
    // blue
    u: color(40, 40, 220),
    U: color(40, 40, 150),
    i: color(70, 70, 230),
    "^": color(20, 120, 240),
    v: color(20 / 1.15, 120 / 1.15, 240 / 1.15),
    V: color(20 / 1.3, 120 / 1.3, 240 / 1.3),
    // purpur
    q: color(127.5, 0, 255),
    Q: color(90, 0, 180),
    I: color(150, 50, 255),
};

// Make other pools
const colorSub =
    "blue,uU yellow,yY orange,oO green,gG purple,pP brown,bB".split(
        " "
    );
for (let a = 0; a < colorSub.length; a++) {
    // Pool
    let colorArt = [],
        name = colorSub[a].split(",")[0],
        symbols = colorSub[a].split(",")[1];
    for (let i = 0; i < art.redPool.length; i++) {
        let colorImage = [];
        for (let j = 0; j < art.redPool[i].length; j++) {
            colorImage.push(
                art.redPool[i][j]
                    .replaceAll("r", symbols[0])
                    .replaceAll("R", symbols[1])
            );
        }
        colorArt.push(colorImage);
    }
    art[name + "Pool"] = colorArt;

    // Pool top
    colorArt = [];
    name = colorSub[a].split(",")[0];
    symbols = colorSub[a].split(",")[1];
    for (let i = 0; i < art.redPoolTop.length; i++) {
        let colorImage = [];
        for (let j = 0; j < art.redPoolTop[i].length; j++) {
            colorImage.push(
                art.redPoolTop[i][j]
                    .replaceAll("r", symbols[0])
                    .replaceAll("R", symbols[1])
            );
        }
        colorArt.push(colorImage);
    }
    art[name + "PoolTop"] = colorArt;
}

if (instantLoad) {
    // Render art
    noStroke();
    for (let a in art) {
        if (typeof art[a][0] === "string") {
            background(0, 0);
            let pixelW = 400 / art[a][0].length,
                pixelH = 400 / art[a].length;
            for (let i = 0; i < art[a].length; i++) {
                for (let j = 0; j < art[a][i].length; j++) {
                    fill(colors[art[a][i][j]]);
                    rect(
                        j * pixelW,
                        i * pixelH,
                        pixelW + 1,
                        pixelH + 1
                    );
                }
            }
            art[a] = get(0, 0, 400, 400);
        } else {
            for (let t = 0; t < art[a].length; t++) {
                background(0, 0);
                let pixelW = 400 / art[a][t][0].length,
                    pixelH = 400 / art[a][t].length;
                for (let i = 0; i < art[a][t].length; i++) {
                    for (let j = 0; j < art[a][t][i].length; j++) {
                        fill(colors[art[a][t][i][j]]);
                        rect(
                            j * pixelW,
                            i * pixelH,
                            pixelW + 1,
                            pixelH + 1
                        );
                    }
                }
                art[a][t] = get(0, 0, 400, 400);
            }
        }
    }
    for (let s in sprites) {
        background(0, 0);
        if (typeof sprites[s][0] === "string") {
            background(0, 0);
            let pixelW = 400 / sprites[s][0].length,
                pixelH = height / sprites[s].length;
            for (let i = 0; i < sprites[s].length; i++) {
                for (let j = 0; j < sprites[s][i].length; j++) {
                    fill(colors[sprites[s][i][j]]);
                    rect(
                        j * pixelW,
                        i * pixelH,
                        pixelW + 1,
                        pixelH + 1
                    );
                }
            }
            sprites[s] = get(0, 0, 400, 400);
        } else {
            for (let t = 0; t < sprites[s].length; t++) {
                background(0, 0);
                let pixelW = 400 / sprites[s][t][0].length,
                    pixelH = 400 / sprites[s][t].length;
                for (let i = 0; i < sprites[s][t].length; i++) {
                    for (
                        let j = 0;
                        j < sprites[s][t][i].length;
                        j++
                    ) {
                        fill(colors[sprites[s][t][i][j]]);
                        rect(
                            j * pixelW,
                            i * pixelH,
                            pixelW + 1,
                            pixelH + 1
                        );
                    }
                }
                sprites[s][t] = get(0, 0, 400, 400);
            }
        }
    }
    parseSpirals();
    console.log("---Images loaded---");
}

// ]

/** Pixel character (font) class **/
// [

// The amazing pixel art font in bitmap form(ish)
const pixelFont = {
    0: "011110,111111,110011,110011,110011,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    1: "001100,111100,111100,001100,001100,001100,001100,001100,001100,111111,111111,000000,000000,000000,".split(
        ","
    ),
    2: "011110,111111,110011,000011,000011,000111,001110,011100,111000,111111,111111,000000,000000,000000,".split(
        ","
    ),
    3: "011110,111111,110011,000011,001110,001111,000011,000011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    4: "110011,110011,110011,110011,110011,111111,011111,000011,000011,000011,000011,000000,000000,000000,".split(
        ","
    ),
    5: "111111,111111,110000,110000,111110,111111,000011,000011,000011,111111,111110,000000,000000,000000,".split(
        ","
    ),
    6: "011110,111111,110011,110000,111110,111111,110011,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    7: "111111,111111,000011,000011,000111,000110,001110,001100,001100,001100,001100,000000,000000,000000,".split(
        ","
    ),
    8: "011110,111111,110011,110011,011110,111111,110011,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    9: "011110,111111,110011,110011,110011,111111,011111,000011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    a: "000000,000000,000000,111110,111111,000011,011111,111111,110011,111111,011111,000000,000000,000000,".split(
        ","
    ),
    b: "110000,110000,110000,111110,111111,110011,110011,110011,110011,111111,111110,000000,000000,000000,".split(
        ","
    ),
    c: "000000,000000,000000,011111,111111,110000,110000,110000,110000,111111,011111,000000,000000,000000,".split(
        ","
    ),
    d: "000011,000011,000011,011111,111111,110011,110011,110011,110011,111111,011111,000000,000000,000000,".split(
        ","
    ),
    e: "000000,000000,000000,011110,111111,110011,111111,111111,110000,111111,011111,000000,000000,000000,".split(
        ","
    ),
    f: "001111,011111,011000,111110,111110,011000,011000,011000,011000,011000,011000,000000,000000,000000,".split(
        ","
    ),
    g: "000000,000000,000000,011110,111111,110011,110011,110011,110011,111111,011111,000011,111111,111110,".split(
        ","
    ),
    h: "110000,110000,110000,111110,111111,110011,110011,110011,110011,110011,110011,000000,000000,000000,".split(
        ","
    ),
    i: "11,11,00,11,11,11,11,11,11,11,11,00,00,00,".split(","),
    j: "000011,000011,000000,000011,000011,000011,000011,000011,000011,000011,000011,110011,111111,011110,".split(
        ","
    ),
    k: "110000,110000,110000,110011,110011,110110,111100,111100,110110,110011,110011,000000,000000,000000,".split(
        ","
    ),
    l: "11,11,11,11,11,11,11,11,11,11,11,00,00,00,".split(","),
    m: "00000000,00000000,00000000,11111110,11111111,11011011,11011011,11011011,11011011,11011011,11011011,00000000,00000000,00000000,".split(
        ","
    ),
    n: "000000,000000,000000,111110,111111,110011,110011,110011,110011,110011,110011,000000,000000,000000,".split(
        ","
    ),
    o: "000000,000000,000000,011110,111111,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    p: "000000,000000,000000,111110,111111,110011,110011,110011,110011,111111,111110,110000,110000,110000,".split(
        ","
    ),
    q: "000000,000000,000000,011111,111111,110011,110011,110011,110011,110011,011111,000011,000011,000011,".split(
        ","
    ),
    r: "000000,000000,000000,110111,111111,111000,110000,110000,110000,110000,110000,000000,000000,000000,".split(
        ","
    ),
    s: "000000,000000,000000,011111,111111,110000,111110,011111,000011,111111,111110,000000,000000,000000,".split(
        ","
    ),
    t: "011000,011000,011000,111111,111111,011000,011000,011000,011000,011111,001111,000000,000000,000000,".split(
        ","
    ),
    u: "000000,000000,000000,110011,110011,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    v: "000000,000000,000000,110011,110011,110011,110011,011110,011110,001100,001100,000000,000000,000000,".split(
        ","
    ),
    w: "00000000,00000000,00000000,11011011,11011011,11011011,11011011,11011011,11011011,11111111,11111110,00000000,00000000,00000000,".split(
        ","
    ),
    x: "0000000,0000000,0000000,1100011,1100011,0110110,0011100,0011100,0110110,1100011,1100011,0000000,0000000,0000000,".split(
        ","
    ),
    y: "000000,000000,000000,110011,110011,110011,110011,110011,110011,111111,011111,000011,111111,111110,".split(
        ","
    ),
    z: "000000,000000,000000,111111,111111,000111,001110,011100,111000,111111,111111,000000,000000,000000,".split(
        ","
    ),
    A: "011110,111111,110011,110011,110011,111111,111111,110011,110011,110011,110011,000000,000000,000000,".split(
        ","
    ),
    B: "111110,111111,110011,110011,111110,111111,110011,110011,110011,111111,111110,000000,000000,000000,".split(
        ","
    ),
    C: "011111,111111,110000,110000,110000,110000,110000,110000,110000,111111,011111,000000,000000,000000,".split(
        ","
    ),
    D: "111110,111111,110011,110011,110011,110011,110011,110011,110011,111111,111110,000000,000000,000000,".split(
        ","
    ),
    E: "011111,111111,110000,110000,111110,111110,110000,110000,110000,111111,011111,000000,000000,000000,".split(
        ","
    ),
    F: "011111,111111,110000,110000,111110,111110,110000,110000,110000,110000,110000,000000,000000,000000,".split(
        ","
    ),
    G: "011111,111111,110000,110000,110000,110111,110111,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    H: "110011,110011,110011,110011,111111,111111,110011,110011,110011,110011,110011,000000,000000,000000,".split(
        ","
    ),
    I: "111111,111111,001100,001100,001100,001100,001100,001100,001100,111111,111111,000000,000000,000000,".split(
        ","
    ),
    J: "111111,111111,000110,000110,000110,000110,000110,110110,110110,111110,011100,000000,000000,000000,".split(
        ","
    ),
    K: "110011,110011,110110,110110,111100,111100,111100,110110,110110,110011,110011,000000,000000,000000,".split(
        ","
    ),
    L: "110000,110000,110000,110000,110000,110000,110000,110000,110000,111111,011111,000000,000000,000000,".split(
        ","
    ),
    M: "11111110,11111111,11011011,11011011,11011011,11011011,11011011,11000011,11000011,11000011,11000011,00000000,00000000,00000000,".split(
        ","
    ),
    N: "111110,111111,110011,110011,110011,110011,110011,110011,110011,110011,110011,000000,000000,000000,".split(
        ","
    ),
    O: "111110,111111,110011,110011,110011,110011,110011,110011,110011,111111,011111,000000,000000,000000,".split(
        ","
    ),
    P: "111110,111111,110011,110011,111111,111110,110000,110000,110000,110000,110000,000000,000000,000000,".split(
        ","
    ),
    Q: "0111100,1111110,1100110,1100110,1100110,1100110,1100110,1100110,1100110,1111110,0111111,0000011,0000000,0000000,".split(
        ","
    ),
    R: "111110,111111,110011,110011,111111,111110,110111,110011,110011,110011,110011,000000,000000,000000,".split(
        ","
    ),
    S: "011111,111111,110000,110000,111110,011111,000011,000011,000011,111111,111110,000000,000000,000000,".split(
        ","
    ),
    T: "111111,111111,001100,001100,001100,001100,001100,001100,001100,001100,001100,000000,000000,000000,".split(
        ","
    ),
    U: "110011,110011,110011,110011,110011,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(
        ","
    ),
    V: "1100011,1100011,1100011,1100011,0110110,0110110,0110110,0110110,0011100,0011100,0011100,0000000,0000000,0000000,".split(
        ","
    ),
    W: "11000011,11000011,11000011,11000011,11011011,11011011,11011011,11011011,11011011,11111111,01111110,00000000,00000000,00000000,".split(
        ","
    ),
    X: "11000011,11000011,11000011,01100110,00111100,00011000,00111100,01100110,11000011,11000011,11000011,00000000,00000000,00000000,".split(
        ","
    ),
    Y: "110011,110011,110011,110011,110011,111111,011110,001100,001100,001100,001100,000000,000000,000000,".split(
        ","
    ),
    Z: "111111,111111,000011,000011,000110,001100,011000,110000,110000,111111,111111,000000,000000,000000,".split(
        ","
    ),
    " ": "000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,".split(
        ","
    ),
    ".": "00,00,00,00,00,00,00,00,00,11,11,00,00,00,".split(","),
    ",": "00,00,00,00,00,00,00,00,00,11,11,01,10,00,".split(","),
    ":": "00,00,00,11,11,00,00,00,00,11,11,00,00,00,".split(","),
    ";": "00,00,00,11,11,00,00,00,00,11,11,01,10,00,".split(","),
    "!": "11,11,11,11,11,11,11,11,00,11,11,00,00,00,".split(","),
    "?": "011110,111111,110011,000011,000110,001100,001100,001100,000000,001100,001100,000000,000000,000000,".split(
        ","
    ),
    "(": "0111,1111,1100,1100,1100,1100,1100,1100,1100,1100,1100,1111,0111,0000,".split(
        ","
    ),
    ")": "1110,1111,0011,0011,0011,0011,0011,0011,0011,0011,0011,1111,1110,0000,".split(
        ","
    ),
    "[": "11111,11111,11000,11000,11000,11000,11000,11000,11000,11000,11000,11111,11111,00000,".split(
        ","
    ),
    "]": "11111,11111,00011,00011,00011,00011,00011,00011,00011,00011,00011,11111,11111,00000,".split(
        ","
    ),
    "{": "0001111,0011111,0011000,0011000,0110000,0110000,1100000,0110000,0110000,0011000,0011000,0011111,0001111,0000000,".split(
        ","
    ),
    "}": "1111000,1111100,0001100,0001100,0000110,0000110,0000011,0000110,0000110,0001100,0001100,1111100,1111000,0000000,".split(
        ","
    ),
    "+": "000000,000000,000000,000000,001100,001100,111111,111111,001100,001100,000000,000000,000000,000000,".split(
        ","
    ),
    "-": "000000,000000,000000,000000,000000,000000,111111,111111,000000,000000,000000,000000,000000,000000,".split(
        ","
    ),
    "=": "000000,000000,000000,000000,111111,111111,000000,111111,111111,000000,000000,000000,000000,000000,".split(
        ","
    ),
    "@": "00111111100,01111111110,11100000111,11001110011,11011111011,11011011011,11011111011,11001111011,11100011111,01111001110,00111100000,00000000000,00000000000,00000000000,".split(
        ","
    ),
    "#": "0011001100,0011001100,1111111111,1111111111,0011001100,0011001100,0011001100,1111111111,1111111111,0011001100,0011001100,0000000000,0000000000,0000000000,".split(
        ","
    ),
    $: "001100,001100,011111,111111,110000,111110,011111,000011,111111,111110,001100,001100,000000,000000,".split(
        ","
    ),
    "%": "000000011000,000000011000,011000110000,100100110000,100101100000,011001100110,000001101001,000011001001,000011000110,000110000000,000110000000,000000000000,000000000000,000000000000,".split(
        ","
    ),
    "^": "00011000,00111100,01100110,11000011,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,".split(
        ","
    ),
    "&": "0011110000,0111111000,0110011000,0110011000,0011110000,0011100000,0110110100,1100011100,1100001100,1111111110,0111111011,0000000000,0000000000,0000000000,".split(
        ","
    ),
    "*": "10101,01110,11111,01110,10101,00000,00000,00000,00000,00000,00000,00000,00000,00000,".split(
        ","
    ),
    _: "0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,1111111,0000000,0000000,".split(
        ","
    ),
    "<": "0000,0000,0000,0001,0011,0110,1100,1100,0110,0011,0001,0000,0000,0000,".split(
        ","
    ),
    ">": "0000,0000,0000,1000,1100,0110,0011,0011,0110,1100,1000,0000,0000,0000,".split(
        ","
    ),
    "`": "110,011,001,000,000,000,000,000,000,000,000,000,000,000,".split(
        ","
    ),
    "~": "000000,000000,000000,000000,000000,011000,111101,101111,000110,000000,000000,000000,000000,000000,".split(
        ","
    ),
    "\\": "110000,110000,011000,011000,001100,001100,001100,000110,000110,000011,000011,000000,000000,000000,".split(
        ","
    ),
    "/": "000011,000011,000110,000110,001100,001100,001100,011000,011000,110000,110000,000000,000000,000000,".split(
        ","
    ),
    "|": "11,11,11,11,11,00,11,11,11,11,11,00,00,00,".split(","),
    "'": "11,11,01,00,00,00,00,00,00,00,00,00,00,00,".split(","),
    '"': "11011,11011,01001,00000,00000,00000,00000,00000,00000,00000,00000,00000,00000,00000,".split(
        ","
    ),
};

// Render the pixel art font
for (let letter in pixelFont) {
    const data = pixelFont[letter];

    // Empty current spot in the array for reusability
    pixelFont[letter] = [];

    background(0, 0);
    strokeWeight(1);

    // Two different colors
    const fontColors = [30, 255];
    for (let a = 0; a < 2; a++) {
        fill(fontColors[a]);
        stroke(fontColors[a]);
        const pixelSize = 20;
        for (let i = 0; i < data.length; i++) {
            for (let j = 0; j < data[i].length; j++) {
                if (data[i][j] === "1") {
                    rect(
                        j * pixelSize,
                        i * pixelSize,
                        pixelSize,
                        pixelSize
                    );
                }
            }
        }

        // Store the current letter in the pixel art array
        pixelFont[letter].push(
            get(
                0,
                0,
                pixelSize * data[0].length,
                pixelSize * data.length
            )
        );
    }
}

/**
 * Pixelized Character
 *
 * A single pixelized letter that can be animated and used
 * in combination with more of itself to form strings
 *
 * @param {object} params - Contains the Character's parameters.
 *     @param {string} char - A single character representing the character
 **/
class Character {
    constructor(params) {
        this.char = " ";
        this.size = 10;
        this.index = 0;

        for (var param in params) {
            this[param] = params[param];
        }
    }

    /**
     * Display the letter at the specified size & color
     **/
    display(size, color) {
        // Nope
        if (!pixelFont[this.char]) return;

        // Do it
        const data = pixelFont[this.char][color];
        const width = size * (data.width / data.height),
            height = size;
        pushMatrix();
        // translate(width / 2, height / 2);
        // rotate(cos((frameCount * 2) + (this.index * 10)) * 10);
        // image(data, -width / 2, -height / 2, width, height);
        image(data, 0, 0, width, height);
        popMatrix();
    }

    /**
     * Get the width and height of the character
     **/
    get height() {
        if (!pixelFont[this.char]) return 0;
        return pixelFont[this.char][0].height;
    }
    get width() {
        if (!pixelFont[this.char]) return 0;
        return pixelFont[this.char][0].width;
    }
}

// ]

/** Spirals **/
// [

function parseSpirals() {
    // Spiral fills for coloarable blocks
    // Available colors are red, yellow, blue, green, purple, orange, and brown
    let amount = 100,
        pending = [],
        c = 0,
        rendering = true;
    let grid = Array.from({ length: amount }, function () {
        return Array(amount).fill(0);
    });
    background(-1, 0);

    // Predefs for the spiral color fills
    let colorIndex = -1,
        finished = true;
    function renderNext() {
        colorIndex++;
        c = 0;
        grid = Array.from({ length: amount }, function () {
            return Array(amount).fill(0);
        });
        background(0, 0);
        // image(art.blank, 0, 0, amount, amount);
        // art[spiralColors[colorIndex][0]].push(get(0, 0, amount, amount));
        get(0, 0, amount, amount);
    }
    function setPixel(x, y, a, a2) {
        if (
            y < grid.length &&
            y >= 0 &&
            x < grid[y].length &&
            x >= 0 &&
            grid[y][x] !== 1
        ) {
            pending.push([y, x]);
            return 1;
        }
        return 0;
    }

    renderNext();

    let i = 0;
    while (1) {
        i++;
        stroke(
            lerpColor(
                spiralColors[colorIndex][1],
                color(0),
                noise(i / 50)
            )
        );

        // Spread the Grid
        finished = true;
        grid.forEach(function (v2, y, a) {
            v2.forEach(function (v, x, a2) {
                if (v === 1) {
                    //rect(x * (100 / a2.length), y * (100 / a.length), 100 / a2.length, 100 / a.length);
                    point(x, y);

                    var r = floor(random(0, 5));
                    switch (r) {
                        case 1:
                            setPixel(x + 1, y, a, a2);
                            break;
                        case 2:
                            setPixel(x, y + 1, a, a2);
                            break;
                        case 3:
                            setPixel(x - 1, y, a, a2);
                            break;
                        case 4:
                            setPixel(x, y - 1, a, a2);
                            break;
                    }

                    if (
                        (!grid[y + 1] || grid[y + 1][x] !== 0) &&
                        (!grid[y - 1] || grid[y - 1][x] !== 0) &&
                        (!grid[y][x + 1] || grid[y][x + 1] !== 0) &&
                        (!grid[y][x - 1] || grid[y][x - 1] !== 0)
                    ) {
                        grid[y][x] = 2;
                    }
                }
                if (!v) {
                    finished = false;
                }
            });
        });

        rendering = pending.length || c < 75;
        for (let i = pending.length - 1; i >= 0; i--) {
            grid[pending[i][0]][pending[i][1]] = 1;
            pending.splice(i, 1);
        }

        // Spiral animation
        if (c < 75) {
            var sz = map(c, 0, 100, 1, 400);
            var x = cos(c * 10.1) * sz + 300;
            var y = sin(c * 10.1) * sz + 300;
            grid[floor(y / (600 / grid.length))][
                floor(x / (600 / grid[0].length))
            ] = 1;
            c++;
        }

        // Capture the image every couple frames
        if (i % 5 === 0)
            art[spiralColors[colorIndex][0]].push(
                get(0, 0, amount, amount)
            );

        // Render the next spiral
        if (finished) {
            art[spiralColors[colorIndex][0]].push(
                get(0, 0, amount, amount)
            );
            renderNext();
        }
        if (colorIndex === spiralColors.length) break;
    }
}

// ]

/** Pixel text class **/
// [

/**
 * Pixelized Text
 *
 * A string of pixelized text that can be displayed on the screen
 *
 * @param {object} params - Contains the Texts's parameters.
 *     @param {string} string - A string representation of the text
 *     @param {number} size - How big the text is
 *     @param {bool} color - What color the letter is (0 = black, anything else = white)
 *     @param {number} rotation - In degrees
 **/
class PixelText {
    constructor(params) {
        // Coincide with each other
        this.chars = [];
        this._string = "";
        this._rows = "";

        // For center align, stores the offset of each row
        this.rowWidths = [];

        // Display stuffs
        this.x = 0;
        this.y = 0;
        this.size = 10;
        this.color = 0;
        this.rotation = 0;
        this.align = CORNER;

        for (var param in params) {
            this[param] = params[param];
        }
    }

    /**
     * A sneaky way to easily update the contents of the text
     **/
    get string() {
        return this._string;
    }
    set string(value) {
        this._string = value;
        this.setChars(value);
    }

    /**
     * Update the characters stored based off of a passed string
     **/
    setChars(string) {
        this.width = 0;
        this.height = 0;
        this.chars = [];
        this.rowWidths = [];

        // Nothing to do
        if (!string.length) return;

        this._rows = string.split("\n");
        let index = 0;
        for (var i = 0; i < this._rows.length; i++) {
            // Nothing in this row
            this.chars.push([]);
            if (!this._rows[i].length) {
                this.rowWidths.push(0);
                continue;
            }

            let rowWidth = 0;
            for (let j = 0; j < this._rows[i].length; j++) {
                this.chars[this.chars.length - 1].push(
                    new Character({
                        char: this._rows[i][j],
                        size: this.size,
                        index: index,
                    })
                );
                index++;
                rowWidth +=
                    this.chars[i][j].width /
                        this.chars[i][j].height || 0;
            }
            this.rowWidths.push(rowWidth);
        }
    }

    /**
     * Display the text
     **/
    display() {
        imageMode(CORNER);
        pushMatrix();
        translate(this.x, this.y);
        rotate(this.rotation);

        const spaceX = this.size / 10,
            spaceY = this.size / 10;

        if (this.align === CENTER) {
            translate(
                0,
                -(
                    (this.chars.length * this.size) / 2 +
                    ((this.chars.length - 1) * spaceY) / 2
                )
            );
        }
        for (let i = 0; i < this.chars.length; i++) {
            pushMatrix();
            if (this.align === CENTER) {
                translate(
                    -(
                        (this.size * this.rowWidths[i]) / 2 +
                        ((this.chars[i].length - 1) * spaceX) / 2
                    ),
                    0
                );
            }
            for (let j = 0; j < this.chars[i].length; j++) {
                const char = this.chars[i][j];
                char.display(this.size, this.color);
                translate(
                    this.size * (char.width / char.height) + spaceX,
                    0
                );
            }
            popMatrix();
            translate(0, this.size + spaceY);
        }

        popMatrix();
    }
}

// ]

/** Pages class **/
// [

/**
 * Page
 *
 * A scene that can be displayed and has some helpful methods
 *
 * @param {object} params - Contains the page's parameters.
 *     @param {boolean} visible - Whether the page is visible or not.
 *     @param {function} draw - Called every frame the page is visible for.
 *     @param {function} onSwitch - Called whenever the page's visibily state is changed.
 *     @param {function} onLeave - Called when the page becomes invisible
 *     @param {function} onEnter - Called when the page becomes visible
 **/
class Page {
    constructor(params) {
        this.visible = false;
        this.draw = () => {};
        this.onSwitch = () => {};
        this.onLeave = () => {};
        this.onEnter = () => {};
        for (let i in params) {
            this[i] = params[i];
        }
    }

    hide() {
        this.visible = false;
    }
    show() {
        this.visible = true;
    }
    update() {
        try {
            if (this.visible) this.draw();
        } catch (err) {
            println(
                "Oops looks like something went wrong! Please try restarting the program. Check the console for more info."
            );
            console.error(err);
            noLoop();
        }
    }
}

/**
 * Pages
 *
 * Contains all the pages for the game.
 *
 * @param {object} params - Contains the parameters for the pages.
 *     @param {object} pages - The object of pages
 *     @param {string} page - A string representing the name of the current visible page
 *     @param {string} lastPage - A string representing the name of the last visible page
 **/
class Pages {
    constructor(params) {
        this.pages = {};
        this.page = undefined;
        this.lastPage = undefined;
        this.Page = undefined;
        for (let i in params) {
            this[i] = params[i];
        }
        for (let i in this.pages) {
            this.pages[i].name = i;
        }
    }

    /**
     * Hide a single page
     *
     * @param {string / object} page - a string or object representing the page to hide
     **/
    hidePage(page) {
        // Hide page
        if (typeof page === "string") {
            // String passed
            this.pages[page].hide();
            if (this.page === page) this.page = undefined;
        } else {
            // Object passed
            page.hide();
            if (this.page === page.name) this.page = undefined;
        }
    }

    /**
     * Hide all the pages
     **/
    hidePages() {
        for (let i in this.pages) {
            this.hidePage(i);
        }
    }

    /**
     * Hide a single page
     *
     * @param {string / object} page - a string or object representing the page to show
     **/
    showPage(page) {
        try {
            this.hidePages();
            // Show one page
            if (typeof page === "string") {
                // String passed
                this.pages[page].show();
                this.page = page;
                this.Page = this.pages[page];
            } else {
                // Object passed
                page.show();
                this.page = page.name;
                this.Page = page;
            }
        } catch (err) {
            println(err);
        }
    }

    /**
     * Update the pages
     **/
    update() {
        this.lastPage = this.page;
        for (let i in this.pages) {
            this.pages[i].update();
        }
        if (this.lastPage !== this.page) {
            this.pages[this.page].onSwitch();
            this.pages[this.lastPage].onSwitch();
            this.pages[this.page].onEnter();
            this.pages[this.page].onLeave();
        }
    }
}

// ]

/** Light class **/
// [

class Light {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.numRays = 360;
        this.color = color(255, 25);
        this.strength = 255;
        this.rays = [];
        this.visibleRays = [];
        for (
            let i = 0;
            i <= this.numRays + 1;
            i++ && this.visibleRays.push({ x: 0, y: 0 })
        ) {}
    }

    castRays(blocks) {
        this.rays = [];
        const step = (2 * Math.PI) / this.numRays;

        for (let angle = 0; angle < 2 * Math.PI; angle += step) {
            this.castRay(angle, blocks);
        }
    }
    castRay(angle, blocks) {
        const rayLength = 400;
        const blockSize = 40;
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);

        const compensation = (max(width, height) / rayLength) * 2;

        let t = 0;
        while (t < rayLength) {
            const rayX = this.x + t * dx;
            const rayY = this.y + t * dy;

            const blockX = floor(rayX / blockSize);
            const blockY = floor(rayY / blockSize);

            // Find relative X & Y positions within the current block
            const left = rayX - blockX * blockSize;
            const top = rayY - blockY * blockSize;
            const right = blockSize - left;
            const bottom = blockSize - top;

            const checks = [
                blockX,
                blockY,
                blockX + 1,
                blockY,
                blockX,
                blockY + 1,
                blockX - 1,
                blockY,
                blockX,
                blockY - 1,
            ];
            for (let i = 0; i < checks.length; i += 2) {
                const x = checks[i] * blockSize,
                    y = checks[i + 1] * blockSize;
                if (
                    checks[i] >= 0 &&
                    checks[i] < blocks[0].length &&
                    checks[i + 1] >= 0 &&
                    checks[i + 1] < blocks.length &&
                    rayX >= x &&
                    rayX <= x + blockSize &&
                    rayY >= y &&
                    rayY <= y + blockSize
                ) {
                    if (
                        blocks[checks[i + 1]][checks[i]].canCollide
                    ) {
                        this.rays.push({ x: rayX, y: rayY });
                        return;
                    } else {
                        blocks[checks[i + 1]][checks[i]].setLight(
                            (1 - t / rayLength) * this.strength
                        );
                    }
                }
            }

            const stepX = dx > 0 ? right / abs(dx) : left / abs(dx);
            const stepY = dy > 0 ? bottom / abs(dy) : top / abs(dy);

            t += min(stepX || 1, stepY || 1);

            if (t >= rayLength) {
                this.rays.push({
                    x: this.x + rayLength * dx * compensation,
                    y: this.y + rayLength * dy * compensation,
                });
                return;
            }
        }
    }

    draw() {
        fill(this.color, 25);
        // stroke(this.color, 25);
        // strokeWeight(3);
        noStroke();
        beginShape();
        // Subtle animation
        this.visibleRays.forEach((v, i) => {
            this.visibleRays[i].x +=
                (this.rays[i].x - this.visibleRays[i].x) / 2;
            this.visibleRays[i].y +=
                (this.rays[i].y - this.visibleRays[i].y) / 2;
            vertex(v.x - PADDING_X, v.y - PADDING_Y);
        });
        endShape();
    }
}

// ]

/** Enemy class **/
// [

class Enemy {
    constructor(params) {
        this.x = 0;
        this.y = 0;
        this.vy = 0;
        this.vx = 0;
        this.w = blockW;
        this.h = blockH;

        this.transition = random(0, 999999);
        this.animateSpeed = 10;
        this.type = "basic";
        this.index = 0;
        this.attacking = false;

        this.inLiquid = false;
        this.isGrounded = false;
        this.isNear = false;
        this.isTouching = false;

        this.strength = -1;

        for (let i in params) {
            this[i] = params[i];
        }
    }

    /**
     * Efficient collisions
     *
     * Only check the closest blocks for collisions and ignore all others
     **/
    collide(vx, vy) {
        let X = floor((this.x + PADDING_X) / blockW) - 1,
            Y = floor((this.y + PADDING_Y) / blockH) - 1,
            toX,
            toY;
        this.isStuck = true;
        for (
            let y = max(Y, 0);
            y < min(Y + 4, blocks.length);
            y++
        ) {
            for (
                let x = max(X, 0);
                x < min(X + 4, blocks[y].length);
                x++
            ) {
                let block = blocks[y][x],
                    overlapX =
                        this.x - block.x < 0
                            ? this.w + (this.x - block.x)
                            : block.w - (this.x - block.x),
                    overlapY =
                        this.y - block.y < 0
                            ? this.h + (this.y - block.y)
                            : block.h - (this.y - block.y),
                    touching =
                        overlapY > this.h / 2 &&
                        overlapX > this.w / 2;
                if (block.canCollide) this.isNear = true;
                if (
                    this.x + this.w > block.x &&
                    this.y + this.h > block.y &&
                    block.x + block.w > this.x &&
                    block.y + block.h > this.y
                ) {
                    // Handle collision
                    if (block.canCollide) {
                        this.isTouching = true;
                        if (vx > 0) {
                            this.vx = 0;
                            toX = block.x - this.w;
                        }
                        if (vx < 0) {
                            this.vx = 0;
                            toX = block.x + block.w;
                        }
                        if (vy > 0) {
                            this.isGrounded = true;
                            this.vy = 0;
                            toY = block.y - this.h;
                        }
                        if (vy < 0) {
                            this.vy = 0;
                            toY = block.y + block.h;
                        }
                    } else {
                        this.isStuck = false;
                    }
                    if (block.isLiquid) {
                        this.inLiquid = true;
                    }
                    block.setColor(this.strength, "none");
                }
            }
        }

        if (toX !== undefined) {
            this.x = toX;
        }
        if (toY !== undefined) {
            this.y = toY;
        }
    }

    applyForce(fx, fy) {
        this.vx += fx;
        this.vy += fy;
    }

    /**
     * Reset frame
     *
     * To be called every frame before the enemy is updated to reset some complex-logic variables
     **/
    resetFrame() {
        this.isTouching = false;
        this.isNear = false;
        this.attacking = false;
        this.transition++;
    }

    update() {
        this.logic();
        this.isGrounded = false;
        this.inLiquid = false;
        this.move();
        this.draw();
    }
    draw() {
        let mapped = floor(
            (this.transition / this.animateSpeed) %
                sprites[this.type].length
        );
        pushMatrix();
        translate(this.x, this.y);
        image(
            sprites[this.type][mapped],
            0,
            0,
            this.w + 1,
            this.h + 1
        );
        popMatrix();
    }
    logic() {
        this.x += this.vx;
        this.y += this.vy;
    }
    move() {}
}

// ]

/** Rottweiler class **/
// [

class Rottweiler extends Enemy {
    constructor(params) {
        super(params);
        this.mv = 5;
        this.type = "rottweiler";
        this.strength = -1;
        this.animateSpeed = 4;
        this.health = 100;
        // this.x += random(-1, 1);
        // this.y += random(-1, 1);
    }

    draw() {
        if (this.attacking) {
            let mapped =
                floor(
                    (this.transition / this.animateSpeed) %
                        (sprites[this.type].length - 1)
                ) + 1;
            pushMatrix();
            translate(this.x + this.w / 2, this.y + this.h / 2);
            if (this.vx > 0) {
                scale(1, -1);
                rotate(atan2(this.vx, this.vy) + 90);
            } else {
                rotate(atan2(-this.vx, this.vy) - 90);
            }
            image(
                sprites[this.type][mapped],
                -this.w / 2,
                -this.h / 2,
                this.w + 1,
                this.h + 1
            );
            popMatrix();
        } else {
            pushMatrix();
            translate(this.x, this.y);
            image(
                sprites[this.type][0],
                0,
                0,
                this.w + 1,
                this.h + 1
            );
            popMatrix();
        }
    }
    logic() {
        // repulse from other rottweilers
        const repulsionDistance = max(this.w, this.h);
        const repulsionForce = 0.1;
        for (let j = this.index + 1; j < enemies.length; j++) {
            if (enemies[j].type === this.type) {
                const dx = enemies[j].x - this.x;
                const dy = enemies[j].y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                if (distance < repulsionDistance) {
                    this.isTouching = true;
                    const force =
                        (repulsionForce *
                            (repulsionDistance - distance)) /
                        distance;
                    const fx = force * dx;
                    const fy = force * dy;
                    this.applyForce(-fx, -fy);
                    enemies[j].applyForce(fx, fy);
                }
            }
        }

        // Follow the player's pathfinder
        this.gridPos = toGrid(this.x, this.y, this.w, this.h);
        let p = player.pathfinder,
            g = this.gridPos,
            d = p[g.y][g.x];

        // Calculate the movement velocity
        this.mv = min(
            map(
                dist(player.x, player.y, this.x, this.y),
                0,
                600,
                1,
                25
            ),
            25
        );

        // Find path in the X axis
        let c = [MAX_DIST + 1, {}];
        [
            { x: g.x + 1, y: g.y },
            { x: g.x - 1, y: g.y },
        ]
            .filter((v) => {
                return (
                    v.y < blocks.length &&
                    v.y >= 0 &&
                    v.x < blocks[0].length &&
                    v.x >= 0
                );
            })
            .forEach((v) => {
                if (p[v.y][v.x] < c[0] && p[v.y][v.x] !== 0) {
                    c[0] = p[v.y][v.x];
                    c[1] = v;
                }
            });
        if (c[0] !== MAX_DIST + 1) {
            this.attacking = true;
            this.vx = min(
                max(this.vx + (c[1].x - g.x) / 5, -this.mv),
                this.mv
            );
        }

        // Find path in the Y axis
        c = [MAX_DIST + 1, {}];
        [
            { x: g.x, y: g.y + 1 },
            { x: g.x, y: g.y - 1 },
        ]
            .filter((v) => {
                return (
                    v.y < blocks.length &&
                    v.y >= 0 &&
                    v.x < blocks[0].length &&
                    v.x >= 0
                );
            })
            .forEach((v) => {
                if (p[v.y][v.x] < c[0] && p[v.y][v.x] !== 0) {
                    c[0] = p[v.y][v.x];
                    c[1] = v;
                }
            });
        if (c[0] !== MAX_DIST + 1) {
            this.attacking = true;
            if (this.isTouching) {
                this.vy = min(
                    max(this.vy + (c[1].y - g.y) / 3, -this.mv),
                    this.mv
                );
            }
        }

        // Prevent a failed path finding attempt due to lack of velocity
        if (abs(this.vx) < 1) {
            this.vx *= 1.2;
        }

        // Drain the player's health
        if (collide(this, player)) {
            player.colorStrength = max(
                player.colorStrength - 0.1,
                -100
            );

            // Drain this rottweiler's own health
            if (player.colorStrength > 0) {
                this.health -= player.colorStrength / 100;
            }
        }

        // Convert when touching liquid or dead
        if (
            this.inLiquid ||
            this.health <= 0 ||
            this.y > levelH - PADDING_Y
        ) {
            entities.push(
                new GoodRottweiler({
                    x: this.x,
                    y: this.y,
                    w: this.w,
                    h: this.h,
                    vx: this.vx,
                    vy: this.vy,
                })
            );
            this.dead = true;
        }
    }
    move() {
        // Collide x
        this.x += this.vx;
        this.collide(this.vx, 0);

        // Collide y
        this.y += this.vy;
        this.collide(0, this.vy);

        // Friction
        const f = 0.01;
        if (this.vx > 0) this.vx = max(this.vx - f, 0);
        if (this.vx < 0) this.vx = min(this.vx + f, 0);
        if (this.vy > 0) this.vy = max(this.vy - f, 0);
        if (this.vy < 0) this.vy = min(this.vy + f, 0);

        this.vy += GRAVITY;
    }
}

// ]

/** Good Rottweiler class **/
// [

class GoodRottweiler {
    constructor(params) {
        this.x = 0;
        this.y = 0;
        this.vy = 0;
        this.vx = 0;

        this.w = blockW;
        this.h = blockH;

        this.animateSpeed = 5;
        this.transition = 0;
        this.dead = false;

        this.speed = random(0.5, 1);

        for (let i in params) {
            this[i] = params[i];
        }
    }

    update() {
        this.logic();
        this.draw();
    }
    draw() {
        let mapped = floor(
            min(
                this.transition / this.animateSpeed,
                sprites.goodRottweiler.length - 1
            )
        );
        pushMatrix();
        translate(this.x + this.w / 2, this.y + this.h / 2);
        if (this.vx > 0) {
            scale(1, -1);
            rotate(atan2(this.vx, this.vy) + 90 - this.transition);
        } else {
            rotate(atan2(-this.vx, this.vy) - 90 + this.transition);
        }
        image(
            sprites.goodRottweiler[mapped],
            -this.w / 2,
            -this.h / 2,
            this.w + 1,
            this.h + 1
        );
        popMatrix();
    }
    logic() {
        this.transition++;

        // Keep moving in the original direction, but make the total speed = this.speed
        this.vx =
            this.vx *
            (this.speed /
                sqrt(this.vx * this.vx + this.vy * this.vy));
        this.vy =
            this.vy *
            (this.speed /
                sqrt(this.vx * this.vx + this.vy * this.vy));

        this.x += this.vx;
        this.y += this.vy;

        if (this.x > levelW) this.dead = true;
    }
}

// ]

/** Bird class **/
// [

class Bird {
    constructor(params) {
        this.x = 0;
        this.y = 0;
        this.vy = 0;
        this.vx = 0;

        this.w = blockW;
        this.h = blockH;

        this.animateSpeed = 10;
        this.transition = random(0, 999999);
        this.dead = false;

        for (let i in params) {
            this[i] = params[i];
        }
    }

    update() {
        this.logic();
        this.draw();
    }
    draw() {
        let mapped = floor(
            (this.transition / this.animateSpeed) %
                sprites.bird.length
        );
        image(
            sprites.bird[mapped],
            this.x,
            this.y,
            this.w + 1,
            this.h + 1
        );
    }
    logic() {
        this.transition++;
        this.vy = -(noise(this.transition / 100) - 0.4) * 10;
        this.vx = min(this.vx + 0.02, 2);

        this.x += this.vx;
        this.y += this.vy;

        if (this.x > levelW) this.dead = true;
    }
}

// ]

/** Block class **/
// [

/**
 * Block
 *
 * @param {object} params - Contains the block's parameters.
 *     @param {number} x/y - The block's coordinates.
 *     @param {string} type - The name of the block, aka the type of block.
 **/
class Block {
    constructor(params) {
        this.x = 0;
        this.y = 0;
        this.type = "air";
        this.animateSpeed = 10;
        this.playerDist = 0;

        // Color handling
        this.strength = 0;
        this.canSpread = false;
        this.lastColorName = "none";
        this.colorName = "none";

        // Transition
        this.transSpeed = 50;
        this.transition = -100;

        // Light strength
        this.light = 0;
        this.lowest = 0;
        this.displayLowest = 0;

        for (let i in params) {
            this[i] = params[i];
        }

        this.data = blockData[this.symbol];

        for (let i in this.data) {
            this[i] = this.data[i];
        }
    }

    /**
     * Display the block
     *
     * Display: display the image of the block
     * Draw: handle animations
     **/
    display(art, x, y, w, h) {
        image(art, x, y, w + 1, h + 1);
    }
    draw() {
        let name = this.colorable
            ? this.colorName !== "none"
                ? this.colorName
                : this.type
            : this.type;

        if (art[name].length || this.colorable) {
            if (this.canInfiniteAnimate) {
                let mapped = floor(
                    (abs(this.transition) / this.animateSpeed) %
                        art[name].length
                );
                this.display(
                    art[name][mapped],
                    this.x,
                    this.y,
                    this.w,
                    this.h
                );
            } else {
                // A block is being colored!
                if (this.strength > 0) {
                    // Make an exception for colorable blocks
                    if (this.colorable) {
                        let mapped = round(
                            map(
                                this.transition,
                                this.transSpeed,
                                0,
                                0,
                                art[name].length - 1
                            )
                        );
                        if (this.transition < 0) {
                            mapped = art[name].length - 1;
                        }
                        // Display the old color underneath
                        if (this.lastColorName === "none") {
                            this.display(
                                art.blank,
                                this.x,
                                this.y,
                                this.w,
                                this.h
                            );
                        } else {
                            this.display(
                                art[this.lastColorName][
                                    art[this.lastColorName].length -
                                        1
                                ],
                                this.x,
                                this.y,
                                this.w,
                                this.h
                            );
                        }
                        this.display(
                            art[name][
                                constrain(
                                    mapped,
                                    0,
                                    art[name].length - 1
                                )
                            ],
                            this.x,
                            this.y,
                            this.w,
                            this.h
                        );
                    } else {
                        let mapped = round(
                            map(
                                this.transition,
                                this.transSpeed,
                                0,
                                art[name].length - 1,
                                0
                            )
                        );
                        if (this.transition < 0) {
                            mapped = art[name].length - 1;
                        }
                        this.display(
                            art[name][
                                constrain(
                                    mapped,
                                    0,
                                    art[name].length - 1
                                )
                            ],
                            this.x,
                            this.y,
                            this.w,
                            this.h
                        );
                    }
                }
                // A block is decaying...
                else {
                    // Make an exception for colorable blocks
                    if (this.colorable) {
                        name = this.lastColorName;
                        this.display(
                            art.blank,
                            this.x,
                            this.y,
                            this.w,
                            this.h
                        );
                        if (name !== "none") {
                            let mapped = round(
                                map(
                                    this.transition,
                                    -this.transSpeed,
                                    0,
                                    0,
                                    art[name].length - 1
                                )
                            );
                            if (
                                this.transition < -this.transSpeed
                            ) {
                                mapped = 0;
                            }
                            this.display(
                                art[name][
                                    constrain(
                                        mapped,
                                        0,
                                        art[name].length - 1
                                    )
                                ],
                                this.x,
                                this.y,
                                this.w,
                                this.h
                            );
                        }
                    } else {
                        let mapped = round(
                            map(
                                this.transition,
                                -this.transSpeed,
                                0,
                                art[name].length - 1,
                                0
                            )
                        );
                        if (this.transition < -this.transSpeed) {
                            mapped = art[name].length - 1;
                        }
                        this.display(
                            art[name][
                                constrain(
                                    mapped,
                                    0,
                                    art[name].length - 1
                                )
                            ],
                            this.x,
                            this.y,
                            this.w,
                            this.h
                        );
                    }
                }
            }
        } else {
            this.display(art[name], this.x, this.y, this.w, this.h);
        }

        textSize(10);
        fill(0);
        textAlign(CENTER, CENTER);
        text(
            this.colorName,
            this.x + this.w / 2,
            this.y + this.h / 2
        );

        if (
            !this.canAnimate &&
            this.canChangeColor &&
            !this.colorable
        ) {
            // A block is being colored!
            if (this.strength > 0) {
                rectMode(CENTER);
                colorMode(HSB);

                noFill();
                let amount = 20;
                strokeWeight(this.w / amount / 2);
                for (let i = 0; i < amount; i++) {
                    let size = i * (this.transSpeed / amount);
                    if (
                        this.transition + size > 0 &&
                        this.transition + size < this.transSpeed
                    ) {
                        stroke(
                            map(i, 0, amount, 0, 255),
                            180,
                            180,
                            200
                        );
                        rect(
                            this.x + this.w / 2,
                            this.y + this.h / 2,
                            map(
                                this.transition + size,
                                this.transSpeed,
                                0,
                                0,
                                this.w
                            ),
                            map(
                                this.transition + size,
                                this.transSpeed,
                                0,
                                0,
                                this.h
                            )
                        );
                    }
                }

                rectMode(CORNER);
                colorMode(RGB);
            }

            // A block is decaying...
            else if (this.strength <= 0) {
                rectMode(CENTER);

                noFill();
                let amount = 20;
                strokeWeight(this.w / amount / 2);
                for (let i = 0; i < amount; i++) {
                    let size = i * (this.transSpeed / amount);
                    if (
                        this.transition + size > 0 &&
                        this.transition + size < this.transSpeed
                    ) {
                        stroke(map(i, 0, amount, 255, 0));
                        rect(
                            this.x + this.w / 2,
                            this.y + this.h / 2,
                            map(
                                this.transition + size,
                                this.transSpeed,
                                0,
                                0,
                                this.w
                            ),
                            map(
                                this.transition + size,
                                this.transSpeed,
                                0,
                                0,
                                this.h
                            )
                        );
                    }
                }

                rectMode(CORNER);
            }
        }

        if (
            this.colorable &&
            (this.type !== this.colorName || !this.colored)
        ) {
            let n = (cos(frameCount) / 2 + 0.5) * 200;
            noStroke();
            noFill();
            switch (this.type) {
                case "red":
                    fill(222.5, 0, 0, n);
                    break;
                case "green":
                    fill(30, 200, 30, n);
                    break;
                case "blue":
                    fill(40, 40, 220, n);
                    break;
                case "purple":
                    fill(127.5, 0, 255, n);
                    break;
                case "orange":
                    fill(255, 120, 0, n);
                    break;
                case "yellow":
                    fill(220, 220, 30, n);
                    break;
                case "brown":
                    fill(100, 50, 0, n);
                    break;
            }
            rect(this.x, this.y, this.w + 1, this.h + 1);
        }
    }
    shadow() {
        noStroke();
        fill(0, min(255 - this.light, 255 - this.displayLowest));
        rect(this.x, this.y, this.w, this.h);
        this.light = 0;
    }

    /**
     * Change states
     **/
    changeTo(type) {
        this.canInfiniteAnimate = 0;
        for (let i in this.data) {
            this[i] = 0;
        }
        this.onChange = () => {};

        for (let i in blockData[type]) {
            this[i] = blockData[type][i];
        }

        if (this.onChange) {
            this.onChange(this);
        }
    }
    setColor(strength, colorName) {
        // Sadly, no
        if (!this.canChangeColor) return;

        fill(255, 0, 0, 100);
        rect(this.x, this.y, this.w, this.h);

        // Colorize!
        if (strength > 0) {
            // Decay transition in progress, maybe later
            if (
                this.transition >= -this.transSpeed &&
                this.canColor(colorName)
            )
                return;

            // Set color for the first time
            if (this.canColor(colorName)) {
                this.transition = this.transSpeed;
                player.colorStrength = max(
                    player.colorStrength - player.colorDecrease,
                    0
                );

                this.lastColorName = this.colorName;
                this.colorName = colorName;

                if (this.colorable) {
                    if (
                        this.type === this.colorName ||
                        this.type === "blank"
                    ) {
                        player.hasColored++;
                    }
                } else {
                    player.hasColored++;
                }
            }

            this.strength = strength;
            this.setLowLight(255);
            this.spread(colorName);
        }

        // Decayizeâ¢ï¸...
        else if (strength <= 0) {
            // Color transition in progress, maybe later
            if (
                this.transition >= -this.transSpeed &&
                this.canDecay()
            )
                return;

            // Start decaying for the first time
            if (this.canDecay()) {
                this.lastColorName = this.colorName;
                this.colorName = "none";
                this.transition = this.transSpeed;
                if (this.colorable) {
                    if (
                        this.type === this.lastColorName ||
                        this.type === "blank"
                    ) {
                        player.hasColored--;
                    }
                } else {
                    player.hasColored--;
                }
            }

            this.strength = strength;
            this.spread();
        }
    }

    /**
     * Light modification
     *
     * @param {number} light - Number between 255-0 representing the light level to change to
     **/
    setLight(light) {
        this.light = max(max(this.light, light), 0);
        if (this.light <= 0) return;

        const decrease =
            this.light - (this.canCollide ? 255 / 3 : 255 / 8);
        if (
            this.index[1] !== blocks[0].length - 1 &&
            blocks[this.index[0]][this.index[1] + 1].light <
                decrease
        )
            blocks[this.index[0]][this.index[1] + 1].setLight(
                decrease
            );
        if (
            this.index[1] !== 0 &&
            blocks[this.index[0]][this.index[1] - 1].light <
                decrease
        )
            blocks[this.index[0]][this.index[1] - 1].setLight(
                decrease
            );
        if (
            this.index[0] !== blocks.length - 1 &&
            blocks[this.index[0] + 1][this.index[1]].light <
                decrease
        )
            blocks[this.index[0] + 1][this.index[1]].setLight(
                decrease
            );
        if (
            this.index[0] !== 0 &&
            blocks[this.index[0] - 1][this.index[1]].light <
                decrease
        )
            blocks[this.index[0] - 1][this.index[1]].setLight(
                decrease
            );
    }
    setLowLight(light) {
        this.lowest = max(max(this.lowest, light), 0);
        if (this.lowest <= 0) return;

        const decrease =
            this.lowest - (this.canCollide ? 255 / 5 : 255 / 10);
        if (
            this.index[1] !== blocks[0].length - 1 &&
            blocks[this.index[0]][this.index[1] + 1].lowest <
                decrease
        )
            blocks[this.index[0]][this.index[1] + 1].setLowLight(
                decrease
            );
        if (
            this.index[1] !== 0 &&
            blocks[this.index[0]][this.index[1] - 1].lowest <
                decrease
        )
            blocks[this.index[0]][this.index[1] - 1].setLowLight(
                decrease
            );
        if (
            this.index[0] !== blocks.length - 1 &&
            blocks[this.index[0] + 1][this.index[1]].lowest <
                decrease
        )
            blocks[this.index[0] + 1][this.index[1]].setLowLight(
                decrease
            );
        if (
            this.index[0] !== 0 &&
            blocks[this.index[0] - 1][this.index[1]].lowest <
                decrease
        )
            blocks[this.index[0] - 1][this.index[1]].setLowLight(
                decrease
            );
    }

    /**
     * Check the status of the block.
     *
     * canDecay: Can the block become a decayed block?
     * canColor: Can the block become a colored block?
     **/
    canDecay() {
        return this.strength > 0;
    }
    canColor(colorName) {
        return (
            this.strength <= 0 ||
            (this.colorable && this.colorName !== colorName)
        );
    }
    isDecayed() {
        return this.strength < 0;
    }
    isColored() {
        return this.strength > 0;
    }

    /**
     * Spread color or decay depending on the block's state
     **/
    spread(colorName) {
        let touching = [
            [this.index[0] + 1, this.index[1]],
            [this.index[0] - 1, this.index[1]],
            [this.index[0], this.index[1] + 1],
            [this.index[0], this.index[1] - 1],
        ].filter((v) => {
            return (
                v[0] < blocks.length &&
                v[0] >= 0 &&
                v[1] < blocks[0].length &&
                v[1] >= 0
            );
        });

        this.spreadDecay(touching, colorName);
        this.spreadColor(touching, colorName);
    }
    spreadDecay(touching, colorName) {
        // Spread the death
        touching.forEach((v) => {
            if (this.strength < 0)
                blocks[v[0]][v[1]].setColor(
                    this.strength + 1,
                    colorName
                );
        });
    }
    spreadColor(touching, colorName) {
        // Spread the joy
        touching.forEach((v) => {
            if (this.strength > 1)
                blocks[v[0]][v[1]].setColor(
                    this.strength - 1,
                    colorName
                );
        });
    }

    /**
     * Update the block
     **/
    update() {
        this.logic();
        this.draw();
    }
    logic() {
        // Animation
        if (this.transition === 0) {
            if (this.nextType) {
                this.changeTo(this.nextType);
            }
        }
        this.transition--;

        // Turn dirt to grass
        let blockAbove =
            blocks[max(this.index[0] - 1, 0)][this.index[1]];
        if (this.type === "grayGrassBlock" && blockAbove) {
            if (
                blockAbove.canCollide &&
                blockAbove.id !== this.id
            ) {
                this.changeTo("D");
            }
        }
        if (this.type === "grassBlock" && blockAbove) {
            if (
                blockAbove.canCollide &&
                blockAbove.id !== this.id
            ) {
                this.changeTo("d");
            }
        }

        // Add tops to liquid
        if (this.isLiquid && blockAbove && this.nextType) {
            if (
                blockAbove.type === "air" ||
                blockAbove.id === this.id
            ) {
                this.changeTo(this.nextType);
            }
        }

        // Update the displayed lowest light smoothly
        this.lowest = (player.hasColored / player.mustColor) * 255;
        this.lowest = player.colorStrength < 0 ? 0 : this.lowest;
        this.displayLowest +=
            (this.lowest - this.displayLowest) / 20;
    }
}

// ]

/** Player class **/
// [

class Player {
    constructor(params) {
        // Physics
        this.vx = 0;
        this.vy = 0;
        this.canJump = false;
        this.inLiquid = false;
        this.wasInLiquid = false;

        // Color stuff
        this.lastColorStrength = 0;
        this.colorStrength = 0;
        this.colorDecrease = 0.15;
        this.timeSinceColorChange = 0;
        this.lastColor = color(255, 0, 0);
        this.color = color(255, 0, 0);
        this.colorName = "red";

        this.light = new Light(0, 0);
        this.nearDark = {};
        this.pathfinder = [];
        this.blankPathfinder = [];

        // Wonder wut this does
        this.dead = false;

        // Counters
        this.hasColored = 0;
        this.mustColor = 0;

        for (let i in params) {
            this[i] = params[i];
        }

        this.startX = this.x;
        this.startY = this.y;
    }

    updateHud() {
        // Health bar
        noStroke();
        fill(100);
        rect(100, 20, 400, 10);
        fill(this.lastColorStrength > 0 ? this.lerpedColor : 0);
        rect(
            100,
            20,
            map(abs(this.lastColorStrength), 0, 100, 0, 400),
            10
        );
        rectMode(CENTER);
        fill(0);
        for (let i = 100 / 5; i < 100; i += 100 / 5) {
            rect(map(i, 0, 100, 100, 500), 25, 5, 10);
        }
        rectMode(CORNER);

        // Darkness arrow
        let block = this.nearDark.block;
        if (
            block &&
            (block.x - cam.x + block.w < 0 ||
                block.x - cam.x > width ||
                block.y - cam.y + block.h < 0 ||
                block.y - cam.y > height)
        ) {
            textAlign(CENTER, CENTER);
            pushMatrix();
            const x = constrain(
                    block.x - cam.x + block.w / 2,
                    50,
                    width - 50
                ),
                y = constrain(
                    block.y - cam.y + block.w / 2,
                    50,
                    height - 50
                );
            translate(x, y);
            rotate(
                -atan2(
                    x - (block.x - cam.x + block.w / 2),
                    y - (block.y - cam.y + block.h / 2)
                ) - 90
            );
            let txt = new PixelText({
                x: 0,
                y: 0,
                string: ">",
                size: 40,
                color: 0,
                align: CENTER,
            });
            txt.display();
            txt.color = 1;
            txt.size = 30;
            txt.display();
            popMatrix();
        }

        // Amount left
        textSize(25, 20, 30);
        fill(100);
        text(this.hasColored + "/" + this.mustColor, 500, 550);
    }

    /**
     * Efficient collisions
     *
     * Only check the closest blocks for collisions and ignore all others
     **/
    collide(vx, vy) {
        let X = floor((this.x + PADDING_X) / blockW) - 1,
            Y = floor((this.y + PADDING_Y) / blockH) - 1,
            toX,
            toY;
        for (
            let y = max(Y, 0);
            y < min(Y + 4, blocks.length);
            y++
        ) {
            for (
                let x = max(X, 0);
                x < min(X + 4, blocks[y].length);
                x++
            ) {
                let block = blocks[y][x],
                    overlapX = max(
                        0,
                        min(this.x + this.w, block.x + block.w) -
                            max(this.x, block.x)
                    ),
                    overlapY = max(
                        0,
                        min(this.y + this.h, block.y + block.h) -
                            max(this.y, block.y)
                    ),
                    touching =
                        overlapY > this.h / 4 &&
                        overlapX > this.w / 4;
                if (
                    this.x + this.w > block.x &&
                    this.y + this.h > block.y &&
                    block.x + block.w > this.x &&
                    block.y + block.h > this.y
                ) {
                    // Handle collision
                    if (block.canCollide) {
                        if (vx > 0) {
                            this.vx = 0;
                            toX = block.x - this.w;
                        }
                        if (vx < 0) {
                            this.vx = 0;
                            toX = block.x + block.w;
                        }
                        if (vy > 0) {
                            if (
                                this.colorStrength > 0 &&
                                this.vy > 1
                            ) {
                                for (
                                    let i = 0;
                                    i <
                                    (this.vy *
                                        (this.colorStrength / 20)) /
                                        2;
                                    i++
                                ) {
                                    pages.Page.particles.add(
                                        new Particle({
                                            x: random(
                                                this.x,
                                                this.x + this.w
                                            ),
                                            y: this.y + this.h,
                                            vx: random(-3, 3),
                                            vy: random(-3, -5),
                                            w: blockW / 10,
                                            color: this.mixedColor,
                                            fade: true,
                                            health: round(
                                                random(30, 50)
                                            ),
                                            image: "ellipse",
                                            onUpdate: function () {
                                                this.vy += GRAVITY;
                                            },
                                        })
                                    );
                                }
                            }
                            this.canJump = true;
                            if (this.vy > 15) {
                                sounds["hard_landing"].play();
                            } else if (this.vy > 2) {
                                sounds["landing"].setVolume(
                                    map(this.vy, 1, 15, 0.1, 3)
                                );
                                sounds["landing"].play();
                            }
                            this.vy = 0;
                            toY = block.y - this.h;
                        }
                        if (vy < 0) {
                            this.vy = 0;
                            toY = block.y + block.h;
                        }
                    }
                    if (block.isLiquid && touching) {
                        this.inLiquid = block;
                        this.colorName = block.name;
                        this.canJump = true;
                    }

                    if (this.colorStrength !== 0)
                        block.setColor(
                            ceil(this.colorStrength / 20),
                            this.colorName
                        );
                }
            }
        }

        if (toX !== undefined) {
            this.x = toX;
        }
        if (toY !== undefined) {
            this.y = toY;
        }
    }

    /**
     *
     * Find the nearest uncolored block
     *
     **/
    findNearDark() {
        this.nearDark = {};
        if (this.hasColored < this.mustColor) {
            for (let i = 0; i < blocks.length; i++) {
                for (let j = 0; j < blocks[i].length; j++) {
                    let block = blocks[i][j];
                    if (
                        block.canChangeColor &&
                        block.strength <= 0
                    ) {
                        let d = dist(
                            this.x,
                            this.y,
                            block.x,
                            block.y
                        );
                        if (this.nearDark.block) {
                            if (this.nearDark.dist > d) {
                                this.nearDark.block = blocks[i][j];
                                this.nearDark.dist = d;
                            }
                        } else {
                            this.nearDark.block = blocks[i][j];
                            this.nearDark.dist = d;
                        }
                    }
                }
            }
        }
    }
    reset() {
        this.x = this.startX;
        this.y = this.startY;
        this.vx = 0;
        this.vy = 0;
        this.nearDark = {};
        this.pathfinder = this.blankPathfinder.map((innerArray) => [
            ...innerArray,
        ]);
    }

    /**
     * Path finding
     *
     * Calculate the path around the player by a certain radius
     **/
    findPath() {
        this.pathfinder = this.blankPathfinder.map((innerArray) => [
            ...innerArray,
        ]);
        const pos = toGrid(this.x, this.y, this.w, this.h);
        this.pathfinder[pos.y][pos.x] = 1;
        this.movePath(pos, 2, MAX_DIST);
    }
    movePath(p, a, m) {
        if (a > m) return;

        [
            { x: p.x + 1, y: p.y },
            { x: p.x - 1, y: p.y },
            { x: p.x, y: p.y + 1 },
            { x: p.x, y: p.y - 1 },
        ]
            .filter((v) => {
                return (
                    v.y < blocks.length &&
                    v.y >= 0 &&
                    v.x < blocks[0].length &&
                    v.x >= 0 &&
                    !blocks[v.y][v.x].canCollide &&
                    (this.pathfinder[v.y][v.x] === 0 ||
                        this.pathfinder[v.y][v.x] > a)
                );
            })
            .forEach((v) => {
                blocks[v.y][v.x].n = a;
                this.pathfinder[v.y][v.x] = a;
                this.movePath(v, a + 1, m);
            });
    }

    update() {
        this.move();
        this.logic();
        this.draw();
    }
    draw() {
        noStroke();
        fill(this.mixedColor);
        quad(
            this.x + this.vx * 1.5,
            this.y,
            this.x + this.w + this.vx * 1.5,
            this.y,
            this.x + this.w,
            this.y + this.h,
            this.x,
            this.y + this.h
        );
    }
    move() {
        // Gravity keeps pulling me down down down
        this.vy += GRAVITY;

        // Animate color strength bar
        this.lastColorStrength += easeOut(
            this.colorStrength,
            this.lastColorStrength,
            10
        );

        this.timeSinceColorChange++;
        let acc = 0.7,
            fri = 0.35,
            spd = Math.PI + Math.PI / 2;
        if (this.inLiquid) {
            // Handle movement
            if (keys[37] || keys[65]) {
                // Move left
                this.vx -= acc;
            }
            if (keys[39] || keys[68]) {
                // Move right
                this.vx += acc;
            }
            if (keys[38] || keys[87]) {
                // Move up
                this.vy -= acc;
                this.vy = max(this.vy, -4);
            } else {
                this.vy = max(this.vy, -1);
            }
            if (keys[40] || keys[83]) {
                // Move down
                this.vy += acc;
                this.vy = min(this.vy, 4);
            } else {
                this.vy = min(this.vy, 1);
            }
            this.vx = constrain(this.vx, -4, 4);

            // Gain strength
            this.colorStrength = min(this.colorStrength + 0.5, 100);
            if (this.inLiquid.color !== this.color) {
                this.timeSinceColorChange = 0;
                this.lastColor = this.color;
                this.color = this.inLiquid.color;
            }
        } else {
            // Handle movement
            if (keys[37] || keys[65]) {
                // Move left
                this.vx = max(this.vx - acc, -spd);
            }
            if (keys[39] || keys[68]) {
                // Move right
                this.vx = min(this.vx + acc, spd);
            }
            if ((keys[38] || keys[87]) && this.canJump) {
                // Jump
                this.canJump = false;
                this.vy = -Math.PI * 3;
            }
        }

        if (keys[82]) this.dead = true;

        // Duh
        this.wasInLiquid = this.inLiquid;
        this.inLiquid = false;

        // Collide x
        this.x += this.vx;
        this.collide(this.vx, 0);

        // Collide y
        this.y += this.vy;
        this.collide(0, this.vy);

        // Friction
        this.vx =
            this.vx > 0
                ? max(this.vx - fri, 0)
                : min(this.vx + fri, 0);
    }
    logic() {
        // Cache the lerped
        this.lerpedColor = lerpColor(
            this.lastColor,
            this.color,
            min(this.timeSinceColorChange / 100, 1)
        );
        this.mixedColor =
            this.lastColorStrength > 0
                ? lerpColor(
                        color(100),
                        this.lerpedColor,
                        min(this.lastColorStrength / 100, 1)
                    )
                : lerpColor(
                        color(100),
                        color(0),
                        min(-(this.lastColorStrength / 100), 1)
                    );

        // Light up the world (or else)
        this.light.x = round(PADDING_X + this.x + this.w / 2);
        this.light.y = round(PADDING_Y + this.y + this.h / 2);
        this.light.color = color(
            this.colorStrength >= 0
                ? lerpColor(
                        this.mixedColor,
                        color(-1, 1),
                        this.hasColored / this.mustColor
                    )
                : 0
        );
        this.light.strength =
            this.colorStrength >= 0
                ? map(this.colorStrength, 100, 0, 255, 200)
                : map(this.colorStrength, 0, -100, 200, 150);
        this.light.castRays(blocks);

        // Calculate the pathfinding grid
        this.findPath();

        // Find the nearest darkened block
        if (frameCount % 100 === 0) {
            this.findNearDark();
        }

        // Jumping in
        if (!this.wasInLiquid && this.inLiquid) {
            if (this.vy > 0) {
                for (let i = 0; i < abs(this.vy * 3); i++) {
                    pages.Page.particles.add(
                        new Particle({
                            x: random(this.x, this.x + this.w),
                            y: this.y + this.h,
                            vx: random(-3, 3),
                            vy: -random(this.vy / 2, this.vy / 1.5),
                            w: blockW / 10,
                            color: this.inLiquid.color,
                            health: round(this.vy * 5),
                            image: "ellipse",
                            fade: true,
                            onUpdate: function () {
                                this.vy += GRAVITY;
                            },
                        })
                    );
                }
            }
            sounds.splash2.play();
            sounds.underwater.play();
        }

        // Jumping out
        if (this.wasInLiquid && !this.inLiquid) {
            if (this.vy < 0) {
                for (let i = 0; i < abs(this.vy * 3); i++) {
                    pages.Page.particles.add(
                        new Particle({
                            x: random(this.x, this.x + this.w),
                            y: this.y,
                            vx: random(-3, 3),
                            vy: random(this.vy, this.vy * 2),
                            w: blockW / 10,
                            color: this.color,
                            health: round(-this.vy * 13),
                            image: "ellipse",
                            fade: true,
                            onUpdate: function () {
                                this.vy += GRAVITY;
                            },
                        })
                    );
                }
            }
            sounds.splash1.play();
            sounds.underwater.fadeOut(1);
        }

        // Die you fools!
        if (this.y > levelH - PADDING_Y) {
            sounds.wilhelm.play();
            this.colorStrength = max(
                this.colorStrength - 100 / 5,
                -100
            );
            this.reset();
        }
        if (this.colorStrength === -100) {
            this.dead = true;
        }
    }
}

// ]

/** Particle class **/
// [

/**
 * Particle System
 *
 * An easy way to create tons of particles with
 * three simple methods.
 *
 * @param {object} params - Contains the particle system's parameters.
 *     @param {array} particles - The list of particles in the system.
 **/
class ParticleSystem {
    constructor(params) {
        this.particles = [];

        for (let param in params) {
            this[param] = params[param];
        }
    }

    /**
     * Update all the particles in this system.
     **/
    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.update();
            if (p.dead) {
                p.onDeath();
                this.particles.splice(i, 1);
            }
        }
    }

    /**
     * Adds a particle to the system.
     *
     * @param {object} particle - An instance of Particle
     **/
    add(particle) {
        this.particles.push(particle);
    }

    /**
     * Remove all particles in this system.
     **/
    reset() {
        Delete(this.particles);
    }
}

/**
 * Particle
 *
 * A dynamic particle with lots of customization options
 *
 * @param {object} params - Contains the particle's parameters.
 *     @param {number} x/y - Coordinates.
 *     @param {number} w/h - Dimentions.
 *     @param {number} rx/ry/rz - Rotation x, y and z respectively.
 *     @param {number} rvx/rvy/rvz - Rotation velocity x, y and z respectively.
 *     @param {number} vx/vx - Position velocity.
 *     @param {number} vw/vh - Dimention velocity.
 *     @param {number} toX/toY - Move to coordinates.
 *     @param {number} toRx/toRy/toRz - Rotation to move to. X, y and x respectively.
 *     @param {number} toW/toH - Move to dimentions.
 *     @param {number} toX/toY - Move to coordinates.
 *     @param {boolean} fade - Fade to 0% opacity as death nears.
 *     @param {string} image - Either "rect", "ellipse" or and instance of image.
 *     @param {number} health - Represents how many frames the particle has left to live. (-1 if it never dies)
 *     @param {number} pause - How many frames the particle should ignore moveTo commands. (0 if it shouldn't)
 *     @param {number} strokeWeight - The thickness of the particle's border.
 *     @param {color} color/stroke - The particle's color and border color respectively.
 *     @param {function} onArrive - Called when the particle reaches it's moveTo destination.
 *     @param {function} onUpdate - Called whenever the particle is updated.
 *     @param {function} onDeath - Called when the particle dies.
 *
 **/
class Particle {
    constructor(params) {
        // Positions
        this.x = width / 2;
        this.y = height / 2;
        this.w = 0;
        this.h = 0;
        this.rx = 0;
        this.ry = 0;
        this.rz = 0;

        // Velocities
        this.rvx = 0;
        this.rvy = 0;
        this.rvz = 0;
        this.vx = 0;
        this.vy = 0;
        this.vw = 0;
        this.vh = 0;

        // To positions
        this.toX = 0;
        this.toY = 0;
        this.toRx = 0;
        this.toRy = 0;
        this.toRz = 0;
        this.toSpeed = 10;
        this.toRSpeed = 0;
        this.toW = 0;
        this.toH = 0;

        // Misc settings
        this.fade = false;
        this.image = "rect";
        this.health = 100;
        this.dead = false;
        this.pause = 0;

        // Display
        this.strokeWeight = 0;
        this.color = color(0);
        this.stroke = color(0);

        // Events
        this.onArrive = function () {};
        this.onUpdate = function () {};
        this.onDeath = function () {};

        for (let param in params) {
            this[param] = params[param];
        }

        // Background logic
        this.life = this.health;
        if (!this.h && this.image.width && this.image.height) {
            this.h = map(
                this.w,
                0,
                this.image.width,
                0,
                this.image.height
            );
        }
    }

    /**
     * Update the size of the particle taking into acount the size of the image, if there is one
     *
     * @param {number} w - The width of the particle
     * @param {number} h - The height of the particle
     **/
    setSize(w, h) {
        this.w = w;
        this.h = h || w;
        if (!h && this.image.width && this.image.height) {
            this.h = map(
                this.w,
                0,
                this.image.width,
                0,
                this.image.height
            );
        }
    }

    /**
     * Update the particle.
     **/
    update() {
        this.logic();
        this.display();
    }
    display() {
        fill(
            this.fade
                ? lerpColor(
                        color(-1, 1),
                        this.color,
                        constrain(this.health / this.life, 0, 1)
                    )
                : this.color
        );
        stroke(
            this.fade
                ? lerpColor(
                        color(-1, 1),
                        this.stroke,
                        constrain(this.health / this.life, 0, 1)
                    )
                : this.stroke
        );
        this.strokeWeight
            ? strokeWeight(this.strokeWeight)
            : noStroke();

        pushMatrix();
        translate(this.x, this.y);
        rotate(this.rx);
        scale(cos(this.ry), cos(this.rz));

        let w = this.w,
            h = this.h || this.w;
        switch (this.image) {
            case "rect":
                rect(0, 0, w, h);
                break;
            case "ellipse":
                ellipse(0, 0, w, h);
                break;
            default:
                image(this.image, 0, 0, w, h);
                break;
        }

        popMatrix();
    }
    logic() {
        this.onUpdate();
        if (this.pause) {
            this.pause--;
        } else {
            if (
                round(this.x - this.toX) === 0 &&
                round(this.y - this.toY) === 0
            ) {
                this.onArrive();
            }
            if (this.toX)
                this.x += easeOut(this.toX, this.x, this.toSpeed);
            if (this.toY)
                this.y += easeOut(this.toY, this.y, this.toSpeed);
            if (this.toW)
                this.w += easeOut(this.toW, this.w, this.toSpeed);
            if (this.toH)
                this.h += easeOut(this.toH, this.h, this.toSpeed);
            if (this.toRx)
                this.rx += easeOut(
                    this.toRx % 360,
                    this.rx,
                    this.toRSpeed || this.toSpeed
                );
            if (this.toRy)
                this.ry += easeOut(
                    this.toRy % 360,
                    this.ry,
                    this.toRSpeed || this.toSpeed
                );
            if (this.toRz)
                this.rz += easeOut(
                    this.toRz % 360,
                    this.rz,
                    this.toRSpeed || this.toSpeed
                );
            if (!this.health) this.dead = true;
            this.health--;
        }

        this.x += this.vx;
        this.y += this.vy;
        this.w += this.vw;
        this.h += this.vh;
        this.rx += this.rvx;
        this.ry += this.rvy;
        this.rz += this.rvz;
    }
}

// ]

/** Extreme walker class **/
// [

/**
 * Extreme Walker
 *
 * A cool spreading effect for the homescreen
 *
 * @param {object} params - Contains the extreme walker's parameters.
 *     @param {number} amount - How many pixels are in the walker (both width & height)
 **/
class ExtremeWalker {
    constructor(params) {
        this.grid = [];
        this.color = randomColor();
        this.pending = [];
        this.finished = false;
        this.amount = 200;

        for (let param in params) {
            this[param] = params[param];
        }
        this.reset(this.amount);
    }

    /**
     * Add a pixel to the pending list to add in the future
     **/
    setPixel(x, y) {
        this.finished = false;
        if (
            y < this.grid.length &&
            y >= 0 &&
            x < this.grid[y].length &&
            x >= 0 &&
            this.grid[y][x] !== 1
        ) {
            this.pending.push([y, x]);
        }
    }

    /**
     * Update all the pixels in the grid,
     * spreading each solid pixel randomly,
     * unless it's already spread in all four directions
     **/
    update() {
        // No need to continue
        if (this.finished) return;

        // Setup
        noStroke();
        fill(this.color);

        // Assume the grid is finished spreading
        this.finished = true;

        this.grid.forEach((v2, y, a) => {
            v2.forEach((v, x, a2) => {
                if (v === 1) {
                    // Draw a rectangle at the current pixel's position
                    rect(
                        round(x * (width / a2.length)),
                        round(y * (height / a.length)),
                        round(width / a2.length) + 1,
                        round(height / a.length) + 1
                    );

                    // Choose a random direction to spread in
                    let r = floor(random(0, 5));
                    switch (r) {
                        case 1:
                            this.setPixel(x + 1, y, a, a2);
                            break;
                        case 2:
                            this.setPixel(x, y + 1, a, a2);
                            break;
                        case 3:
                            this.setPixel(x - 1, y, a, a2);
                            break;
                        case 4:
                            this.setPixel(x, y - 1, a, a2);
                            break;
                    }

                    // Check if the current pixel has spread in all directions
                    if (
                        (!this.grid[y + 1] ||
                            this.grid[y + 1][x] !== 0) &&
                        (!this.grid[y - 1] ||
                            this.grid[y - 1][x] !== 0) &&
                        (!this.grid[y][x + 1] ||
                            this.grid[y][x + 1] !== 0) &&
                        (!this.grid[y][x - 1] ||
                            this.grid[y][x - 1] !== 0)
                    ) {
                        this.grid[y][x] = 2;
                    }
                }

                // The grid is not finished spreading
                if (v === 0) {
                    this.finished = false;
                }
            });
        });

        // Add all pending pixels to the grid
        for (let j = this.pending.length - 1; j >= 0; j--) {
            this.grid[this.pending[j][0]][this.pending[j][1]] = 1;
            this.pending.splice(j, 1);
        }
    }

    /**
     * Reset the grid
     **/
    reset(amount) {
        this.grid = Array.from({ length: amount }, function () {
            return Array(amount).fill(0);
        });
    }
}

// ]

/** Cataclysmic intro class **/
// [

class CataclysmicIntro {
    constructor() {
        // [

        this.data =
            "1m7n1n7n1o7n1p7n1q7n1r7n1s7n1t7n1u7n1v7n1w7n9l7n9m7n9n7n9o7n9p7n9q7n9r7n9s7n9t7nbt7nbu7nbv7nbw7nbx7nby7nbz7nc07nc17nc27nc37n1j7o1k7o1l7o1m7o1n7o1o7o1p7o1q7o1r7o1s7o1t7o1u7o1v7o1w7o1x7o1y7o1z7o5r7o5s7o5t7o5u7o5v7o5w7o5x7o5y7o5z7o607o9k7o9l7o9m7o9n7o9o7o9p7o9q7o9r7o9s7o9t7obq7obr7obs7obt7obu7obv7obw7obx7oby7obz7oc07oc17oc27oc37oc47oc57oc67oe87oe97oea7oeb7oec7oed7oee7oef7oeg7oeh7o1h7p1i7p1j7p1k7p1l7p1m7p1n7p1o7p1p7p1q7p1r7p1s7p1t7p1u7p1v7p1w7p1x7p1y7p1z7p207p217p5r7p5s7p5t7p5u7p5v7p5w7p5x7p5y7p5z7p607p9k7p9l7p9m7p9n7p9o7p9p7p9q7p9r7p9s7p9t7pbo7pbp7pbq7pbr7pbs7pbt7pbu7pbv7pbw7pbx7pby7pbz7pc07pc17pc27pc37pc47pc57pc67pc77pc87pe87pe97pea7peb7pec7ped7pee7pef7peg7peh7p1f7q1g7q1h7q1i7q1j7q1k7q1l7q1m7q1n7q1o7q1p7q1q7q1r7q1s7q1t7q1u7q1v7q1w7q1x7q1y7q1z7q207q217q227q237q3f7q3g7q3h7q3i7q3j7q3k7q3l7q3m7q3n7q5r7q5s7q5t7q5u7q5v7q5w7q5x7q5y7q5z7q607q9k7q9l7q9m7q9n7q9o7q9p7q9q7q9r7q9s7q9t7qbm7qbn7qbo7qbp7qbq7qbr7qbs7qbt7qbu7qbv7qbw7qbx7qby7qbz7qc07qc17qc27qc37qc47qc57qc67qc77qc87qc97qca7qe87qe97qea7qeb7qec7qed7qee7qef7qeg7qeh7q1e7r1f7r1g7r1h7r1i7r1j7r1k7r1l7r1m7r1n7r1o7r1p7r1q7r1r7r1s7r1t7r1u7r1v7r1w7r1x7r1y7r1z7r207r217r227r237r247r3e7r3f7r3g7r3h7r3i7r3j7r3k7r3l7r3m7r3n7r5r7r5s7r5t7r5u7r5v7r5w7r5x7r5y7r5z7r607r9k7r9l7r9m7r9n7r9o7r9p7r9q7r9r7r9s7r9t7rbl7rbm7rbn7rbo7rbp7rbq7rbr7rbs7rbt7rbu7rbv7rbw7rbx7rby7rbz7rc07rc17rc27rc37rc47rc57rc67rc77rc87rc97rca7rcb7re87re97rea7reb7rec7red7ree7ref7reg7reh7r1d7s1e7s1f7s1g7s1h7s1i7s1j7s1k7s1l7s1m7s1n7s1o7s1p7s1q7s1r7s1s7s1t7s1u7s1v7s1w7s1x7s1y7s1z7s207s217s227s237s247s257s3e7s3f7s3g7s3h7s3i7s3j7s3k7s3l7s3m7s3n7s5r7s5s7s5t7s5u7s5v7s5w7s5x7s5y7s5z7s607s9k7s9l7s9m7s9n7s9o7s9p7s9q7s9r7s9s7s9t7sbk7sbl7sbm7sbn7sbo7sbp7sbq7sbr7sbs7sbt7sbu7sbv7sbw7sbx7sby7sbz7sc07sc17sc27sc37sc47sc57sc67sc77sc87sc97sca7scb7scc7se87se97sea7seb7sec7sed7see7sef7seg7seh7s1c7t1d7t1e7t1f7t1g7t1h7t1i7t1j7t1k7t1l7t1m7t1n7t1o7t1p7t1q7t1r7t1s7t1t7t1u7t1v7t1w7t1x7t1y7t1z7t207t217t227t237t247t257t267t3e7t3f7t3g7t3h7t3i7t3j7t3k7t3l7t3m7t3n7t5r7t5s7t5t7t5u7t5v7t5w7t5x7t5y7t5z7t607t9k7t9l7t9m7t9n7t9o7t9p7t9q7t9r7t9s7t9t7tbj7tbk7tbl7tbm7tbn7tbo7tbp7tbq7tbr7tbs7tbt7tbu7tbv7tbw7tbx7tby7tbz7tc07tc17tc27tc37tc47tc57tc67tc77tc87tc97tca7tcb7tcc7tcd7te87te97tea7teb7tec7ted7tee7tef7teg7teh7t1b7u1c7u1d7u1e7u1f7u1g7u1h7u1i7u1j7u1k7u1l7u1m7u1n7u1o7u1p7u1q7u1r7u1s7u1t7u1u7u1v7u1w7u1x7u1y7u1z7u207u217u227u237u247u257u267u277u3e7u3f7u3g7u3h7u3i7u3j7u3k7u3l7u3m7u3n7u5r7u5s7u5t7u5u7u5v7u5w7u5x7u5y7u5z7u607u9k7u9l7u9m7u9n7u9o7u9p7u9q7u9r7u9s7u9t7ubi7ubj7ubk7ubl7ubm7ubn7ubo7ubp7ubq7ubr7ubs7ubt7ubu7ubv7ubw7ubx7uby7ubz7uc07uc17uc27uc37uc47uc57uc67uc77uc87uc97uca7ucb7ucc7ucd7uce7ue87ue97uea7ueb7uec7ued7uee7uef7ueg7ueh7u1b7v1c7v1d7v1e7v1f7v1g7v1h7v1i7v1j7v1k7v1l7v1m7v1n7v1o7v1p7v1q7v1r7v1s7v1t7v1u7v1v7v1w7v1x7v1y7v1z7v207v217v227v237v247v257v267v277v287v3e7v3f7v3g7v3h7v3i7v3j7v3k7v3l7v3m7v3n7v5r7v5s7v5t7v5u7v5v7v5w7v5x7v5y7v5z7v607v9k7v9l7v9m7v9n7v9o7v9p7v9q7v9r7v9s7v9t7vbi7vbj7vbk7vbl7vbm7vbn7vbo7vbp7vbq7vbr7vbs7vbt7vbu7vbv7vbw7vbx7vby7vbz7vc07vc17vc27vc37vc47vc57vc67vc77vc87vc97vca7vcb7vcc7vcd7vce7vcf7ve87ve97vea7veb7vec7ved7vee7vef7veg7veh7v1a7w1b7w1c7w1d7w1e7w1f7w1g7w1h7w1i7w1j7w1k7w1l7w1m7w1n7w1o7w1t7w1u7w1v7w1w7w1x7w1y7w1z7w207w217w227w237w247w257w267w277w287w3e7w3f7w3g7w3h7w3i7w3j7w3k7w3l7w3m7w3n7w5r7w5s7w5t7w5u7w5v7w5w7w5x7w5y7w5z7w607w9k7w9l7w9m7w9n7w9o7w9p7w9q7w9r7w9s7w9t7wbh7wbi7wbj7wbk7wbl7wbm7wbn7wbo7wbp7wbq7wbr7wbs7wbt7wbu7wbv7wc07wc17wc27wc37wc47wc57wc67wc77wc87wc97wca7wcb7wcc7wcd7wce7wcf7we87we97wea7web7wec7wed7wee7wef7weg7weh7w1a7x1b7x1c7x1d7x1e7x1f7x1g7x1h7x1i7x1j7x1k7x1l7x1m7x1w7x1x7x1y7x1z7x207x217x227x237x247x257x267x277x287x297x3e7x3f7x3g7x3h7x3i7x3j7x3k7x3l7x3m7x3n7x5r7x5s7x5t7x5u7x5v7x5w7x5x7x5y7x5z7x607xbh7xbi7xbj7xbk7xbl7xbm7xbn7xbo7xbp7xbq7xbr7xbs7xbt7xc37xc47xc57xc67xc77xc87xc97xca7xcb7xcc7xcd7xce7xcf7xcg7xe87xe97xea7xeb7xec7xed7xee7xef7xeg7xeh7x197y1a7y1b7y1c7y1d7y1e7y1f7y1g7y1h7y1i7y1j7y1k7y1l7y1y7y1z7y207y217y227y237y247y257y267y277y287y297y2o7y2p7y2q7y2r7y2s7y2t7y2u7y3e7y3f7y3g7y3h7y3i7y3j7y3k7y3l7y3m7y3n7y467y477y487y497y4a7y4b7y4c7y557y567y577y587y597y5a7y5r7y5s7y5t7y5u7y5v7y5w7y5x7y5y7y5z7y607y7g7y7h7y7i7y7j7y7k7y7l7y7m7y8j7y8k7y8l7y8m7y917y927y937y947y957yac7yad7yae7yaf7yag7yah7ybg7ybh7ybi7ybj7ybk7ybl7ybm7ybn7ybo7ybp7ybq7ybr7ybs7yc57yc67yc77yc87yc97yca7ycb7ycc7ycd7yce7ycf7ycg7ycw7ycx7ycy7ycz7yd07yd17yd27yd37yd47yd57ydx7ydy7ydz7ye07ye17ye87ye97yea7yeb7yec7yed7yee7yef7yeg7yeh7yey7yez7yf07yf17yf27yf37yf47y197z1a7z1b7z1c7z1d7z1e7z1f7z1g7z1h7z1i7z1j7z1k7z1z7z207z217z227z237z247z257z267z277z287z297z2l7z2m7z2n7z2o7z2p7z2q7z2r7z2s7z2t7z2u7z2v7z2w7z2x7z2y7z2z7z3a7z3b7z3c7z3d7z3e7z3f7z3g7z3h7z3i7z3j7z3k7z3l7z3m7z3n7z3o7z3p7z3q7z3r7z3s7z437z447z457z467z477z487z497z4a7z4b7z4c7z4d7z4e7z4f7z4g7z4h7z517z527z537z547z557z567z577z587z597z5a7z5b7z5c7z5d7z5e7z5r7z5s7z5t7z5u7z5v7z5w7z5x7z5y7z5z7z607z657z667z677z687z697z6a7z6b7z6c7z6d7z6e7z6f7z6s7z6t7z6u7z6v7z6w7z6x7z6y7z6z7z707z717z7c7z7d7z7e7z7f7z7g7z7h7z7i7z7j7z7k7z7l7z7m7z7n7z7o7z7p7z7q7z837z847z857z867z877z887z897z8a7z8b7z8c7z8g7z8h7z8i7z8j7z8k7z8l7z8m7z8n7z8o7z8p7z8q7z8y7z8z7z907z917z927z937z947z957z967z977z987z9k7z9l7z9m7z9n7z9o7z9p7z9q7z9r7z9s7z9t7za87za97zaa7zab7zac7zad7zae7zaf7zag7zah7zai7zaj7zak7zal7zbg7zbh7zbi7zbj7zbk7zbl7zbm7zbn7zbo7zbp7zbq7zbr7zc67zc77zc87zc97zca7zcb7zcc7zcd7zce7zcf7zcg7zct7zcu7zcv7zcw7zcx7zcy7zcz7zd07zd17zd27zd37zd47zd57zd67zd77zd87zdt7zdu7zdv7zdw7zdx7zdy7zdz7ze07ze17ze27ze37ze47ze87ze97zea7zeb7zec7zed7zee7zef7zeg7zeh7zeu7zev7zew7zex7zey7zez7zf07zf17zf27zf37zf47zf57zf67zf77zf87z188019801a801b801c801d801e801f801g801h801i801j801z8020802180228023802480258026802780288029802j802k802l802m802n802o802p802q802r802s802t802u802v802w802x802y802z803080318032803a803b803c803d803e803f803g803h803i803j803k803l803m803n803o803p803q803r803s804180428043804480458046804780488049804a804b804c804d804e804f804g804h804i804j804k804z8050805180528053805480558056805780588059805a805b805c805d805e805f805g805h805r805s805t805u805v805w805x805y805z806080658066806780688069806a806b806c806d806e806f806r806s806t806u806v806w806x806y806z80708071807a807b807c807d807e807f807g807h807i807j807k807l807m807n807o807p807q807r807s807t8083808480858086808780888089808a808b808c808e808f808g808h808i808j808k808l808m808n808o808p808q808r808w808x808y808z8090809180928093809480958096809780988099809a809k809l809m809n809o809p809q809r809s809t80a680a780a880a980aa80ab80ac80ad80ae80af80ag80ah80ai80aj80ak80al80am80an80ao80bf80bg80bh80bi80bj80bk80bl80bm80bn80bo80bp80bq80c680c780c880c980ca80cb80cc80cd80ce80cf80cg80cr80cs80ct80cu80cv80cw80cx80cy80cz80d080d180d280d380d480d580d680d780d880d980da80ds80dt80du80dv80dw80dx80dy80dz80e080e180e280e380e480e580e680e880e980ea80eb80ec80ed80ee80ef80eg80eh80et80eu80ev80ew80ex80ey80ez80f080f180f280f380f480f580f680f780f880f980fa80188119811a811b811c811d811e811f811g811h811i811j8120812181228123812481258126812781288129812a812h812i812j812k812l812m812n812o812p812q812r812s812t812u812v812w812x812y812z8130813181328133813a813b813c813d813e813f813g813h813i813j813k813l813m813n813o813p813q813r813s813z8140814181428143814481458146814781488149814a814b814c814d814e814f814g814h814i814j814k814l814y814z8150815181528153815481558156815781588159815a815b815c815d815e815f815g815h815i815r815s815t815u815v815w815x815y815z816081658166816781688169816a816b816c816d816e816f816r816s816t816u816v816w816x816y816z817081718179817a817b817c817d817e817f817g817h817i817j817k817l817m817n817o817p817q817r817s817t817u8183818481858186818781888189818a818b818c818d818e818f818g818h818i818j818k818l818m818n818o818p818q818r818s818v818w818x818y818z8190819181928193819481958196819781988199819a819b819k819l819m819n819o819p819q819r819s819t81a581a681a781a881a981aa81ab81ac81ad81ae81af81ag81ah81ai81aj81ak81al81am81an81ao81ap81bf81bg81bh81bi81bj81bk81bl81bm81bn81bo81bp81bq81c781c881c981ca81cb81cc81cd81ce81cf81cg81ch81cq81cr81cs81ct81cu81cv81cw81cx81cy81cz81d081d181d281d381d481d581d681d781d881d981da81db81dc81dq81dr81ds81dt81du81dv81dw81dx81dy81dz81e081e181e281e381e481e581e681e781e881e981ea81eb81ec81ed81ee81ef81eg81eh81er81es81et81eu81ev81ew81ex81ey81ez81f081f181f281f381f481f581f681f781f881f981fa81fb81188219821a821b821c821d821e821f821g821h821i8220822182228223822482258226822782288229822a822g822h822i822j822k822l822m822n822o822p822q822r822s822t822u822v822w822x822y822z82308231823282338234823a823b823c823d823e823f823g823h823i823j823k823l823m823n823o823p823q823r823s823y823z8240824182428243824482458246824782488249824a824b824c824d824e824f824g824h824i824j824k824l824m824x824y824z8250825182528253825482558256825782588259825a825b825c825d825e825f825g825h825i825j825r825s825t825u825v825w825x825y825z82608266826782688269826a826b826c826d826e826f826g826r826s826t826u826v826w826x826y826z827082788279827a827b827c827d827e827f827g827h827i827j827k827l827m827n827o827p827q827r827s827t827u827v8283828482858286828782888289828a828b828c828d828e828f828g828h828i828j828k828l828m828n828o828p828q828r828s828t828u828v828w828x828y828z8290829182928293829482958296829782988299829a829b829k829l829m829n829o829p829q829r829s829t82a482a582a682a782a882a982aa82ab82ac82ad82ae82af82ag82ah82ai82aj82ak82al82am82an82ao82ap82aq82bf82bg82bh82bi82bj82bk82bl82bm82bn82bo82bp82c782c882c982ca82cb82cc82cd82ce82cf82cg82ch82cp82cq82cr82cs82ct82cu82cv82cw82cx82cy82cz82d082d182d282d382d482d582d682d782d882d982da82db82dc82dd82dp82dq82dr82ds82dt82du82dv82dw82dx82dy82dz82e082e182e282e382e482e582e682e782e882e982ea82eb82ec82ed82ee82ef82eg82eh82eq82er82es82et82eu82ev82ew82ex82ey82ez82f082f182f282f382f482f582f682f782f882f982fa82fb82fc82188319831a831b831c831d831e831f831g831h831i8320832183228323832483258326832783288329832a832g832h832i832j832k832l832m832n832o832p832q832r832s832t832u832v832w832x832y832z833083318332833383348335833a833b833c833d833e833f833g833h833i833j833k833l833m833n833o833p833q833r833s833y833z8340834183428343834483458346834783488349834a834b834c834d834e834f834g834h834i834j834k834l834m834n834w834x834y834z8350835183528353835483558356835783588359835a835b835c835d835e835f835g835h835i835j835k835r835s835t835u835v835w835x835y835z83608366836783688369836a836b836c836d836e836f836g836r836s836t836u836v836w836x836y836z8370837783788379837a837b837c837d837e837f837g837h837i837j837k837l837m837n837o837p837q837r837s837t837u837v8383838483858386838783888389838a838b838c838d838e838f838g838h838i838j838k838l838m838n838o838p838q838r838s838t838u838v838w838x838y838z8390839183928393839483958396839783988399839a839b839c839k839l839m839n839o839p839q839r839s839t83a383a483a583a683a783a883a983aa83ab83ac83ad83ae83af83ag83ah83ai83aj83ak83al83am83an83ao83ap83aq83ar83bf83bg83bh83bi83bj83bk83bl83bm83bn83bo83bp83c783c883c983ca83cb83cc83cd83ce83cf83cg83ch83co83cp83cq83cr83cs83ct83cu83cv83cw83cx83cy83cz83d083d183d283d383d483d583d683d783d883d983da83db83dc83dd83dp83dq83dr83ds83dt83du83dv83dw83dx83dy83dz83e083e183e283e383e483e583e683e783e883e983ea83eb83ec83ed83ee83ef83eg83eh83ep83eq83er83es83et83eu83ev83ew83ex83ey83ez83f083f183f283f383f483f583f683f783f883f983fa83fb83fc83fd831784188419841a841b841c841d841e841f841g841h842f842g842h842i842j842k842l842m842n842o842p842q842r842s842t842u842v842w842x842y842z843084318432843384348435843a843b843c843d843e843f843g843h843i843j843k843l843m843n843o843p843q843r843s843x843y843z8440844184428443844484458446844784488449844a844b844c844d844e844f844g844h844i844j844k844l844m844n844v844w844x844y844z8450845184528453845484558456845784588459845a845b845c845d845e845f845g845h845i845j845k845l845r845s845t845u845v845w845x845y845z84608466846784688469846a846b846c846d846e846f846g846q846r846s846t846u846v846w846x846y846z84708476847784788479847a847b847c847d847e847f847g847h847i847j847k847l847m847n847o847p847q847r847s847t847u847v847w8483848484858486848784888489848a848b848c848d848e848f848g848h848i848j848k848l848m848n848o848p848q848r848s848t848u848v848w848x848y848z8490849184928493849484958496849784988499849a849b849c849k849l849m849n849o849p849q849r849s849t84a284a384a484a584a684a784a884a984aa84ab84ac84ad84ae84af84ag84ah84ai84aj84ak84al84am84an84ao84ap84aq84ar84as84be84bf84bg84bh84bi84bj84bk84bl84bm84bn84bo84cn84co84cp84cq84cr84cs84ct84cu84cv84cw84cx84cy84cz84d084d184d284d384d484d584d684d784d884d984da84db84dc84dd84de84do84dp84dq84dr84ds84dt84du84dv84dw84dx84dy84dz84e084e184e284e384e484e584e684e784e884e984ea84eb84ec84ed84ee84ef84eg84eh84eo84ep84eq84er84es84et84eu84ev84ew84ex84ey84ez84f084f184f284f384f484f584f684f784f884f984fa84fb84fc84fd84fe841785188519851a851b851c851d851e851f851g851h852f852g852h852i852j852k852l852m852n852o852p852q852r852s852t852u852v852w852x852y852z853085318532853385348535853a853b853c853d853e853f853g853h853i853j853k853l853m853n853o853p853q853r853s853x853y853z8540854185428543854485458546854785488549854a854b854c854d854e854f854g854h854i854j854k854l854m854n854v854w854x854y854z8550855185528553855485558556855785588559855a855b855c855d855e855f855g855h855i855j855k855l855r855s855t855u855v855w855x855y855z8560856785688569856a856b856c856d856e856f856g856h856q856r856s856t856u856v856w856x856y856z8576857785788579857a857b857c857d857e857f857g857h857i857j857k857l857m857n857o857p857q857r857s857t857u857v857w8583858485858586858785888589858a858b858c858d858e858f858g858h858i858j858k858l858m858n858o858p858q858r858s858t858u858v858w858x858y858z8590859185928593859485958596859785988599859a859b859c859d859k859l859m859n859o859p859q859r859s859t85a285a385a485a585a685a785a885a985aa85ab85ac85ad85ae85af85ag85ah85ai85aj85ak85al85am85an85ao85ap85aq85ar85as85be85bf85bg85bh85bi85bj85bk85bl85bm85bn85bo85cn85co85cp85cq85cr85cs85ct85cu85cv85cw85cx85cy85cz85d085d185d285d385d485d585d685d785d885d985da85db85dc85dd85de85df85dn85do85dp85dq85dr85ds85dt85du85dv85dw85dx85dy85dz85e085e185e285e385e485e585e685e785e885e985ea85eb85ec85ed85ee85ef85eg85eh85eo85ep85eq85er85es85et85eu85ev85ew85ex85ey85ez85f085f185f285f385f485f585f685f785f885f985fa85fb85fc85fd85fe851786188619861a861b861c861d861e861f861g861h862f862g862h862i862j862k862l862m862n862o862p862q862r862s862t862u862v862w862x862y862z863086318632863386348635863a863b863c863d863e863f863g863h863i863j863k863l863m863n863o863p863q863r863s863x863y863z8640864186428643864486458646864786488649864a864b864c864d864e864f864g864h864i864j864k864l864m864n864u864v864w864x864y864z8650865186528653865486558656865786588659865a865b865c865d865e865f865g865h865i865j865k865l865r865s865t865u865v865w865x865y865z8660866786688669866a866b866c866d866e866f866g866h866q866r866s866t866u866v866w866x866y866z8676867786788679867a867b867c867d867e867f867g867m867n867o867p867q867r867s867t867u867v867w867x8683868486858686868786888689868a868b868c868d868e868f868g868h868i868j868k868l868m868n868o868p868q868r868s868t868u868v868w868x868y868z8690869186928693869486958696869786988699869a869b869c869d869k869l869m869n869o869p869q869r869s869t86a186a286a386a486a586a686a786a886a986aa86ab86ac86ad86ae86af86ag86ah86ai86aj86ak86al86am86an86ao86ap86aq86ar86as86be86bf86bg86bh86bi86bj86bk86bl86bm86bn86bo86cm86cn86co86cp86cq86cr86cs86ct86cu86cv86cw86cx86cy86cz86d086d186d286d386d486d586d686d786d886d986da86db86dc86dd86de86df86dn86do86dp86dq86dr86ds86dt86du86dv86dw86dx86dy86dz86e086e186e286e386e486e586e686e786e886e986ea86eb86ec86ed86ee86ef86eg86eh86en86eo86ep86eq86er86es86et86eu86ev86ew86ex86ey86ez86f086f186f286f386f486f586f686f786f886f986fa86fb86fc86fd86fe86ff861787188719871a871b871c871d871e871f871g871h872e872f872g872h872i872j872k872l872m872n872o872w872x872y872z8730873187328733873487358736873e873f873g873h873i873j873k873l873m873n873w873x873y873z8740874187428743874487458746874e874f874g874h874i874j874k874l874m874n874o874u874v874w874x874y874z875087518752875387548755875b875c875d875e875f875g875h875i875j875k875l875m875r875s875t875u875v875w875x875y875z8760876787688769876a876b876c876d876e876f876g876h876p876q876r876s876t876u876v876w876x876y876z87758776877787788779877a877b877c877d877e877n877o877p877q877r877s877t877u877v877w877x8783878487858786878787888789878a878b878c878d878e878f878j878k878l878m878n878o878p878q878r878s878t878u878v878w878x87928793879487958796879787988799879a879b879c879d879k879l879m879n879o879p879q879r879s879t87a187a287a387a487a587a687a787a887a987aa87ab87ac87ai87aj87ak87al87am87an87ao87ap87aq87ar87as87at87be87bf87bg87bh87bi87bj87bk87bl87bm87bn87bo87cm87cn87co87cp87cq87cr87cs87ct87cu87cv87cw87cx87d487d587d687d787d887d987da87db87dc87dd87de87df87dg87dm87dn87do87dp87dq87dr87ds87dt87du87dv87dw87dx87dy87dz87e387e487e587e687e787e887e987ea87eb87ec87ed87ee87ef87eg87eh87en87eo87ep87eq87er87es87et87eu87ev87ew87ex87ey87f487f587f687f787f887f987fa87fb87fc87fd87fe87ff871788188819881a881b881c881d881e881f881g881h882e882f882g882h882i882j882k882l882m882n882x882y882z8830883188328833883488358836883e883f883g883h883i883j883k883l883m883n883w883x883y883z884088418842884388448845884f884g884h884i884j884k884l884m884n884o884t884u884v884w884x884y884z88508851885288538854885c885d885e885f885g885h885i885j885k885l885m885r885s885t885u885v885w885x885y885z886088688869886a886b886c886d886e886f886g886h886p886q886r886s886t886u886v886w886x886y88758876887788788879887a887b887c887d887e887o887p887q887r887s887t887u887v887w887x8883888488858886888788888889888a888b888c888d888k888l888m888n888o888p888q888r888s888t888u888v888w8893889488958896889788988899889a889b889c889d889k889l889m889n889o889p889q889r889s889t88a088a188a288a388a488a588a688a788a888a988aa88ab88aj88ak88al88am88an88ao88ap88aq88ar88as88at88be88bf88bg88bh88bi88bj88bk88bl88bm88bn88bo88cl88cm88cn88co88cp88cq88cr88cs88ct88cu88cv88cw88d588d688d788d888d988da88db88dc88dd88de88df88dg88dm88dn88do88dp88dq88dr88ds88dt88du88dv88dw88dx88e588e688e788e888e988ea88eb88ec88ed88ee88ef88eg88eh88en88eo88ep88eq88er88es88et88eu88ev88ew88ex88f588f688f788f888f988fa88fb88fc88fd88fe88ff881789188919891a891b891c891d891e891f891g891h892e892f892g892h892i892j892k892l892m892n892w892x892y892z8930893189328933893489358936893e893f893g893h893i893j893k893l893m893n893w893x893y893z894089418942894389448945894e894f894g894h894i894j894k894l894m894n894o894t894u894v894w894x894y894z8950895189528953895c895d895e895f895g895h895i895j895k895l895m895r895s895t895u895v895w895x895y895z896089688969896a896b896c896d896e896f896g896h896i896p896q896r896s896t896u896v896w896x896y89758976897789788979897a897b897c897d897e897f897o897p897q897r897s897t897u897v897w897x8983898489858986898789888989898a898b898c898d898l898m898n898o898p898q898r898s898t898u898v899489958996899789988999899a899b899c899d899k899l899m899n899o899p899q899r899s899t89a089a189a289a389a489a589a689a789a889a989aa89aj89ak89al89am89an89ao89ap89aq89ar89as89at89be89bf89bg89bh89bi89bj89bk89bl89bm89bn89bo89cl89cm89cn89co89cp89cq89cr89cs89ct89cu89cv89d689d789d889d989da89db89dc89dd89de89df89dg89dm89dn89do89dp89dq89dr89ds89dt89du89dv89dw89e689e789e889e989ea89eb89ec89ed89ee89ef89eg89eh89em89en89eo89ep89eq89er89es89et89eu89ev89ew89f689f789f889f989fa89fb89fc89fd89fe89ff89fg89178a188a198a1a8a1b8a1c8a1d8a1e8a1f8a1g8a1h8a2e8a2f8a2g8a2h8a2i8a2j8a2k8a2l8a2m8a2n8a2w8a2x8a2y8a2z8a308a318a328a338a348a358a368a3e8a3f8a3g8a3h8a3i8a3j8a3k8a3l8a3m8a3n8a3w8a3x8a3y8a3z8a408a418a428a438a448a458a4e8a4f8a4g8a4h8a4i8a4j8a4k8a4l8a4m8a4n8a4o8a4t8a4u8a4v8a4w8a4x8a4y8a4z8a508a518a528a538a5d8a5e8a5f8a5g8a5h8a5i8a5j8a5k8a5l8a5m8a5r8a5s8a5t8a5u8a5v8a5w8a5x8a5y8a5z8a608a688a698a6a8a6b8a6c8a6d8a6e8a6f8a6g8a6h8a6i8a6p8a6q8a6r8a6s8a6t8a6u8a6v8a6w8a6x8a6y8a758a768a778a788a798a7a8a7b8a7c8a7d8a7e8a7f8a7g8a7h8a7i8a838a848a858a868a878a888a898a8a8a8b8a8c8a8l8a8m8a8n8a8o8a8p8a8q8a8r8a8s8a8t8a8u8a8v8a948a958a968a978a988a998a9a8a9b8a9c8a9d8a9k8a9l8a9m8a9n8a9o8a9p8a9q8a9r8a9s8a9t8aa08aa18aa28aa38aa48aa58aa68aa78aa88aa98aaa8aak8aal8aam8aan8aao8aap8aaq8aar8aas8aat8abe8abf8abg8abh8abi8abj8abk8abl8abm8abn8abo8acl8acm8acn8aco8acp8acq8acr8acs8act8acu8acv8ad78ad88ad98ada8adb8adc8add8ade8adf8adg8adh8adm8adn8ado8adp8adq8adr8ads8adt8adu8adv8adw8ae78ae88ae98aea8aeb8aec8aed8aee8aef8aeg8aeh8aem8aen8aeo8aep8aeq8aer8aes8aet8aeu8aev8af78af88af98afa8afb8afc8afd8afe8aff8afg8a178b188b198b1a8b1b8b1c8b1d8b1e8b1f8b1g8b1h8b2s8b2t8b2u8b2v8b2w8b2x8b2y8b2z8b308b318b328b338b348b358b368b3e8b3f8b3g8b3h8b3i8b3j8b3k8b3l8b3m8b3n8b4a8b4b8b4c8b4d8b4e8b4f8b4g8b4h8b4i8b4j8b4k8b4l8b4m8b4n8b4o8b4t8b4u8b4v8b4w8b4x8b4y8b4z8b508b518b528b5d8b5e8b5f8b5g8b5h8b5i8b5j8b5k8b5l8b5m8b5r8b5s8b5t8b5u8b5v8b5w8b5x8b5y8b5z8b608b698b6a8b6b8b6c8b6d8b6e8b6f8b6g8b6h8b6i8b6o8b6p8b6q8b6r8b6s8b6t8b6u8b6v8b6w8b6x8b758b768b778b788b798b7a8b7b8b7c8b7d8b7e8b7f8b7g8b7h8b7i8b7j8b7k8b7l8b7m8b7n8b838b848b858b868b878b888b898b8a8b8b8b8c8b8m8b8n8b8o8b8p8b8q8b8r8b8s8b8t8b8u8b8v8b948b958b968b978b988b998b9a8b9b8b9c8b9d8b9k8b9l8b9m8b9n8b9o8b9p8b9q8b9r8b9s8b9t8ba08ba18ba28ba38ba48ba58ba68ba78ba88ba98bak8bal8bam8ban8bao8bap8baq8bar8bas8bat8bbe8bbf8bbg8bbh8bbi8bbj8bbk8bbl8bbm8bbn8bbo8bcl8bcm8bcn8bco8bcp8bcq8bcr8bcs8bct8bcu8bd78bd88bd98bda8bdb8bdc8bdd8bde8bdf8bdg8bdh8bdl8bdm8bdn8bdo8bdp8bdq8bdr8bds8bdt8bdu8bdv8be78be88be98bea8beb8bec8bed8bee8bef8beg8beh8bem8ben8beo8bep8beq8ber8bes8bet8beu8bev8bf78bf88bf98bfa8bfb8bfc8bfd8bfe8bff8bfg8b178c188c198c1a8c1b8c1c8c1d8c1e8c1f8c1g8c1h8c2m8c2n8c2o8c2p8c2q8c2r8c2s8c2t8c2u8c2v8c2w8c2x8c2y8c2z8c308c318c328c338c348c358c368c3e8c3f8c3g8c3h8c3i8c3j8c3k8c3l8c3m8c3n8c448c458c468c478c488c498c4a8c4b8c4c8c4d8c4e8c4f8c4g8c4h8c4i8c4j8c4k8c4l8c4m8c4n8c4o8c4t8c4u8c4v8c4w8c4x8c4y8c4z8c508c518c528c5r8c5s8c5t8c5u8c5v8c5w8c5x8c5y8c5z8c608c698c6a8c6b8c6c8c6d8c6e8c6f8c6g8c6h8c6i8c6j8c6o8c6p8c6q8c6r8c6s8c6t8c6u8c6v8c6w8c6x8c768c778c788c798c7a8c7b8c7c8c7d8c7e8c7f8c7g8c7h8c7i8c7j8c7k8c7l8c7m8c7n8c7o8c7p8c7q8c838c848c858c868c878c888c898c8a8c8b8c8c8c8m8c8n8c8o8c8p8c8q8c8r8c8s8c8t8c8u8c8v8c948c958c968c978c988c998c9a8c9b8c9c8c9d8c9k8c9l8c9m8c9n8c9o8c9p8c9q8c9r8c9s8c9t8ca08ca18ca28ca38ca48ca58ca68ca78ca88ca98cbe8cbf8cbg8cbh8cbi8cbj8cbk8cbl8cbm8cbn8cbo8cck8ccl8ccm8ccn8cco8ccp8ccq8ccr8ccs8cct8ccu8cd88cd98cda8cdb8cdc8cdd8cde8cdf8cdg8cdh8cdl8cdm8cdn8cdo8cdp8cdq8cdr8cds8cdt8cdu8cdv8ce78ce88ce98cea8ceb8cec8ced8cee8cef8ceg8ceh8cem8cen8ceo8cep8ceq8cer8ces8cet8ceu8cev8cew8cex8cey8cez8cf08cf18cf28cf38cf48cf58cf68cf78cf88cf98cfa8cfb8cfc8cfd8cfe8cff8cfg8c178d188d198d1a8d1b8d1c8d1d8d1e8d1f8d1g8d1h8d2j8d2k8d2l8d2m8d2n8d2o8d2p8d2q8d2r8d2s8d2t8d2u8d2v8d2w8d2x8d2y8d2z8d308d318d328d338d348d358d368d3e8d3f8d3g8d3h8d3i8d3j8d3k8d3l8d3m8d3n8d418d428d438d448d458d468d478d488d498d4a8d4b8d4c8d4d8d4e8d4f8d4g8d4h8d4i8d4j8d4k8d4l8d4m8d4n8d4o8d4s8d4t8d4u8d4v8d4w8d4x8d4y8d4z8d508d518d528d5r8d5s8d5t8d5u8d5v8d5w8d5x8d5y8d5z8d608d698d6a8d6b8d6c8d6d8d6e8d6f8d6g8d6h8d6i8d6j8d6o8d6p8d6q8d6r8d6s8d6t8d6u8d6v8d6w8d6x8d768d778d788d798d7a8d7b8d7c8d7d8d7e8d7f8d7g8d7h8d7i8d7j8d7k8d7l8d7m8d7n8d7o8d7p8d7q8d7r8d7s8d7t8d838d848d858d868d878d888d898d8a8d8b8d8c8d8m8d8n8d8o8d8p8d8q8d8r8d8s8d8t8d8u8d8v8d948d958d968d978d988d998d9a8d9b8d9c8d9d8d9k8d9l8d9m8d9n8d9o8d9p8d9q8d9r8d9s8d9t8d9z8da08da18da28da38da48da58da68da78da88da98dbe8dbf8dbg8dbh8dbi8dbj8dbk8dbl8dbm8dbn8dbo8dck8dcl8dcm8dcn8dco8dcp8dcq8dcr8dcs8dct8dcu8dd88dd98dda8ddb8ddc8ddd8dde8ddf8ddg8ddh8ddl8ddm8ddn8ddo8ddp8ddq8ddr8dds8ddt8ddu8ddv8de88de98dea8deb8dec8ded8dee8def8deg8deh8dem8den8deo8dep8deq8der8des8det8deu8dev8dew8dex8dey8dez8df08df18df28df38df48df58df68df78df88df98dfa8dfb8dfc8dfd8dfe8dff8dfg8d178e188e198e1a8e1b8e1c8e1d8e1e8e1f8e1g8e1h8e2h8e2i8e2j8e2k8e2l8e2m8e2n8e2o8e2p8e2q8e2r8e2s8e2t8e2u8e2v8e2w8e2x8e2y8e2z8e308e318e328e338e348e358e368e3e8e3f8e3g8e3h8e3i8e3j8e3k8e3l8e3m8e3n8e3z8e408e418e428e438e448e458e468e478e488e498e4a8e4b8e4c8e4d8e4e8e4f8e4g8e4h8e4i8e4j8e4k8e4l8e4m8e4n8e4o8e4s8e4t8e4u8e4v8e4w8e4x8e4y8e4z8e508e518e528e5r8e5s8e5t8e5u8e5v8e5w8e5x8e5y8e5z8e608e6a8e6b8e6c8e6d8e6e8e6f8e6g8e6h8e6i8e6j8e6n8e6o8e6p8e6q8e6r8e6s8e6t8e6u8e6v8e6w8e768e778e788e798e7a8e7b8e7c8e7d8e7e8e7f8e7g8e7h8e7i8e7j8e7k8e7l8e7m8e7n8e7o8e7p8e7q8e7r8e7s8e7t8e7u8e838e848e858e868e878e888e898e8a8e8b8e8c8e8m8e8n8e8o8e8p8e8q8e8r8e8s8e8t8e8u8e8v8e948e958e968e978e988e998e9a8e9b8e9c8e9d8e9k8e9l8e9m8e9n8e9o8e9p8e9q8e9r8e9s8e9t8e9z8ea08ea18ea28ea38ea48ea58ea68ea78ea88ea98ebe8ebf8ebg8ebh8ebi8ebj8ebk8ebl8ebm8ebn8ebo8eck8ecl8ecm8ecn8eco8ecp8ecq8ecr8ecs8ect8ecu8ed88ed98eda8edb8edc8edd8ede8edf8edg8edh8edl8edm8edn8edo8edp8edq8edr8eds8edt8edu8ee88ee98eea8eeb8eec8eed8eee8eef8eeg8eeh8eem8een8eeo8eep8eeq8eer8ees8eet8eeu8eev8eew8eex8eey8eez8ef08ef18ef28ef38ef48ef58ef68ef78ef88ef98efa8efb8efc8efd8efe8eff8efg8e178f188f198f1a8f1b8f1c8f1d8f1e8f1f8f1g8f1h8f2g8f2h8f2i8f2j8f2k8f2l8f2m8f2n8f2o8f2p8f2q8f2r8f2s8f2t8f2u8f2v8f2w8f2x8f2y8f2z8f308f318f328f338f348f358f368f3e8f3f8f3g8f3h8f3i8f3j8f3k8f3l8f3m8f3n8f3y8f3z8f408f418f428f438f448f458f468f478f488f498f4a8f4b8f4c8f4d8f4e8f4f8f4g8f4h8f4i8f4j8f4k8f4l8f4m8f4n8f4o8f4s8f4t8f4u8f4v8f4w8f4x8f4y8f4z8f508f518f528f5r8f5s8f5t8f5u8f5v8f5w8f5x8f5y8f5z8f608f6a8f6b8f6c8f6d8f6e8f6f8f6g8f6h8f6i8f6j8f6n8f6o8f6p8f6q8f6r8f6s8f6t8f6u8f6v8f6w8f778f788f798f7a8f7b8f7c8f7d8f7e8f7f8f7g8f7h8f7i8f7j8f7k8f7l8f7m8f7n8f7o8f7p8f7q8f7r8f7s8f7t8f7u8f7v8f838f848f858f868f878f888f898f8a8f8b8f8c8f8m8f8n8f8o8f8p8f8q8f8r8f8s8f8t8f8u8f8v8f948f958f968f978f988f998f9a8f9b8f9c8f9d8f9k8f9l8f9m8f9n8f9o8f9p8f9q8f9r8f9s8f9t8f9z8fa08fa18fa28fa38fa48fa58fa68fa78fa88fa98fbe8fbf8fbg8fbh8fbi8fbj8fbk8fbl8fbm8fbn8fbo8fck8fcl8fcm8fcn8fco8fcp8fcq8fcr8fcs8fct8fd88fd98fda8fdb8fdc8fdd8fde8fdf8fdg8fdh8fdl8fdm8fdn8fdo8fdp8fdq8fdr8fds8fdt8fdu8fe88fe98fea8feb8fec8fed8fee8fef8feg8feh8fem8fen8feo8fep8feq8fer8fes8fet8feu8fev8few8fex8fey8fez8ff08ff18ff28ff38ff48ff58ff68ff78ff88ff98ffa8ffb8ffc8ffd8ffe8fff8ffg8f178g188g198g1a8g1b8g1c8g1d8g1e8g1f8g1g8g1h8g208g218g228g238g248g258g268g278g288g298g2a8g2f8g2g8g2h8g2i8g2j8g2k8g2l8g2m8g2n8g2o8g2p8g2q8g2r8g2s8g2t8g2u8g2v8g2w8g2x8g2y8g2z8g308g318g328g338g348g358g368g3e8g3f8g3g8g3h8g3i8g3j8g3k8g3l8g3m8g3n8g3x8g3y8g3z8g408g418g428g438g448g458g468g478g488g498g4a8g4b8g4c8g4d8g4e8g4f8g4g8g4h8g4i8g4j8g4k8g4l8g4m8g4n8g4o8g4s8g4t8g4u8g4v8g4w8g4x8g4y8g4z8g508g518g528g5r8g5s8g5t8g5u8g5v8g5w8g5x8g5y8g5z8g608g6b8g6c8g6d8g6e8g6f8g6g8g6h8g6i8g6j8g6k8g6n8g6o8g6p8g6q8g6r8g6s8g6t8g6u8g6v8g788g798g7a8g7b8g7c8g7d8g7e8g7f8g7g8g7h8g7i8g7j8g7k8g7l8g7m8g7n8g7o8g7p8g7q8g7r8g7s8g7t8g7u8g7v8g7w8g838g848g858g868g878g888g898g8a8g8b8g8c8g8m8g8n8g8o8g8p8g8q8g8r8g8s8g8t8g8u8g8v8g948g958g968g978g988g998g9a8g9b8g9c8g9d8g9k8g9l8g9m8g9n8g9o8g9p8g9q8g9r8g9s8g9t8g9z8ga08ga18ga28ga38ga48ga58ga68ga78ga88ga98gbe8gbf8gbg8gbh8gbi8gbj8gbk8gbl8gbm8gbn8gbo8gc78gc88gc98gca8gcb8gcc8gcd8gce8gcf8gcg8gch8gck8gcl8gcm8gcn8gco8gcp8gcq8gcr8gcs8gct8gcu8gd88gd98gda8gdb8gdc8gdd8gde8gdf8gdg8gdh8gdl8gdm8gdn8gdo8gdp8gdq8gdr8gds8gdt8gdu8ge88ge98gea8geb8gec8ged8gee8gef8geg8geh8gem8gen8geo8gep8geq8ger8ges8get8geu8gev8gew8gex8gey8gez8gf08gf18gf28gf38gf48gf58gf68gf78gf88gf98gfa8gfb8gfc8gfd8gfe8gff8gfg8g188h198h1a8h1b8h1c8h1d8h1e8h1f8h1g8h1h8h1i8h208h218h228h238h248h258h268h278h288h298h2a8h2e8h2f8h2g8h2h8h2i8h2j8h2k8h2l8h2m8h2n8h2o8h2p8h2q8h2r8h2s8h2t8h2u8h2v8h2w8h2x8h2y8h2z8h308h318h328h338h348h358h368h3e8h3f8h3g8h3h8h3i8h3j8h3k8h3l8h3m8h3n8h3w8h3x8h3y8h3z8h408h418h428h438h448h458h468h478h488h498h4a8h4b8h4c8h4d8h4e8h4f8h4g8h4h8h4i8h4j8h4k8h4l8h4m8h4n8h4o8h4s8h4t8h4u8h4v8h4w8h4x8h4y8h4z8h508h518h528h5r8h5s8h5t8h5u8h5v8h5w8h5x8h5y8h5z8h608h6b8h6c8h6d8h6e8h6f8h6g8h6h8h6i8h6j8h6k8h6n8h6o8h6p8h6q8h6r8h6s8h6t8h6u8h6v8h7a8h7b8h7c8h7d8h7e8h7f8h7g8h7h8h7i8h7j8h7k8h7l8h7m8h7n8h7o8h7p8h7q8h7r8h7s8h7t8h7u8h7v8h7w8h7x8h838h848h858h868h878h888h898h8a8h8b8h8c8h8m8h8n8h8o8h8p8h8q8h8r8h8s8h8t8h8u8h8v8h948h958h968h978h988h998h9a8h9b8h9c8h9d8h9k8h9l8h9m8h9n8h9o8h9p8h9q8h9r8h9s8h9t8h9z8ha08ha18ha28ha38ha48ha58ha68ha78ha88ha98hbf8hbg8hbh8hbi8hbj8hbk8hbl8hbm8hbn8hbo8hbp8hc78hc88hc98hca8hcb8hcc8hcd8hce8hcf8hcg8hch8hck8hcl8hcm8hcn8hco8hcp8hcq8hcr8hcs8hct8hcu8hd88hd98hda8hdb8hdc8hdd8hde8hdf8hdg8hdh8hdl8hdm8hdn8hdo8hdp8hdq8hdr8hds8hdt8hdu8he88he98hea8heb8hec8hed8hee8hef8heg8heh8hem8hen8heo8hep8heq8her8hes8het8heu8hev8hew8hex8hey8hez8hf08hf18hf28hf38hf48hf58hf68hf78hf88hf98hfa8hfb8hfc8hfd8hfe8hff8hfg8h188i198i1a8i1b8i1c8i1d8i1e8i1f8i1g8i1h8i1i8i208i218i228i238i248i258i268i278i288i298i2a8i2e8i2f8i2g8i2h8i2i8i2j8i2k8i2l8i2m8i2n8i2o8i2p8i2q8i2r8i2s8i2x8i2y8i2z8i308i318i328i338i348i358i368i3e8i3f8i3g8i3h8i3i8i3j8i3k8i3l8i3m8i3n8i3w8i3x8i3y8i3z8i408i418i428i438i448i458i468i478i488i498i4a8i4f8i4g8i4h8i4i8i4j8i4k8i4l8i4m8i4n8i4o8i4s8i4t8i4u8i4v8i4w8i4x8i4y8i4z8i508i518i528i5r8i5s8i5t8i5u8i5v8i5w8i5x8i5y8i5z8i608i6b8i6c8i6d8i6e8i6f8i6g8i6h8i6i8i6j8i6k8i6m8i6n8i6o8i6p8i6q8i6r8i6s8i6t8i6u8i6v8i7c8i7d8i7e8i7f8i7g8i7h8i7i8i7j8i7k8i7l8i7m8i7n8i7o8i7p8i7q8i7r8i7s8i7t8i7u8i7v8i7w8i7x8i838i848i858i868i878i888i898i8a8i8b8i8c8i8m8i8n8i8o8i8p8i8q8i8r8i8s8i8t8i8u8i8v8i948i958i968i978i988i998i9a8i9b8i9c8i9d8i9k8i9l8i9m8i9n8i9o8i9p8i9q8i9r8i9s8i9t8i9z8ia08ia18ia28ia38ia48ia58ia68ia78ia88ia98ibf8ibg8ibh8ibi8ibj8ibk8ibl8ibm8ibn8ibo8ibp8ic78ic88ic98ica8icb8icc8icd8ice8icf8icg8ich8ick8icl8icm8icn8ico8icp8icq8icr8ics8ict8icu8id88id98ida8idb8idc8idd8ide8idf8idg8idh8idl8idm8idn8ido8idp8idq8idr8ids8idt8idu8idv8ie88ie98iea8ieb8iec8ied8iee8ief8ieg8ieh8iem8ien8ieo8iep8ieq8ier8ies8iet8ieu8iev8iew8iex8iey8iez8if08if18if28if38if48if58if68if78if88if98ifa8ifb8ifc8ifd8ife8iff8ifg8i188j198j1a8j1b8j1c8j1d8j1e8j1f8j1g8j1h8j1i8j1j8j1z8j208j218j228j238j248j258j268j278j288j298j2d8j2e8j2f8j2g8j2h8j2i8j2j8j2k8j2l8j2m8j2n8j2o8j2x8j2y8j2z8j308j318j328j338j348j358j368j3e8j3f8j3g8j3h8j3i8j3j8j3k8j3l8j3m8j3n8j3v8j3w8j3x8j3y8j3z8j408j418j428j438j448j458j468j4f8j4g8j4h8j4i8j4j8j4k8j4l8j4m8j4n8j4o8j4s8j4t8j4u8j4v8j4w8j4x8j4y8j4z8j508j518j528j5d8j5e8j5f8j5g8j5h8j5i8j5j8j5k8j5l8j5m8j5r8j5s8j5t8j5u8j5v8j5w8j5x8j5y8j5z8j608j6c8j6d8j6e8j6f8j6g8j6h8j6i8j6j8j6k8j6l8j6m8j6n8j6o8j6p8j6q8j6r8j6s8j6t8j6u8j7f8j7g8j7h8j7i8j7j8j7k8j7l8j7m8j7n8j7o8j7p8j7q8j7r8j7s8j7t8j7u8j7v8j7w8j7x8j838j848j858j868j878j888j898j8a8j8b8j8c8j8m8j8n8j8o8j8p8j8q8j8r8j8s8j8t8j8u8j8v8j948j958j968j978j988j998j9a8j9b8j9c8j9d8j9k8j9l8j9m8j9n8j9o8j9p8j9q8j9r8j9s8j9t8j9z8ja08ja18ja28ja38ja48ja58ja68ja78ja88ja98jak8jal8jam8jan8jao8jap8jaq8jar8jas8jat8jbf8jbg8jbh8jbi8jbj8jbk8jbl8jbm8jbn8jbo8jbp8jbq8jc68jc78jc88jc98jca8jcb8jcc8jcd8jce8jcf8jcg8jck8jcl8jcm8jcn8jco8jcp8jcq8jcr8jcs8jct8jcu8jd88jd98jda8jdb8jdc8jdd8jde8jdf8jdg8jdh8jdl8jdm8jdn8jdo8jdp8jdq8jdr8jds8jdt8jdu8jdv8je78je88je98jea8jeb8jec8jed8jee8jef8jeg8jeh8jem8jen8jeo8jep8jeq8jer8jes8jet8jeu8jev8j188k198k1a8k1b8k1c8k1d8k1e8k1f8k1g8k1h8k1i8k1j8k1z8k208k218k228k238k248k258k268k278k288k298k2d8k2e8k2f8k2g8k2h8k2i8k2j8k2k8k2l8k2m8k2n8k2w8k2x8k2y8k2z8k308k318k328k338k348k358k368k3e8k3f8k3g8k3h8k3i8k3j8k3k8k3l8k3m8k3n8k3v8k3w8k3x8k3y8k3z8k408k418k428k438k448k458k4e8k4f8k4g8k4h8k4i8k4j8k4k8k4l8k4m8k4n8k4o8k4t8k4u8k4v8k4w8k4x8k4y8k4z8k508k518k528k5d8k5e8k5f8k5g8k5h8k5i8k5j8k5k8k5l8k5m8k5r8k5s8k5t8k5u8k5v8k5w8k5x8k5y8k5z8k608k6c8k6d8k6e8k6f8k6g8k6h8k6i8k6j8k6k8k6l8k6m8k6n8k6o8k6p8k6q8k6r8k6s8k6t8k6u8k7j8k7k8k7l8k7m8k7n8k7o8k7p8k7q8k7r8k7s8k7t8k7u8k7v8k7w8k7x8k7y8k838k848k858k868k878k888k898k8a8k8b8k8c8k8m8k8n8k8o8k8p8k8q8k8r8k8s8k8t8k8u8k8v8k948k958k968k978k988k998k9a8k9b8k9c8k9d8k9k8k9l8k9m8k9n8k9o8k9p8k9q8k9r8k9s8k9t8ka08ka18ka28ka38ka48ka58ka68ka78ka88ka98kak8kal8kam8kan8kao8kap8kaq8kar8kas8kat8kbf8kbg8kbh8kbi8kbj8kbk8kbl8kbm8kbn8kbo8kbp8kbq8kc68kc78kc88kc98kca8kcb8kcc8kcd8kce8kcf8kcg8kcl8kcm8kcn8kco8kcp8kcq8kcr8kcs8kct8kcu8kd78kd88kd98kda8kdb8kdc8kdd8kde8kdf8kdg8kdh8kdl8kdm8kdn8kdo8kdp8kdq8kdr8kds8kdt8kdu8kdv8ke78ke88ke98kea8keb8kec8ked8kee8kef8keg8keh8kem8ken8keo8kep8keq8ker8kes8ket8keu8kev8k198l1a8l1b8l1c8l1d8l1e8l1f8l1g8l1h8l1i8l1j8l1k8l1y8l1z8l208l218l228l238l248l258l268l278l288l298l2d8l2e8l2f8l2g8l2h8l2i8l2j8l2k8l2l8l2m8l2w8l2x8l2y8l2z8l308l318l328l338l348l358l368l3e8l3f8l3g8l3h8l3i8l3j8l3k8l3l8l3m8l3n8l3v8l3w8l3x8l3y8l3z8l408l418l428l438l448l4e8l4f8l4g8l4h8l4i8l4j8l4k8l4l8l4m8l4n8l4o8l4t8l4u8l4v8l4w8l4x8l4y8l4z8l508l518l528l538l5d8l5e8l5f8l5g8l5h8l5i8l5j8l5k8l5l8l5m8l5r8l5s8l5t8l5u8l5v8l5w8l5x8l5y8l5z8l608l6c8l6d8l6e8l6f8l6g8l6h8l6i8l6j8l6k8l6l8l6m8l6n8l6o8l6p8l6q8l6r8l6s8l6t8l6u8l748l758l768l778l788l798l7a8l7b8l7c8l7d8l7n8l7o8l7p8l7q8l7r8l7s8l7t8l7u8l7v8l7w8l7x8l7y8l838l848l858l868l878l888l898l8a8l8b8l8c8l8m8l8n8l8o8l8p8l8q8l8r8l8s8l8t8l8u8l8v8l948l958l968l978l988l998l9a8l9b8l9c8l9d8l9k8l9l8l9m8l9n8l9o8l9p8l9q8l9r8l9s8l9t8la08la18la28la38la48la58la68la78la88la98laa8lak8lal8lam8lan8lao8lap8laq8lar8las8lat8lbg8lbh8lbi8lbj8lbk8lbl8lbm8lbn8lbo8lbp8lbq8lbr8lc58lc68lc78lc88lc98lca8lcb8lcc8lcd8lce8lcf8lcg8lcl8lcm8lcn8lco8lcp8lcq8lcr8lcs8lct8lcu8lcv8ld78ld88ld98lda8ldb8ldc8ldd8lde8ldf8ldg8ldh8ldm8ldn8ldo8ldp8ldq8ldr8lds8ldt8ldu8ldv8ldw8le78le88le98lea8leb8lec8led8lee8lef8leg8leh8lem8len8leo8lep8leq8ler8les8let8leu8lev8l198m1a8m1b8m1c8m1d8m1e8m1f8m1g8m1h8m1i8m1j8m1k8m1l8m1x8m1y8m1z8m208m218m228m238m248m258m268m278m288m2d8m2e8m2f8m2g8m2h8m2i8m2j8m2k8m2l8m2m8m2w8m2x8m2y8m2z8m308m318m328m338m348m358m368m3e8m3f8m3g8m3h8m3i8m3j8m3k8m3l8m3m8m3n8m3v8m3w8m3x8m3y8m3z8m408m418m428m438m448m4e8m4f8m4g8m4h8m4i8m4j8m4k8m4l8m4m8m4n8m4o8m4t8m4u8m4v8m4w8m4x8m4y8m4z8m508m518m528m538m5c8m5d8m5e8m5f8m5g8m5h8m5i8m5j8m5k8m5l8m5m8m5r8m5s8m5t8m5u8m5v8m5w8m5x8m5y8m5z8m608m6d8m6e8m6f8m6g8m6h8m6i8m6j8m6k8m6l8m6m8m6n8m6o8m6p8m6q8m6r8m6s8m6t8m748m758m768m778m788m798m7a8m7b8m7c8m7d8m7o8m7p8m7q8m7r8m7s8m7t8m7u8m7v8m7w8m7x8m7y8m838m848m858m868m878m888m898m8a8m8b8m8c8m8m8m8n8m8o8m8p8m8q8m8r8m8s8m8t8m8u8m8v8m948m958m968m978m988m998m9a8m9b8m9c8m9d8m9k8m9l8m9m8m9n8m9o8m9p8m9q8m9r8m9s8m9t8ma08ma18ma28ma38ma48ma58ma68ma78ma88ma98maa8maj8mak8mal8mam8man8mao8map8maq8mar8mas8mat8mbg8mbh8mbi8mbj8mbk8mbl8mbm8mbn8mbo8mbp8mbq8mbr8mbs8mc48mc58mc68mc78mc88mc98mca8mcb8mcc8mcd8mce8mcf8mcl8mcm8mcn8mco8mcp8mcq8mcr8mcs8mct8mcu8mcv8md68md78md88md98mda8mdb8mdc8mdd8mde8mdf8mdg8mdm8mdn8mdo8mdp8mdq8mdr8mds8mdt8mdu8mdv8mdw8me68me78me88me98mea8meb8mec8med8mee8mef8meg8meh8mem8men8meo8mep8meq8mer8mes8met8meu8mev8mew8mf68mf78mf88mf98mfa8mfb8mfc8mfd8mfe8mff8mfg8m1a8n1b8n1c8n1d8n1e8n1f8n1g8n1h8n1i8n1j8n1k8n1l8n1m8n1n8n1v8n1w8n1x8n1y8n1z8n208n218n228n238n248n258n268n278n288n2d8n2e8n2f8n2g8n2h8n2i8n2j8n2k8n2l8n2m8n2v8n2w8n2x8n2y8n2z8n308n318n328n338n348n358n368n3e8n3f8n3g8n3h8n3i8n3j8n3k8n3l8n3m8n3n8n3v8n3w8n3x8n3y8n3z8n408n418n428n438n448n4d8n4e8n4f8n4g8n4h8n4i8n4j8n4k8n4l8n4m8n4n8n4o8n4t8n4u8n4v8n4w8n4x8n4y8n4z8n508n518n528n538n548n5c8n5d8n5e8n5f8n5g8n5h8n5i8n5j8n5k8n5l8n5m8n5r8n5s8n5t8n5u8n5v8n5w8n5x8n5y8n5z8n608n6d8n6e8n6f8n6g8n6h8n6i8n6j8n6k8n6l8n6m8n6n8n6o8n6p8n6q8n6r8n6s8n6t8n748n758n768n778n788n798n7a8n7b8n7c8n7d8n7e8n7p8n7q8n7r8n7s8n7t8n7u8n7v8n7w8n7x8n7y8n838n848n858n868n878n888n898n8a8n8b8n8c8n8m8n8n8n8o8n8p8n8q8n8r8n8s8n8t8n8u8n8v8n948n958n968n978n988n998n9a8n9b8n9c8n9d8n9k8n9l8n9m8n9n8n9o8n9p8n9q8n9r8n9s8n9t8na08na18na28na38na48na58na68na78na88na98naa8nab8naj8nak8nal8nam8nan8nao8nap8naq8nar8nas8nat8nbh8nbi8nbj8nbk8nbl8nbm8nbn8nbo8nbp8nbq8nbr8nbs8nbt8nbu8nc28nc38nc48nc58nc68nc78nc88nc98nca8ncb8ncc8ncd8nce8ncf8ncl8ncm8ncn8nco8ncp8ncq8ncr8ncs8nct8ncu8ncv8ncw8nd58nd68nd78nd88nd98nda8ndb8ndc8ndd8nde8ndf8ndg8ndm8ndn8ndo8ndp8ndq8ndr8nds8ndt8ndu8ndv8ndw8ndx8ne58ne68ne78ne88ne98nea8neb8nec8ned8nee8nef8neg8neh8nen8neo8nep8neq8ner8nes8net8neu8nev8new8nex8nf68nf78nf88nf98nfa8nfb8nfc8nfd8nfe8nff8nfg8n1a8o1b8o1c8o1d8o1e8o1f8o1g8o1h8o1i8o1j8o1k8o1l8o1m8o1n8o1o8o1p8o1q8o1r8o1s8o1t8o1u8o1v8o1w8o1x8o1y8o1z8o208o218o228o238o248o258o268o278o2d8o2e8o2f8o2g8o2h8o2i8o2j8o2k8o2l8o2m8o2n8o2u8o2v8o2w8o2x8o2y8o2z8o308o318o328o338o348o358o368o3e8o3f8o3g8o3h8o3i8o3j8o3k8o3l8o3m8o3n8o3v8o3w8o3x8o3y8o3z8o408o418o428o438o448o458o4c8o4d8o4e8o4f8o4g8o4h8o4i8o4j8o4k8o4l8o4m8o4n8o4o8o4u8o4v8o4w8o4x8o4y8o4z8o508o518o528o538o548o558o5a8o5b8o5c8o5d8o5e8o5f8o5g8o5h8o5i8o5j8o5k8o5l8o5r8o5s8o5t8o5u8o5v8o5w8o5x8o5y8o5z8o608o6d8o6e8o6f8o6g8o6h8o6i8o6j8o6k8o6l8o6m8o6n8o6o8o6p8o6q8o6r8o6s8o6t8o748o758o768o778o788o798o7a8o7b8o7c8o7d8o7e8o7f8o7o8o7p8o7q8o7r8o7s8o7t8o7u8o7v8o7w8o7x8o7y8o838o848o858o868o878o888o898o8a8o8b8o8c8o8m8o8n8o8o8o8p8o8q8o8r8o8s8o8t8o8u8o8v8o948o958o968o978o988o998o9a8o9b8o9c8o9d8o9k8o9l8o9m8o9n8o9o8o9p8o9q8o9r8o9s8o9t8oa18oa28oa38oa48oa58oa68oa78oa88oa98oaa8oab8oac8oah8oai8oaj8oak8oal8oam8oan8oao8oap8oaq8oar8oas8obh8obi8obj8obk8obl8obm8obn8obo8obp8obq8obr8obs8obt8obu8obv8obw8obx8oby8obz8oc08oc18oc28oc38oc48oc58oc68oc78oc88oc98oca8ocb8occ8ocd8oce8ocm8ocn8oco8ocp8ocq8ocr8ocs8oct8ocu8ocv8ocw8ocx8ocy8od38od48od58od68od78od88od98oda8odb8odc8odd8ode8odf8odg8odm8odn8odo8odp8odq8odr8ods8odt8odu8odv8odw8odx8ody8odz8oe38oe48oe58oe68oe78oe88oe98oea8oeb8oec8oed8oee8oef8oeg8oeh8oen8oeo8oep8oeq8oer8oes8oet8oeu8oev8oew8oex8oey8of48of58of68of78of88of98ofa8ofb8ofc8ofd8ofe8off8o1b8p1c8p1d8p1e8p1f8p1g8p1h8p1i8p1j8p1k8p1l8p1m8p1n8p1o8p1p8p1q8p1r8p1s8p1t8p1u8p1v8p1w8p1x8p1y8p1z8p208p218p228p238p248p258p268p278p2d8p2e8p2f8p2g8p2h8p2i8p2j8p2k8p2l8p2m8p2n8p2o8p2s8p2t8p2u8p2v8p2w8p2x8p2y8p2z8p308p318p328p338p348p358p368p3e8p3f8p3g8p3h8p3i8p3j8p3k8p3l8p3m8p3n8p3o8p3p8p3q8p3r8p3s8p3v8p3w8p3x8p3y8p3z8p408p418p428p438p448p458p468p4a8p4b8p4c8p4d8p4e8p4f8p4g8p4h8p4i8p4j8p4k8p4l8p4m8p4n8p4o8p4u8p4v8p4w8p4x8p4y8p4z8p508p518p528p538p548p558p568p578p588p598p5a8p5b8p5c8p5d8p5e8p5f8p5g8p5h8p5i8p5j8p5k8p5l8p5r8p5s8p5t8p5u8p5v8p5w8p5x8p5y8p5z8p608p6e8p6f8p6g8p6h8p6i8p6j8p6k8p6l8p6m8p6n8p6o8p6p8p6q8p6r8p6s8p758p768p778p788p798p7a8p7b8p7c8p7d8p7e8p7f8p7g8p7h8p7i8p7j8p7l8p7m8p7n8p7o8p7p8p7q8p7r8p7s8p7t8p7u8p7v8p7w8p7x8p838p848p858p868p878p888p898p8a8p8b8p8c8p8m8p8n8p8o8p8p8p8q8p8r8p8s8p8t8p8u8p8v8p948p958p968p978p988p998p9a8p9b8p9c8p9d8p9k8p9l8p9m8p9n8p9o8p9p8p9q8p9r8p9s8p9t8pa18pa28pa38pa48pa58pa68pa78pa88pa98paa8pab8pac8pad8pae8paf8pag8pah8pai8paj8pak8pal8pam8pan8pao8pap8paq8par8pas8pbi8pbj8pbk8pbl8pbm8pbn8pbo8pbp8pbq8pbr8pbs8pbt8pbu8pbv8pbw8pbx8pby8pbz8pc08pc18pc28pc38pc48pc58pc68pc78pc88pc98pca8pcb8pcc8pcd8pce8pcm8pcn8pco8pcp8pcq8pcr8pcs8pct8pcu8pcv8pcw8pcx8pcy8pcz8pd08pd18pd28pd38pd48pd58pd68pd78pd88pd98pda8pdb8pdc8pdd8pde8pdf8pdn8pdo8pdp8pdq8pdr8pds8pdt8pdu8pdv8pdw8pdx8pdy8pdz8pe08pe18pe28pe38pe48pe58pe68pe78pe88pe98pea8peb8pec8ped8pee8pef8peg8peh8pen8peo8pep8peq8per8pes8pet8peu8pev8pew8pex8pey8pez8pf08pf18pf28pf38pf48pf58pf68pf78pf88pf98pfa8pfb8pfc8pfd8pfe8pff8p1c8q1d8q1e8q1f8q1g8q1h8q1i8q1j8q1k8q1l8q1m8q1n8q1o8q1p8q1q8q1r8q1s8q1t8q1u8q1v8q1w8q1x8q1y8q1z8q208q218q228q238q248q258q268q2d8q2e8q2f8q2g8q2h8q2i8q2j8q2k8q2l8q2m8q2n8q2o8q2p8q2q8q2r8q2s8q2t8q2u8q2v8q2w8q2x8q2y8q2z8q308q318q328q338q348q358q368q3e8q3f8q3g8q3h8q3i8q3j8q3k8q3l8q3m8q3n8q3o8q3p8q3q8q3r8q3s8q3v8q3w8q3x8q3y8q3z8q408q418q428q438q448q458q468q478q488q498q4a8q4b8q4c8q4d8q4e8q4f8q4g8q4h8q4i8q4j8q4k8q4l8q4m8q4n8q4o8q4u8q4v8q4w8q4x8q4y8q4z8q508q518q528q538q548q558q568q578q588q598q5a8q5b8q5c8q5d8q5e8q5f8q5g8q5h8q5i8q5j8q5k8q5r8q5s8q5t8q5u8q5v8q5w8q5x8q5y8q5z8q608q6e8q6f8q6g8q6h8q6i8q6j8q6k8q6l8q6m8q6n8q6o8q6p8q6q8q6r8q6s8q758q768q778q788q798q7a8q7b8q7c8q7d8q7e8q7f8q7g8q7h8q7i8q7j8q7k8q7l8q7m8q7n8q7o8q7p8q7q8q7r8q7s8q7t8q7u8q7v8q7w8q7x8q838q848q858q868q878q888q898q8a8q8b8q8c8q8m8q8n8q8o8q8p8q8q8q8r8q8s8q8t8q8u8q8v8q948q958q968q978q988q998q9a8q9b8q9c8q9d8q9k8q9l8q9m8q9n8q9o8q9p8q9q8q9r8q9s8q9t8qa18qa28qa38qa48qa58qa68qa78qa88qa98qaa8qab8qac8qad8qae8qaf8qag8qah8qai8qaj8qak8qal8qam8qan8qao8qap8qaq8qar8qbj8qbk8qbl8qbm8qbn8qbo8qbp8qbq8qbr8qbs8qbt8qbu8qbv8qbw8qbx8qby8qbz8qc08qc18qc28qc38qc48qc58qc68qc78qc88qc98qca8qcb8qcc8qcd8qcn8qco8qcp8qcq8qcr8qcs8qct8qcu8qcv8qcw8qcx8qcy8qcz8qd08qd18qd28qd38qd48qd58qd68qd78qd88qd98qda8qdb8qdc8qdd8qde8qdf8qdn8qdo8qdp8qdq8qdr8qds8qdt8qdu8qdv8qdw8qdx8qdy8qdz8qe08qe18qe28qe38qe48qe58qe68qe78qe88qe98qea8qeb8qec8qed8qee8qef8qeg8qeh8qeo8qep8qeq8qer8qes8qet8qeu8qev8qew8qex8qey8qez8qf08qf18qf28qf38qf48qf58qf68qf78qf88qf98qfa8qfb8qfc8qfd8qfe8qff8q1c8r1d8r1e8r1f8r1g8r1h8r1i8r1j8r1k8r1l8r1m8r1n8r1o8r1p8r1q8r1r8r1s8r1t8r1u8r1v8r1w8r1x8r1y8r1z8r208r218r228r238r248r258r2e8r2f8r2g8r2h8r2i8r2j8r2k8r2l8r2m8r2n8r2o8r2p8r2q8r2r8r2s8r2t8r2u8r2v8r2w8r2x8r2y8r2z8r308r318r328r338r348r358r368r3e8r3f8r3g8r3h8r3i8r3j8r3k8r3l8r3m8r3n8r3o8r3p8r3q8r3r8r3s8r3w8r3x8r3y8r3z8r408r418r428r438r448r458r468r478r488r498r4a8r4b8r4c8r4d8r4e8r4f8r4g8r4h8r4i8r4j8r4k8r4l8r4m8r4n8r4o8r4v8r4w8r4x8r4y8r4z8r508r518r528r538r548r558r568r578r588r598r5a8r5b8r5c8r5d8r5e8r5f8r5g8r5h8r5i8r5j8r5k8r5r8r5s8r5t8r5u8r5v8r5w8r5x8r5y8r5z8r608r6e8r6f8r6g8r6h8r6i8r6j8r6k8r6l8r6m8r6n8r6o8r6p8r6q8r6r8r6s8r768r778r788r798r7a8r7b8r7c8r7d8r7e8r7f8r7g8r7h8r7i8r7j8r7k8r7l8r7m8r7n8r7o8r7p8r7q8r7r8r7s8r7t8r7u8r7v8r7w8r7x8r838r848r858r868r878r888r898r8a8r8b8r8c8r8m8r8n8r8o8r8p8r8q8r8r8r8s8r8t8r8u8r8v8r948r958r968r978r988r998r9a8r9b8r9c8r9d8r9k8r9l8r9m8r9n8r9o8r9p8r9q8r9r8r9s8r9t8ra28ra38ra48ra58ra68ra78ra88ra98raa8rab8rac8rad8rae8raf8rag8rah8rai8raj8rak8ral8ram8ran8rao8rap8raq8rar8rbj8rbk8rbl8rbm8rbn8rbo8rbp8rbq8rbr8rbs8rbt8rbu8rbv8rbw8rbx8rby8rbz8rc08rc18rc28rc38rc48rc58rc68rc78rc88rc98rca8rcb8rcc8rco8rcp8rcq8rcr8rcs8rct8rcu8rcv8rcw8rcx8rcy8rcz8rd08rd18rd28rd38rd48rd58rd68rd78rd88rd98rda8rdb8rdc8rdd8rde8rdo8rdp8rdq8rdr8rds8rdt8rdu8rdv8rdw8rdx8rdy8rdz8re08re18re28re38re48re58re68re78re88re98rea8reb8rec8red8ree8ref8reg8reh8rep8req8rer8res8ret8reu8rev8rew8rex8rey8rez8rf08rf18rf28rf38rf48rf58rf68rf78rf88rf98rfa8rfb8rfc8rfd8rfe8r1d8s1e8s1f8s1g8s1h8s1i8s1j8s1k8s1l8s1m8s1n8s1o8s1p8s1q8s1r8s1s8s1t8s1u8s1v8s1w8s1x8s1y8s1z8s208s218s228s238s248s2e8s2f8s2g8s2h8s2i8s2j8s2k8s2l8s2m8s2n8s2o8s2p8s2q8s2r8s2s8s2t8s2u8s2v8s2w8s2x8s2y8s2z8s308s318s328s338s348s358s368s3f8s3g8s3h8s3i8s3j8s3k8s3l8s3m8s3n8s3o8s3p8s3q8s3r8s3s8s3w8s3x8s3y8s3z8s408s418s428s438s448s458s468s478s488s498s4a8s4b8s4c8s4d8s4e8s4f8s4g8s4h8s4i8s4j8s4k8s4l8s4m8s4n8s4o8s4w8s4x8s4y8s4z8s508s518s528s538s548s558s568s578s588s598s5a8s5b8s5c8s5d8s5e8s5f8s5g8s5h8s5i8s5j8s5r8s5s8s5t8s5u8s5v8s5w8s5x8s5y8s5z8s608s6f8s6g8s6h8s6i8s6j8s6k8s6l8s6m8s6n8s6o8s6p8s6q8s6r8s768s778s788s798s7a8s7b8s7c8s7d8s7e8s7f8s7g8s7h8s7i8s7j8s7k8s7l8s7m8s7n8s7o8s7p8s7q8s7r8s7s8s7t8s7u8s7v8s7w8s838s848s858s868s878s888s898s8a8s8b8s8c8s8m8s8n8s8o8s8p8s8q8s8r8s8s8s8t8s8u8s8v8s948s958s968s978s988s998s9a8s9b8s9c8s9d8s9k8s9l8s9m8s9n8s9o8s9p8s9q8s9r8s9s8s9t8sa38sa48sa58sa68sa78sa88sa98saa8sab8sac8sad8sae8saf8sag8sah8sai8saj8sak8sal8sam8san8sao8sap8saq8sbk8sbl8sbm8sbn8sbo8sbp8sbq8sbr8sbs8sbt8sbu8sbv8sbw8sbx8sby8sbz8sc08sc18sc28sc38sc48sc58sc68sc78sc88sc98sca8scb8sco8scp8scq8scr8scs8sct8scu8scv8scw8scx8scy8scz8sd08sd18sd28sd38sd48sd58sd68sd78sd88sd98sda8sdb8sdc8sdd8sdp8sdq8sdr8sds8sdt8sdu8sdv8sdw8sdx8sdy8sdz8se08se18se28se38se48se58se68se78se88se98sea8seb8sec8sed8see8sef8seg8seh8sep8seq8ser8ses8set8seu8sev8sew8sex8sey8sez8sf08sf18sf28sf38sf48sf58sf68sf78sf88sf98sfa8sfb8sfc8sfd8s1e8t1f8t1g8t1h8t1i8t1j8t1k8t1l8t1m8t1n8t1o8t1p8t1q8t1r8t1s8t1t8t1u8t1v8t1w8t1x8t1y8t1z8t208t218t228t238t2f8t2g8t2h8t2i8t2j8t2k8t2l8t2m8t2n8t2o8t2p8t2q8t2r8t2s8t2t8t2u8t2v8t2w8t2x8t2y8t2z8t308t318t328t338t348t358t368t378t3f8t3g8t3h8t3i8t3j8t3k8t3l8t3m8t3n8t3o8t3p8t3q8t3r8t3s8t3x8t3y8t3z8t408t418t428t438t448t458t468t478t488t498t4a8t4b8t4c8t4d8t4e8t4f8t4g8t4h8t4i8t4j8t4k8t4l8t4m8t4n8t4o8t4p8t4x8t4y8t4z8t508t518t528t538t548t558t568t578t588t598t5a8t5b8t5c8t5d8t5e8t5f8t5g8t5h8t5i8t5r8t5s8t5t8t5u8t5v8t5w8t5x8t5y8t5z8t608t6f8t6g8t6h8t6i8t6j8t6k8t6l8t6m8t6n8t6o8t6p8t6q8t6r8t778t788t798t7a8t7b8t7c8t7d8t7e8t7f8t7g8t7h8t7i8t7j8t7k8t7l8t7m8t7n8t7o8t7p8t7q8t7r8t7s8t7t8t7u8t7v8t838t848t858t868t878t888t898t8a8t8b8t8c8t8m8t8n8t8o8t8p8t8q8t8r8t8s8t8t8t8u8t8v8t948t958t968t978t988t998t9a8t9b8t9c8t9d8t9k8t9l8t9m8t9n8t9o8t9p8t9q8t9r8t9s8t9t8ta48ta58ta68ta78ta88ta98taa8tab8tac8tad8tae8taf8tag8tah8tai8taj8tak8tal8tam8tan8tao8tap8tbl8tbm8tbn8tbo8tbp8tbq8tbr8tbs8tbt8tbu8tbv8tbw8tbx8tby8tbz8tc08tc18tc28tc38tc48tc58tc68tc78tc88tc98tca8tcp8tcq8tcr8tcs8tct8tcu8tcv8tcw8tcx8tcy8tcz8td08td18td28td38td48td58td68td78td88td98tda8tdb8tdc8tdq8tdr8tds8tdt8tdu8tdv8tdw8tdx8tdy8tdz8te08te18te28te38te48te58te68te78te88te98tea8teb8tec8ted8tee8tef8teg8teh8teq8ter8tes8tet8teu8tev8tew8tex8tey8tez8tf08tf18tf28tf38tf48tf58tf68tf78tf88tf98tfa8tfb8tfc8t1g8u1h8u1i8u1j8u1k8u1l8u1m8u1n8u1o8u1p8u1q8u1r8u1s8u1t8u1u8u1v8u1w8u1x8u1y8u1z8u208u218u228u2g8u2h8u2i8u2j8u2k8u2l8u2m8u2n8u2o8u2p8u2q8u2r8u2s8u2t8u2u8u2v8u2x8u2y8u2z8u308u318u328u338u348u358u368u378u3g8u3h8u3i8u3j8u3k8u3l8u3m8u3n8u3o8u3p8u3q8u3r8u3s8u3y8u3z8u408u418u428u438u448u458u468u478u488u498u4a8u4b8u4c8u4d8u4f8u4g8u4h8u4i8u4j8u4k8u4l8u4m8u4n8u4o8u4p8u4y8u4z8u508u518u528u538u548u558u568u578u588u598u5a8u5b8u5c8u5d8u5e8u5f8u5g8u5h8u5r8u5s8u5t8u5u8u5v8u5w8u5x8u5y8u5z8u608u6f8u6g8u6h8u6i8u6j8u6k8u6l8u6m8u6n8u6o8u6p8u6q8u6r8u788u798u7a8u7b8u7c8u7d8u7e8u7f8u7g8u7h8u7i8u7j8u7k8u7l8u7m8u7n8u7o8u7p8u7q8u7r8u7s8u7t8u7u8u838u848u858u868u878u888u898u8a8u8b8u8c8u8m8u8n8u8o8u8p8u8q8u8r8u8s8u8t8u8u8u8v8u948u958u968u978u988u998u9a8u9b8u9c8u9d8u9k8u9l8u9m8u9n8u9o8u9p8u9q8u9r8u9s8u9t8ua58ua68ua78ua88ua98uaa8uab8uac8uad8uae8uaf8uag8uah8uai8uaj8uak8ual8uam8uan8uao8ubn8ubo8ubp8ubq8ubr8ubs8ubt8ubu8ubv8ubw8ubx8uby8ubz8uc08uc18uc28uc38uc48uc58uc68uc78uc88uc98ucq8ucr8ucs8uct8ucu8ucv8ucw8ucx8ucy8ucz8ud08ud18ud28ud38ud48ud58ud68ud78ud88ud98uda8udb8udr8uds8udt8udu8udv8udw8udx8udy8udz8ue08ue18ue28ue38ue48ue58ue68ue78ue88ue98uea8ueb8uec8ued8uee8uef8ueg8ueh8ues8uet8ueu8uev8uew8uex8uey8uez8uf08uf18uf28uf38uf48uf58uf68uf78uf88uf98ufa8ufb8u1i8v1j8v1k8v1l8v1m8v1n8v1o8v1p8v1q8v1r8v1s8v1t8v1u8v1v8v1w8v1x8v1y8v1z8v208v2h8v2i8v2j8v2k8v2l8v2m8v2n8v2o8v2p8v2q8v2r8v2s8v2t8v2u8v2y8v2z8v308v318v328v338v348v358v368v378v3h8v3i8v3j8v3k8v3l8v3m8v3n8v3o8v3p8v3q8v3r8v3s8v3z8v408v418v428v438v448v458v468v478v488v498v4a8v4b8v4c8v4g8v4h8v4i8v4j8v4k8v4l8v4m8v4n8v4o8v4p8v4z8v508v518v528v538v548v558v568v578v588v598v5a8v5b8v5c8v5d8v5e8v5f8v5g8v5r8v5s8v5t8v5u8v5v8v5w8v5x8v5y8v5z8v608v6g8v6h8v6i8v6j8v6k8v6l8v6m8v6n8v6o8v6p8v6q8v7a8v7b8v7c8v7d8v7e8v7f8v7g8v7h8v7i8v7j8v7k8v7l8v7m8v7n8v7o8v7p8v7q8v7r8v7s8v7t8v838v848v858v868v878v888v898v8a8v8b8v8c8v8m8v8n8v8o8v8p8v8q8v8r8v8s8v8t8v8u8v8v8v948v958v968v978v988v998v9a8v9b8v9c8v9d8v9k8v9l8v9m8v9n8v9o8v9p8v9q8v9r8v9s8v9t8va68va78va88va98vaa8vab8vac8vad8vae8vaf8vag8vah8vai8vaj8vak8val8vam8van8vbp8vbq8vbr8vbs8vbt8vbu8vbv8vbw8vbx8vby8vbz8vc08vc18vc28vc38vc48vc58vc68vc78vcs8vct8vcu8vcv8vcw8vcx8vcy8vcz8vd08vd18vd28vd38vd48vd58vd68vd78vd88vd98vda8vds8vdt8vdu8vdv8vdw8vdx8vdy8vdz8ve08ve18ve28ve38ve48ve58ve88ve98vea8veb8vec8ved8vee8vef8veg8veh8vet8veu8vev8vew8vex8vey8vez8vf08vf18vf28vf38vf48vf58vf68vf78vf88vf98v1k8w1l8w1m8w1n8w1o8w1p8w1q8w1r8w1s8w1t8w1u8w1v8w1w8w1x8w1y8w2j8w2k8w2l8w2m8w2n8w2o8w2p8w2q8w2r8w2s8w3k8w3l8w3m8w3n8w3o8w3p8w3q8w3r8w3s8w418w428w438w448w458w468w478w488w498w4a8w518w528w538w548w558w568w578w588w598w5a8w5b8w5c8w5d8w6g8w6h8w6i8w6j8w6k8w6l8w6m8w6n8w6o8w6p8w6q8w7c8w7d8w7e8w7f8w7g8w7h8w7i8w7j8w7k8w7l8w7m8w7n8w7o8w7p8w7q8wa88wa98waa8wab8wac8wad8wae8waf8wag8wah8wai8waj8wak8wbr8wbs8wbt8wbu8wbv8wbw8wbx8wby8wbz8wc08wc18wc28wc38wc48wc58wcu8wcv8wcw8wcx8wcy8wcz8wd08wd18wd28wd38wd48wd58wd68wd78wdu8wdv8wdw8wdx8wdy8wdz8we08we18we28we38wev8wew8wex8wey8wez8wf08wf18wf28wf38wf48wf58wf68wf78w1p8x1q8x1r8x1s8x1t8x578x588x6g8x6h8x6i8x6j8x6k8x6l8x6m8x6n8x6o8x6p8x7i8x7j8x7k8xae8xaf8xbw8xbx8xby8xbz8xc08xd08xd18xd28xf18x6g8y6h8y6i8y6j8y6k8y6l8y6m8y6n8y6o8y6p8y6g8z6h8z6i8z6j8z6k8z6l8z6m8z6n8z6o8z6p8z6f906g906h906i906j906k906l906m906n906o9069916a916b916c916d916e916f916g916h916i916j916k916l916m916n916o9169926a926b926c926d926e926f926g926h926i926j926k926l926m926n926o9269936a936b936c936d936e936f936g936h936i936j936k936l936m936n9369946a946b946c946d946e946f946g946h946i946j946k946l946m946n9469956a956b956c956d956e956f956g956h956i956j956k956l956m9569966a966b966c966d966e966f966g966h966i966j966k966l9669976a976b976c976d976e976f976g976h976i976j976k976l9769986a986b986c986d986e986f986g986h986i986j98";

        // ]

        this.points = [];
        for (let i = 0; i < this.data.length; i += 4) {
            const x = parseInt(this.data.substr(i, 2), 36);
            const y = parseInt(this.data.substr(i + 2, 2), 36);
            this.points.push([x, y, this.random(0, 200)]);
        }

        this.cam = {
            x: 500,
            y: 300,
            z: 100,

            lookX: 300,
            lookY: 300,
            lookZ: 100,

            _startLook: null,
            _startPos: null,
            animationOffset: 0,
            animateLook: function (time, start, stop, x, y, z) {
                var time = time + this.animationOffset;
                if (time < start || time > stop) {
                    return;
                }

                if (this._startLook === null) {
                    this._startLook = {
                        x: this.lookX,
                        y: this.lookY,
                        z: this.lookZ,
                    };
                }

                var t = sin(map(time, start, stop, 90, 270));

                this.lookX = map(t, 1, -1, this._startLook.x, x);
                this.lookY = map(t, 1, -1, this._startLook.y, y);
                this.lookZ = map(t, 1, -1, this._startLook.z, z);

                if (time >= stop) {
                    this._startLook = null;
                }
            },
            animatePos: function (time, start, stop, x, y, z) {
                var time = time + this.animationOffset;
                if (time < start || time > stop) {
                    return;
                }

                if (this._startPos === null) {
                    this._startPos = {
                        x: this.x,
                        y: this.y,
                        z: this.z,
                    };
                }

                var t = sin(map(time, start, stop, 90, 270));

                this.x = map(t, 1, -1, this._startPos.x, x);
                this.y = map(t, 1, -1, this._startPos.y, y);
                this.z = map(t, 1, -1, this._startPos.z, z);

                if (time >= stop) {
                    this._startPos = null;
                }
            },
        };

        this.time = 0;
    }

    random(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    transformPoint(pt) {
        const px = pt[0] - this.cam.x;
        const py = pt[1] - this.cam.y;
        const pz = pt[2] - this.cam.z;

        const fx = this.cam.lookX - this.cam.x;
        const fy = this.cam.lookY - this.cam.y;
        const fz = this.cam.lookZ - this.cam.z;
        const fMag = Math.sqrt(fx * fx + fy * fy + fz * fz);
        const forward = [fx / fMag, fy / fMag, fz / fMag];

        const worldUp = [0, 1, 0];
        const right = [-forward[2], 0, forward[0]];
        const rMag = Math.sqrt(
            right[0] * right[0] + right[2] * right[2]
        );
        const normalizedRight = [
            right[0] / rMag,
            0,
            right[2] / rMag,
        ];

        const up = [
            normalizedRight[1] * forward[2] -
                normalizedRight[2] * forward[1],
            normalizedRight[2] * forward[0] -
                normalizedRight[0] * forward[2],
            normalizedRight[0] * forward[1] -
                normalizedRight[1] * forward[0],
        ];
        const uMag = Math.sqrt(
            up[0] * up[0] + up[1] * up[1] + up[2] * up[2]
        );
        const normalizedUp = [
            up[0] / uMag,
            up[1] / uMag,
            up[2] / uMag,
        ];

        return {
            x:
                px * normalizedRight[0] +
                py * normalizedRight[1] +
                pz * normalizedRight[2],
            y:
                px * normalizedUp[0] +
                py * normalizedUp[1] +
                pz * normalizedUp[2],
            z: px * forward[0] + py * forward[1] + pz * forward[2],
        };
    }

    logic() {
        this.time++;

        // Look around
        this.cam.animateLook(this.time, 0, 100, 300, 300, 200);
        this.cam.animatePos(this.time, 0, 150, 200, 300, 100);

        // Position for zoom
        this.cam.animateLook(this.time, 100, 200, 300, 300, 0);
        this.cam.animatePos(this.time, 150, 250, 300, 300, 100);

        // Zoom out
        this.cam.animatePos(this.time, 250, 450, 300, 300, 300);
    }

    init() {
        pages.showPage("cataclysmicIntro");
        songs.cataclysmic_intro.play();

        background(-1);
    }

    lerp(a, b, t) {
        return a + (b - a) * t;
    }

    display() {
        noStroke();
        fill(0, 50);
        rect(0, 0, width, height);

        stroke(-1, min(this.time, 100));

        // Somewhat failed image data usage
        /*
that.loadPixels();
const data = imageData.data;
if (data) {
for (let n = 0; n < this.points.length; n++) {
    if (this.time > 360) {
        this.points[n][2] -= this.points[n][2] / Math.max(720 - this.time, 10);
        if (this.points[n][2] < 0.1) {
            this.points[n][2] = 0;
        }
    }

    const camPoint = this.transformPoint(this.points[n]);
    const f = 300;

    if (camPoint.z > 0) {
        const screenX = Math.floor(camPoint.x * (f / camPoint.z)) + width / 2;
        const screenY = Math.floor(camPoint.y * (f / camPoint.z)) + height / 2;

        const pixelWidth = 1, pixelHeight = 1;
        for (let w = 0; w < pixelWidth; w++) {
            for (let h = 0; h < pixelHeight; h++) {
                if (screenX + w < width && screenX + w > 0 && screenY + h < height && screenY + h > 0) {
                    const i = ((screenX + w) * 4) + ((screenY + h) * 4 * width);
                    data[i] = 255;
                    data[i + 1] = 255;
                    data[i + 2] = 255;
                }
            }
        }
    }
}
}
that.updatePixels();
*/

        if (this.time < 700) {
            pushMatrix();
            translate(300, 300);
            for (var n = 0; n < this.points.length; n++) {
                if (this.time > 400) {
                    this.points[n][2] -=
                        this.points[n][2] /
                        max(500 - this.time, 10);
                    if (this.points[n][2] < 0.01) {
                        this.points[n][2] = 0;
                    }
                }
                var camPoint = this.transformPoint(this.points[n]);

                // f is the focal length (adjust for your view)
                var f = 300;

                // Only project if z is positive (in front of the camera).
                if (camPoint.z > 0) {
                    var screenX = camPoint.x * (f / camPoint.z);
                    var screenY = camPoint.y * (f / camPoint.z);
                    strokeWeight(1);

                    let minStroke = 2;
                    let maxStroke = 100;
                    let k = 300;
                    let weight = k / Math.max(camPoint.z, 0.1);
                    strokeWeight(
                        constrain(weight, minStroke, maxStroke)
                    );

                    point(screenX, screenY);
                }
            }
            popMatrix();
        }
        if (this.time > 750) {
            this.done = true;
        }
    }

    update() {
        this.logic();
        this.display();
    }
}
const cataclysmicIntro = new CataclysmicIntro();

// ]

/** Initiate **/
// [

/**
 *
 * @param {string} type -
 * @param {boolean} canChangeColor -
 * @param {boolean} canAnimate -
 * @param {string} nextType -
 * @param {boolean} canInfiniteAnimate -
 * @param {boolean} canCollide -
 * @param {function} onChange -
 * @param {number} animateSpeed -
 * @param {boolean} isColored -
 * @param {number} transSpeed -
 *
 */
let blockData = {
    "-": {
        type: "air",
    },
    m: {
        canChangeColor: 1,
        canAnimate: 1,
        type: "grass",
        strength: 1,
        nextType: "M",
    },
    M: {
        type: "grayGrass",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "m",
    },
    s: {
        canChangeColor: 1,
        type: "stone",
        canCollide: 1,
        strength: 1,
        nextType: "S",
    },
    S: {
        type: "grayStone",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "s",
    },
    o: {
        canChangeColor: 1,
        type: "ore",
        canCollide: 1,
        strength: 1,
        nextType: "O",
    },
    O: {
        type: "grayOre",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "o",
    },
    f: {
        canChangeColor: 1,
        canAnimate: 1,
        type: "flower",
        strength: 1,
        nextType: "F",
    },
    F: {
        type: "grayFlower",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "f",
    },
    g: {
        canChangeColor: 1,
        type: "grassBlock",
        canCollide: 1,
        strength: 1,
        nextType: "G",
    },
    G: {
        type: "grayGrassBlock",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "g",
    },
    d: {
        canChangeColor: 1,
        type: "dirt",
        canCollide: 1,
        strength: 1,
        nextType: "D",
    },
    D: {
        type: "grayDirt",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "d",
    },
    t: {
        canChangeColor: 1,
        canAnimate: 1,
        type: "flowerGrass",
        strength: 1,
        nextType: "T",
    },
    T: {
        type: "grayFlowerGrass",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "t",
    },
    q: {
        canChangeColor: 1,
        canAnimate: 1,
        type: "doubleFlower",
        strength: 1,
        nextType: "Q",
    },
    Q: {
        type: "grayDoubleFlower",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "q",
    },
    e: {
        canChangeColor: 1,
        canAnimate: 1,
        type: "leaves",
        strength: 1,
        nextType: "E",
    },
    E: {
        type: "grayLeaves",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "e",
        transSpeed: 100,
    },

    0: {
        nextType: "7",
        type: "redPool",
        isLiquid: 1,
        name: "red",
        color: color(255, 0, 0),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    1: {
        nextType: "8",
        type: "bluePool",
        isLiquid: 1,
        name: "blue",
        color: color(50, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    2: {
        nextType: "9",
        type: "yellowPool",
        isLiquid: 1,
        name: "yellow",
        color: color(220, 220, 50),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    3: {
        nextType: "^",
        type: "orangePool",
        isLiquid: 1,
        name: "orange",
        color: color(255, 255 / 2, 0),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    4: {
        nextType: "<",
        type: "greenPool",
        isLiquid: 1,
        name: "green",
        color: color(50, 200, 50),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    5: {
        nextType: ">",
        type: "purplePool",
        isLiquid: 1,
        name: "purple",
        color: color(200, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    6: {
        nextType: "v",
        type: "brownPool",
        isLiquid: 1,
        name: "brown",
        color: color(100, 50, 0),
        canInfiniteAnimate: 1,
        strength: 1,
    },

    7: {
        type: "redPoolTop",
        isLiquid: 1,
        name: "red",
        color: color(255, 0, 0),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    8: {
        type: "bluePoolTop",
        isLiquid: 1,
        name: "blue",
        color: color(50, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    9: {
        type: "yellowPoolTop",
        isLiquid: 1,
        name: "yellow",
        color: color(220, 220, 50),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    "^": {
        type: "orangePoolTop",
        isLiquid: 1,
        name: "orange",
        color: color(255, 255 / 2, 0),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    "<": {
        type: "greenPoolTop",
        isLiquid: 1,
        name: "green",
        color: color(50, 200, 50),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    ">": {
        type: "purplePoolTop",
        isLiquid: 1,
        name: "purple",
        color: color(200, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1,
    },
    v: {
        type: "brownPoolTop",
        isLiquid: 1,
        name: "brown",
        color: color(100, 50, 0),
        canInfiniteAnimate: 1,
        strength: 1,
    },

    l: {
        type: "bug",
        canChangeColor: 1,
        canInfiniteAnimate: 1,
        canAnimate: 1,
        animateSpeed: 3,
        strength: 1,
        nextType: "L",
        onChange: function (e) {
            sounds["cute" + (floor(random(0, 5)) + 1)].play();
        },
    },
    L: {
        canAnimate: 1,
        canChangeColor: 1,
        type: "grayBug",
        nextType: "l",
    },
    b: {
        canChangeColor: 1,
        type: "bird",
        canAnimate: 1,
        strength: 1,
        onChange: function (e) {
            sounds["egg" + (~~random(2) + 1)].play();
            entities.push(
                new Bird({
                    x: e.x,
                    y: e.y,
                })
            );
        },
        nextType: "B",
    },
    B: {
        type: "grayBird",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "b",
    },
    r: {
        type: "grassGuy",
        canChangeColor: 1,
        canInfiniteAnimate: 1,
        canAnimate: 1,
        animateSpeed: 10,
        strength: 1,
        nextType: "R",
        onChange: function (e) {
            sounds["crumble" + (floor(random(0, 2)) + 1)].play();
        },
    },
    R: {
        canAnimate: 1,
        canChangeColor: 1,
        type: "grayGrassGuy",
        nextType: "r",
    },
    y: {
        type: "stoneGuy",
        canChangeColor: 1,
        canInfiniteAnimate: 1,
        canAnimate: 1,
        animateSpeed: 7,
        strength: 1,
        nextType: "Y",
    },
    Y: {
        canAnimate: 1,
        canChangeColor: 1,
        type: "grayStoneGuy",
        nextType: "y",
        transSpeed: 100,
    },

    a: {
        type: "blank",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "a",
    },
    c: {
        type: "red",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "c",
    },
    z: {
        type: "green",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "z",
    },
    h: {
        type: "blue",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "h",
    },
    i: {
        type: "yellow",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "i",
    },
    j: {
        type: "purple",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "j",
    },
    k: {
        type: "orange",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "k",
    },
    p: {
        type: "brown",
        canChangeColor: 1,
        canCollide: 1,
        colorable: 1,
        nextType: "p",
    },
};
let levels = [
        [
            "G#######@#########-------------------------------------------------------------------------------",
            "G#######G#########-------------------------------------------------------------------------------",
            "G#################-------------------------------------------------------------------------------",
            "G>################-------------------------------------------------------------------------------",
            "G#################-------------------------------------------------------------------------------",
            "G#################-------------------------------------------------------------------------------",
            "G#################@------------------------------------------------------------------------------",
            "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG",
        ],
        [
            "------------------------LMM----------------------------",
            "---------------------FFMGGGFFFMM-----------------------",
            "-@---------------MFLTGGGGGGGGGGGFF---------------------",
            "E-R-MMMM-QQFMLTMTGGGGGGGGGGGGGGGGGFMTFMQTM--QEQEQ--F--M",
            "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG--GGGGG44G00G",
            "GGGGGGGGGGGGGGGGGG---FFFFFFFFFMMMMMMMMMM----GGGGG44G00G",
            "GGGGGGGGGGGGGG-QEQEQEGGGGGGGGGGGGGGGGGGGGGGGGGGGG44G00G",
            "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS",
            "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO--OOOOOOOO",
            "-------------------------------------------------------",
            "-------------------------------------------------------",
            "-------------------------------------------------------",
        ],
        [
            "------------------------lmm----------------------------",
            "---------------------ffmgggfffmm-----------------------",
            "--@--------------mfltgggggggggggff---------------------",
            "e-r-mmmm-qqfmltmtgggggggggggggggggfmtfmqtm--qeqeq--f--m",
            "gggggggggggggggggggggggggggggggggggggggggg--ggggg44g00g",
            "gggggggggggggggggg---fffffffffmmmmmmmmmm----ggggg44g00g",
            "gggggggggggggg-qeqeqegggggggggggggggggggggggggggg44g00g",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "ooooooooooooooooooooooooooooooooooooooooooooo--oooooooo",
            "-------------------------------------------------------",
            "-------------------------------------------------------",
            "-------------------------------------------------------",
        ],
        [
            "-----####################----------",
            "----G####################----------",
            "----G####################----------",
            "@---G####################----------",
            "G333GGGGGGGGGGGGGGGGGGGGMR----GGGGG",
            "G333GGGGGGGGGGGGGGGGGGGGGGGF---GGG-",
            "GG33GGGGGGGGGGGGGGGGGGGGGGGG--MGGEE",
            "GGG3SSSSSSSGGGGGGGGGGGGGGG----GGGGG",
            "SSS3SSSSSSSSSSSGGGGGGGGG---LQGGSGGG",
            "SS----SSSSSSSSSSSSSSGGG--QMGGGSSSGE",
            "SSTT---SSSSSSSSSS--------GGSSSSSSGG",
            "SSGG-------SSSSS-----------SSSSSGG-",
            "SSSG--SS---Y--L---V-L----Y--SSSSGEE",
            "SSSS--SSSSSSSSSSSSSSSSSSSSS-----SGG",
            "OOOOT-SSSSSSSSSSSSSSSSSSSSSSS-L--OO",
            "OOOOG--OOO5555SSSSSSSSSOOOOOOOOO-E-",
            "OOOOGTTM55555OOOOOOOOOOOOOOOOOOOGGG",
            "-OOOOGGGOOOOOOOOOOOOOOOOOOOOOOOGGGG",
        ],
        [
            "------------------------------------------------------------------------------------------------",
            "------------------------------------------------------------------------------------------------",
            "------------------------------------------------------------------------------------------------",
            "------------------------------------------------------------------------------------------------",
            "--aa--------------------------------------------------------------------------------------------",
            "-aaaa-------------------------------------------------------------------------------------------",
            "-aaaa-------------------------------------------------------------------------------------------",
            "@--------GG5555GGGGGGGG-GGG---------------------------------------------------------------------",
            "aaa444444aaa555aaaaaaaa-GGGGGG------------------------------------------------------------------",
            "aaa444444aaaaaaaaaaaaaa-aaaaGGGGGG-TMT---------------------------------------------############G",
            "aaa444444aaaaaaaaaaaaaa-aaaaaaaaaGGGGG-T-------------------------------------------############G",
            "aaa444aaaaaaaa111-------aaaaaaaaaaaaGGGGM------------------------------------------############G",
            "aaaa444aaaaaaaaaa-------R-FM----aaaaaaaGG-TM---------------------------------------############G",
            "-aaaa444444aaaaaM-R-FF--GGGGGF--GGaaaaaaGGGGGT------------------------------------############GG",
            "--aa444444aaaaaGGGGGGGF---GGGG--R-GGaaaaaGGGGGMT----------------------------------###########GGG",
            "---aaaaaa44aaaaaaaaaGGG--FMR-MM-GGGaaaaaaaaaaGGGG#-----------------------------GGGGGGGGGGGGGGGGG",
            "--aaaaaaa4444------------GGGGGGGGGaaaaaaaaaaaaGGG#-G---------------------GGGGGGGGGGGGGGGGGGGGGGG",
            "-aaaaaa-----------------aaaaaaaaaaaaaa------##aaG#GGGGG-----------------------------------------",
            "-aaaa---------------------------------------####a#aaaGGGGG-MMQQ--MQ-MQ-MM--QQMQ-QM-QQ-----------",
            "--aaaaL-------------------L---L-L---LLLL-LLL######aaaaaaaGGGGGGGGGGGGGGGGGGGGGGGGGGGG55555555GGG",
            "----aaaa---LBB-L-BB-L-BBaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa555aaaaa",
            "-----OOO222aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa----aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa55aaaaaa",
            "-------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO-----------------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO",
            "----------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO---------------------OOOOOOOOOOOOOOOOOOOOOOOOOOOO",
        ],
    ],
    level = 4;

let blocks = [];
blocks.handle = function (func) {
    for (
        let y = max(floor((cam.y + PADDING_Y) / blockH) - 2, 0);
        y <
        min(
            floor((cam.y + PADDING_Y + height) / blockH) + 2,
            this.length
        );
        y++
    ) {
        for (
            let x = max(floor((cam.x + PADDING_X) / blockW) - 2, 0);
            x <
            min(
                floor((cam.x + PADDING_X + width) / blockW) + 2,
                this[y].length
            );
            x++
        ) {
            this[y][x][func]();
        }
    }
};

function createLevel() {
    // Reset
    enemies.length = 0;
    entities.length = 0;
    blocks.length = 0;

    // Loop y axis
    for (let y = 0; y < levels[level].length; y++) {
        blocks.push([]);

        // Loop x axis
        for (let x = 0; x < levels[level][y].length; x++) {
            let type = levels[level][y][x];
            switch (type) {
                case "@":
                    // Create new player
                    player = new Player({
                        w: blockW * 0.8,
                        h: blockH * 0.8,
                        x: x * blockW,
                        y: y * blockH,
                    });
                    type = "-";
                    break;
                case "#":
                    enemies.push(
                        new Rottweiler({
                            w: blockW * 0.8,
                            h: blockH * 0.8,
                            x: x * blockW,
                            y: y * blockH,
                        })
                    );
                    type = "-";
                    break;
            }

            blocks[y].push(
                new Block({
                    w: blockW,
                    h: blockH,
                    x: x * blockW,
                    y: y * blockH,
                    symbol: type,
                })
            );
        }
    }

    // Add air padding
    for (let y = 0; y < PADDING_Y / blockH; y++) {
        blocks.push([]);
        for (let x = 0; x < blocks[blocks.length - 2].length; x++) {
            blocks[blocks.length - 1].push(
                new Block({
                    w: blockW,
                    h: blockH,
                    x: blocks[blocks.length - 1].length * blockW,
                    y: (blocks.length - 1) * blockH,
                    symbol: "-",
                })
            );
        }
    }
    for (let y = 0; y < PADDING_Y / blockH; y++) {
        blocks.unshift([]);
        for (let x = 0; x < blocks[1].length; x++) {
            blocks[0].push(
                new Block({
                    w: blockW,
                    h: blockH,
                    x: blocks[0].length * blockW,
                    y: (-y - 1) * blockH,
                    symbol: "-",
                })
            );
        }
    }
    for (let y = 0; y < blocks.length; y++) {
        for (let x = 0; x < PADDING_X / blockW; x++) {
            blocks[y].unshift(
                new Block({
                    w: blockW,
                    h: blockH,
                    x: (-x - 1) * blockW,
                    y: y * blockH - PADDING_Y,
                    symbol: "-",
                })
            );
        }
    }
    for (let y = 0; y < blocks.length; y++) {
        for (let x = 0; x < PADDING_X / blockW; x++) {
            blocks[y].push(
                new Block({
                    w: blockW,
                    h: blockH,
                    x: blocks[y].length * blockW - PADDING_X,
                    y: y * blockH - PADDING_Y,
                    symbol: "-",
                })
            );
        }
    }

    // Index blocks
    let id = 0;
    for (let y = 0; y < blocks.length; y++) {
        for (let x = 0; x < blocks[y].length; x++) {
            if (
                y === 0 ||
                x === 0 ||
                y === blocks.length - 1 ||
                x === blocks[y].length - 1
            )
                blocks[y][x].isEnd = true;
            blocks[y][x].index = [y, x];
            blocks[y][x].id = id;
            id++;
            if (blocks[y][x].canChangeColor) {
                if (blocks[y][x].strength > 0) {
                    player.hasColored++;
                }
                player.mustColor++;
            }
        }
    }

    levelW = blockW * blocks[0].length;
    levelH = blockH * blocks.length;

    player.blankPathfinder = blocks.map((innerArray) =>
        innerArray.map(() => 0)
    );
    player.reset();
}

const pages = new Pages({
    pages: {
        loadImages: new Page({
            artKeys: Object.keys(art),
            spriteKeys: Object.keys(sprites),
            loadedA: 0,
            innerLoad: 0,
            loadedS: 0,
            draw: function () {
                background(0);
                noStroke();
                rectMode(CORNER);
                let img = undefined;
                if (this.loadedA < this.artKeys.length) {
                    let a = this.artKeys[this.loadedA];
                    if (typeof art[a][0] === "string") {
                        background(0, 0);
                        let pixelW = 400 / art[a][0].length,
                            pixelH = 400 / art[a].length;
                        for (let i = 0; i < art[a].length; i++) {
                            for (
                                let j = 0;
                                j < art[a][i].length;
                                j++
                            ) {
                                fill(colors[art[a][i][j]]);
                                rect(
                                    j * pixelW,
                                    i * pixelH,
                                    pixelW + 1,
                                    pixelH + 1
                                );
                            }
                        }
                        art[a] = get(0, 0, 400, 400);
                        img = art[a];
                        this.loadedA++;
                    } else {
                        background(0, 0);
                        let pixelW =
                                400 /
                                art[a][this.innerLoad][0].length,
                            pixelH =
                                400 / art[a][this.innerLoad].length;
                        for (
                            let i = 0;
                            i < art[a][this.innerLoad].length;
                            i++
                        ) {
                            for (
                                let j = 0;
                                j <
                                art[a][this.innerLoad][i].length;
                                j++
                            ) {
                                fill(
                                    colors[
                                        art[a][this.innerLoad][i][j]
                                    ]
                                );
                                rect(
                                    j * pixelW,
                                    i * pixelH,
                                    pixelW + 1,
                                    pixelH + 1
                                );
                            }
                        }
                        art[a][this.innerLoad] = get(
                            0,
                            0,
                            400,
                            400
                        );
                        img = art[a][this.innerLoad];
                        if (this.innerLoad === art[a].length - 1) {
                            this.innerLoad = 0;
                            this.loadedA++;
                        } else {
                            this.innerLoad++;
                        }
                    }
                } else {
                    if (this.loadedS < this.spriteKeys.length) {
                        let a = this.spriteKeys[this.loadedS];
                        if (typeof sprites[a][0] === "string") {
                            background(0, 0);
                            let pixelW = 400 / sprites[a][0].length,
                                pixelH = 400 / sprites[a].length;
                            for (
                                let i = 0;
                                i < sprites[a].length;
                                i++
                            ) {
                                for (
                                    let j = 0;
                                    j < sprites[a][i].length;
                                    j++
                                ) {
                                    fill(colors[sprites[a][i][j]]);
                                    rect(
                                        j * pixelW,
                                        i * pixelH,
                                        pixelW + 1,
                                        pixelH + 1
                                    );
                                }
                            }
                            sprites[a] = get(0, 0, 400, 400);
                            img = sprites[a];
                            this.loadedS++;
                        } else {
                            background(0, 0);
                            let pixelW =
                                    400 /
                                    sprites[a][this.innerLoad][0]
                                        .length,
                                pixelH =
                                    400 /
                                    sprites[a][this.innerLoad]
                                        .length;
                            for (
                                let i = 0;
                                i <
                                sprites[a][this.innerLoad].length;
                                i++
                            ) {
                                for (
                                    let j = 0;
                                    j <
                                    sprites[a][this.innerLoad][i]
                                        .length;
                                    j++
                                ) {
                                    fill(
                                        colors[
                                            sprites[a][
                                                this.innerLoad
                                            ][i][j]
                                        ]
                                    );
                                    rect(
                                        j * pixelW,
                                        i * pixelH,
                                        pixelW + 1,
                                        pixelH + 1
                                    );
                                }
                            }
                            sprites[a][this.innerLoad] = get(
                                0,
                                0,
                                400,
                                400
                            );
                            img = sprites[a][this.innerLoad];
                            if (
                                this.innerLoad ===
                                sprites[a].length - 1
                            ) {
                                this.innerLoad = 0;
                                this.loadedS++;
                            } else {
                                this.innerLoad++;
                            }
                        }
                    } else {
                        parseSpirals();
                        console.log("---Images loaded---");
                        pages.showPage("loadAudio");
                    }
                }
                if (img) {
                    background(0);
                    imageMode(CENTER);
                    image(img, width / 2, height * 0.4);
                }
                new PixelText({
                    x: width / 2,
                    y: height * 0.9,
                    string:
                        "Loading Images" +
                        "...".slice(
                            0,
                            floor((frameCount / 50) % 4)
                        ),
                    size: 40,
                    color: 1,
                    align: CENTER,
                }).display();
            },
        }),
        game: new Page({
            dust: new ParticleSystem(),
            particles: new ParticleSystem(),
            draw: function () {
                let bigPapa = backgrounds.Forest[2];
                for (let i = 0; i < bigPapa.length; i++) {
                    let img = bigPapa[i],
                        h = 600,
                        w = (img.width / img.height) * 600;
                    ctx.drawImage(
                        img,
                        ((((-cam.x - 1200) / 20) * (i + 1)) %
                            (w * 2 - 2)) +
                            w,
                        0,
                        w,
                        h
                    );
                    ctx.drawImage(
                        img,
                        ((((-cam.x - 1200) / 20) * (i + 1) -
                            w +
                            1) %
                            (w * 2 - 2)) +
                            w,
                        0,
                        w,
                        h
                    );
                }

                fill(
                    0,
                    150 -
                        (player.hasColored / player.mustColor ||
                            0) *
                            150
                );
                noStroke();
                rect(0, 0, width, height);

                // Update world
                pushMatrix();

                // Camera translations
                scale(cam.scale);
                translate(round(-cam.x), round(-cam.y));

                // Particles
                this.dust.update();
                this.particles.update();

                // Display blocks
                blocks.handle("update");

                // Handle player
                if (player) {
                    cam.moveTo(player);
                    player.update();
                }

                // Enemies and entities
                entities.forEach((e) => {
                    if (e.resetFrame) e.resetFrame();
                });
                for (let i = entities.length - 1; i >= 0; i--) {
                    entities[i].index = i;
                    entities[i].update();
                    if (entities[i].dead) entities.splice(i, 1);
                }
                enemies.forEach((e) => {
                    if (e.resetFrame) e.resetFrame();
                });
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].index = i;
                    enemies[i].update();
                    if (enemies[i].dead) enemies.splice(i, 1);
                }

                // Display shadows
                blocks.handle("shadow");
                player.light.draw();

                popMatrix();

                // Dust
                if (frameCount % 5 === 0) {
                    this.dust.add(
                        new Particle({
                            x: width + tx(10) + cam.x,
                            y: random(0, height) + cam.y,
                            vx: tx(-1),
                            w: 4,
                            color: lerpColor(
                                color(0, 10),
                                color(
                                    random(0, 255),
                                    random(0, 255),
                                    random(0, 255),
                                    30
                                ),
                                player.hasColored /
                                    player.mustColor || 0
                            ),
                            health: width + 20,
                            rvz: random(-0.02, 0.02),
                            rvx: random(-0.02, 0.02),
                            image: round(random(0, 1))
                                ? "ellipse"
                                : "rect",
                            onUpdate: function () {
                                this.vy =
                                    cos(this.health + frameCount) /
                                    4;
                            },
                        })
                    );
                }

                player.updateHud();

                // Fix this, it is returning the error: TypeError: undefined is not an object (evaluating 'blcks[v0]][v[1]].strength')
                if (player.dead) createLevel();
            },
        }),
        home: new Page({
            walkers: [],
            addWalker: function () {
                this.walkers.push(
                    new ExtremeWalker({
                        amount: 200,
                    })
                );
            },
            draw: function () {
                pushStyle();
                fill(0, 5);
                noStroke();
                rect(0, 0, width, height);
                popStyle();

                for (let i = this.walkers.length - 1; i >= 0; i--) {
                    this.walkers[i].update();
                    if (this.walkers[i].finished) {
                        this.walkers.splice(i, 1);
                    }
                }

                if (this.walkers.length === 0) {
                    this.addWalker();
                }
                this.walkers[this.walkers.length - 1].setPixel(
                    floor(
                        mouseX /
                            (width /
                                this.walkers[
                                    this.walkers.length - 1
                                ].grid.length)
                    ),
                    floor(
                        mouseY /
                            (height /
                                this.walkers[
                                    this.walkers.length - 1
                                ].grid.length)
                    )
                );

                if (mouse.released && this.walkers.length < 5) {
                    this.addWalker();
                    mouse.use();
                }

                // Alt + shift + 1 for thumbnail
                if (keys[49] && keys[16] && keys[18]) {
                    pages.showPage("thumbnail");
                }
            },
        }),
        loadAudio: new Page({
            draw: function () {
                background(0);
                new PixelText({
                    x: width / 2,
                    y: height * 0.9,
                    string:
                        "Loading Audio" +
                        "...".slice(
                            0,
                            floor((frameCount / 50) % 4)
                        ),
                    size: 40,
                    color: 1,
                    align: CENTER,
                }).display();
                if (loadedAudio === totalAudio) {
                    console.log("---Audio loaded---");
                    pages.showPage("game");
                    songs[
                        "dark" + (floor(random(0, 4)) + 1)
                    ].play();
                    // songs["happy"+(floor(random(0, 2))+1)].play();
                    // cataclysmicIntro.init();
                }
            },
        }),
        cataclysmicIntro: new Page({
            draw: function () {
                cataclysmicIntro.update();
                if (cataclysmicIntro.done) {
                    pages.showPage("game");
                    songs["dark" + round(random(1, 4))].play();
                }
            },
        }),
        thumbnail: new Page({
            draw: function () {
                background(0);
                new PixelText({
                    x: width / 2,
                    y: height * 0.15,
                    string: "~~ COLOR LAND ~~",
                    size: 50,
                    color: 1,
                    align: CENTER,
                }).display();
                image(art.homeBg, 0, 0, width, height);
                for (k in keys) {
                    if (keys[k]) {
                        pages.showPage("home");
                    }
                }
            },
        }),
    },
});

createLevel();
!instantLoad
    ? pages.showPage("loadImages")
    : pages.showPage("loadAudio");

// Start audio
// songs["dark"+round(random(1, 4))].play();

// ]

/** Draw loop **/
// [

frameRate(60);
let that = undefined;
function draw() {
    that = this;
    frameCount++;
    pages.update();
    mouse.update();
}

// ]

/** Events **/
// [

mousePressed = () => {
    mouse.press();
};
mouseReleased = () => {
    mouse.release();
};
keyPressed = () => {
    keys[keyCode] = true;
};
keyReleased = () => {
    keys[keyCode] = false;
};

// ]

/** End **/
// [
}
function init() {
    parseAudio();
    parseImages();

    let canvas = document.getElementById("game-canvas");
    let processingInstance = runPJS(program);

    let els = document.getElementsByClassName("loading");
    for (let i = 0; i < els.length; i++) {
        els[i].style.display = "none";
    }
}

// ]
    </script>

    <script></script>
</html>
