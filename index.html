<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>New webpage</title>
        <style>

            * {
                -webkit-user-select: none; /* Safari */
                -moz-user-select: none; /* Firefox */
                -ms-user-select: none; /* Internet Explorer/Edge */
                user-select: none; /* Standard */
            }

            #progress-container {
                width: 100%;
                background-color: #f3f3f3;
                padding: 0;
                position: fixed;
                top: 0;
                left: 0;
                z-index: 1000;
            }
            #progress-bar {
                width: 0;
                height: 10px; /* Adjust the height as needed */
                background-color: #4caf50;
            }

            body {
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: #2c3e50;
                margin: 0;
                flex-direction: column;
                font-family: Arial, Helvetica, sans-serif;
            }

            canvas {
                position: absolute;
            }
            #webgl-fog {
                opacity: 0.5;
            }

            .loader {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            h1 {
                color: #ecf0f1;
                margin-bottom: 20px;
            }

            h3 {
                text-align: left;
                color: #ecf0f1;
                margin-left: 20px;
            }

            .dots {
                display: flex;
                justify-content: space-around;
                width: 100px;
            }

            .dot {
                width: 15px;
                height: 15px;
                background-color: #ecf0f1;
                border-radius: 50%;
                animation: loader-animation 1.2s infinite ease-in-out both;
            }

            @keyframes loader-animation {
                0%, 80%, 100% {
                    transform: scale(0);
                }
                40% {
                    transform: scale(1);
                }
            }

            .dot:nth-child(1) {
                animation-delay: -0.32s;
            }
            .dot:nth-child(2) {
                animation-delay: -0.16s;
            }
            .dot:nth-child(3) {
                animation-delay: 0s;
            }
            .dot:nth-child(4) {
                animation-delay: 0.16s;
            }
            .dot:nth-child(5) {
                animation-delay: 0.32s;
            }
            .dot:nth-child(6) {
                animation-delay: 0.48s;
            }
            .dot:nth-child(7) {
                animation-delay: 0.64s;
            }
            .dot:nth-child(8) {
                animation-delay: 0.8s;
            }

            footer {
                position: absolute;
                bottom: 20px;
                width: calc(100% - 40px);
                background-color: rgba(0, 0, 0, 0.5);
                color: white;
                text-align: center;
                padding: 10px;
                margin: 0 20px;
                box-sizing: border-box;
            }

            .tip {
                position: relative;
                height: 40px;
                overflow: hidden;
            }

            .tip div {
                position: absolute;
                width: 100%;
                opacity: 0;
                animation: fade 50s linear infinite;
            }

            /*
                t = time
                a = amount of tips
            */
            .tip div:nth-child(1) {
                animation-delay: 0s;
            }
            .tip div:nth-child(2) {
                animation-delay: 10s; /* t/a */
            }
            .tip div:nth-child(3) {
                animation-delay: 20s; /* (t/a)*2 */
            }
            .tip div:nth-child(4) {
                animation-delay: 30s; /* (t/a)*3 */
            }
            .tip div:nth-child(5) {
                animation-delay: 40s; /* (t/a)*4 */
            }

            @keyframes fade {
                0%{
                    opacity: 0;
                }
                10%{ /* (100/a)/2 */
                    opacity: 0;
                }
                20%{ /* 100/a */
                    opacity: 1;
                }
                30%{ /* ((100/a)/2)*3 */
                    opacity: 0;
                }
                100%{
                    opacity: 0;
                }
            }

        </style>
    </head>
    <body onload = "init();">
        <div id="progress-container" class="loading">
            <div id="progress-bar"></div>
        </div>
        <div class="loader loading">
            <h1>Loading data</h1>
            <div class="dots">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
        </div>
        <footer class="loading">
            <h3>Tip</h3>
            <div class="tip">
                <div>Falling off the edge of the level causes you to lose health.</div>
                <div>Fill your color bar up to the top for maximum color power!</div>
                <div>This game has epic audio so turn up your speakers to the max!</div>
                <div>Death is inevitable. The inevitable can only be prolonged. The prolonged is the procrastinated. Procrastination is inevitable. Need I say more?</div>
                <div>I'm outta ideas here please help me!</div>
            </div>
        </footer>
        <canvas class="sketch"></canvas>
    </body>

    <!--PJs-->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Khan/processing-js@master/processing.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Mushy-Avocado/KA-exporter@v1.0.1/exporter.js"></script>

    <!--Audio-->
    <script type>

        // Volume for various catagories
        let masterSongVolume = 1, masterSoundVolume = 1, masterVolume = 1;

        // Load all audio
        let audioNames = "cute1 cute2 cute3 cute4 cute5 happy1 happy2 splash1 splash2 underwater wilhelm dark1 dark2 dark3 dark4 egg1 egg2 bossfight cataclysmic_intro cave1 crumble1 crumble2 evil_talking garble landing hard_landing master_intro pitbull powerup talking1 dial_up".split(" ");
        
        let totalAudio = audioNames.length, loadedAudio = 0;
        for(let i = 0; i < totalAudio; i++){
            let dScript = document.createElement('script');
            dScript.src = 'https://cdn.jsdelivr.net/gh/CataclysmicCode/de_block_2/Audio/'+audioNames[i]+'.min.js';
            document.body.appendChild(dScript);
        }

        // Â© Leafers Studios 2024
        // https://www.khanacademy.org/computer-programming/song-player-elektronomia-sky-high/5456240516710400
        let sounds = {}, songs = {};
        class Base64Sound {
            constructor (t, params) {
                
                this.audio = t;
                this.audioContext = new(AudioContext || webkitAudioContext);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                this.source = null;
                this.buffer = null;
                
                this.gainNode = this.audioContext.createGain();
    
                this.isPlaying = 0;
                this.startTime = 0;
                this.elapsedTime = 0;
                this.duration = 0;
                this.hasEnded = 0;
                this.isPaused = 0;
    
                this.loop = 0;
                this.onLoad = null;
                this.onEnd = null;
                this.nextSong = null;
                this.nextSound = null;
                this.fadeIn =  false;
                this.fadeDuration =  1;
                this.volume = 1;
                this.ownVolume = 1;
    
                for (let param in params) {
                    this[param] = params[param];
                }

                this.setVolume(1);
                this.loadAudio();
    
            };
    
            _convertBase64ToArrayBuffer(t) {
                let l = t.split(",");
                let e = atob(l[1] ? l[1]: l[0]);
                for (var i = e.length, a = new Uint8Array(i), n = 0; n < i; n++) a[n] = e.charCodeAt(n);
                return a.buffer;
            };
    
            loadAudio() {
                let e = this._convertBase64ToArrayBuffer(this.audio), i = this;
                this.audioContext.decodeAudioData(e, function(t) {
                    i.buffer = t;
                    i.duration = t.duration;
                    loadedAudio++;
                    if (i.onLoad) i.onLoad();
                }, function(t) {});
            };
    
            togglePlayPause() {
                this.hasEnded ? (this.play(), this.hasEnded = 0) : (this.isPlaying ? this.pause() : !this.isPlaying && this.buffer && this.play());
            };
    
            play() {
                if (this.buffer) {
    
                    this.source = this.audioContext.createBufferSource();
                    this.source.buffer = this.buffer;
                    this.source.connect(this.gainNode);
                    this.gainNode.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
    
                    let t = this.elapsedTime > 0 ? this.elapsedTime : 0;
                    this.startTime = this.audioContext.currentTime - t;
                    this.source.start(0, t);
                    this.isPlaying = 1;
                    this.hasEnded = 0;
                    this.isPaused = 0;
    
                    // Set initial volume
                    this.gainNode.gain.setValueAtTime(this.fadeIn ? 0 : this.volume, this.audioContext.currentTime);
                    if (this.fadeIn) {
                        this.gainNode.gain.linearRampToValueAtTime(this.volume, this.audioContext.currentTime + this.fadeDuration); // Use fadeInDuration for fade in
                    }
    
                    let e = this;
                    this.source.onended = function() {
                        if (e.onEnd && e.isPlaying) e.onEnd();
                        if (e.nextSong && e.isPlaying && songs[e.nextSong]) songs[e.nextSong].play();
                        if (e.nextSound && e.isPlaying && sounds[e.nextSound]) sounds[e.nextSound].play();
                        e.isPaused || (e.loop ? e.play() : (e.isPlaying = 0, e.elapsedTime = 0, e.hasEnded = 1));
                    };
    
                }
            };
    
            stop() {
                
                this.isPlaying = 0;
                this.startTime = 0;
                this.elapsedTime = 0;
                this.hasEnded = 0;
                this.isPaused = 1;
    
                if (this.source) {
                    this.source.stop();
                }
    
            };
    
            pause() {
                this.isPlaying && (this.source.stop(), this.elapsedTime = this.audioContext.currentTime - this.startTime, this.isPlaying = 0, this.isPaused = 1);
            };
            
            calculateVolume(volume) {
                this.volume = volume * this.ownVolume * (this.isSong ? masterSongVolume : masterSoundVolume) * masterVolume;
            };

            setVolume(volume) {
                this.calculateVolume(volume);
                let currentTime = this.audioContext.currentTime;
                this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, currentTime);
                this.gainNode.gain.linearRampToValueAtTime(this.volume, currentTime + 0.01);
            };
            
            fadeOut(duration) {
                this.gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + (duration||this.fadeDuration));
                let e = this;
                setTimeout(function() {
                    e.stop();
                }, duration * 1000);
            };
        }

        function parseAudio(){
            
            console.log('---Parsing audio---');
            
            let Sounds = [
                {
                    name: "cute1",
                    data: cute1,
                    ownVolume: 0.2
                },
                {
                    name: "cute2",
                    data: cute2,
                    ownVolume: 0.2
                },
                {
                    name: "cute3",
                    data: cute3,
                    ownVolume: 0.2
                },
                {
                    name: "cute4",
                    data: cute4,
                    ownVolume: 0.2
                },
                {
                    name: "cute5",
                    data: cute5,
                    ownVolume: 0.2
                },
                {
                    name: "dial_up",
                    data: dial_up,
                },
                {
                    name: "wilhelm",
                    data: wilhelm,
                    ownVolume: 0.7
                },
                {
                    name: "underwater",
                    data: underwater,
                    fadeIn: 1,
                    loop: 1,
                },
                {
                    name: "splash1",
                    data: splash1,
                    ownVolume: 0.5,
                },
                {
                    name: "splash2",
                    data: splash2,
                    ownVolume: 0.5,
                },
                {
                    name: "egg1",
                    data: egg1
                },
                {
                    name: "egg2",
                    data: egg2,
                },
                {
                    name: "cave1",
                    data: cave1,
                },
                {
                    name: "crumble1",
                    data: crumble1,
                    ownVolume: 0.5
                },
                {
                    name: "crumble2",
                    data: crumble2,
                    ownVolume: 0.5
                },
                {
                    name: "evil_talking",
                    data: evil_talking,
                },
                {
                    name: "garble",
                    data: garble,
                },
                {
                    name: "landing",
                    data: landing,
                },
                {
                    name: "hard_landing",
                    data: hard_landing,
                },
                {
                    name: "pitbull",
                    data: pitbull,
                },
                {
                    name: "talking1",
                    data: talking1,
                },
            ];
            let Songs = [
                {
                    name: "dark1",
                    data: dark1,
                    nextSong: "dark2",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "dark2",
                    data: dark2,
                    nextSong: "dark3",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "dark3",
                    data: dark3,
                    nextSong: "dark4",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "dark4",
                    data: dark4,
                    nextSong: "dark1",
                    fadeIn: 1,
                    fadeDuration: 5,
                },
                {
                    name: "happy1",
                    data: happy1,
                    fadeIn: 1,
                    fadeDuration: 5,
                    ownVolume: 0.4
                },
                {
                    name: "happy2",
                    data: happy2,
                    ownVolume: 1.5
                },
                {
                    name: "bossfight",
                    data: bossfight,
                },
                {
                    name: "cataclysmic_intro",
                    data: cataclysmic_intro,
                },
                {
                    name: "master_intro",
                    data: master_intro,
                },
                {
                    name: "powerup",
                    data: powerup,
                },
            ];
            
            for(let i = 0; i < Sounds.length; i++){
                sounds[Sounds[i].name] = new Base64Sound(Sounds[i].data, Sounds[i]);
            }
            for(let i = 0; i < Songs.length; i++){
                songs[Songs[i].name] = new Base64Sound(Songs[i].data, Songs[i]);
            }

        }

        function stopAllSounds(){
            for(let sound in sounds){
                sounds[sound].stop();
            }
        }
        function stopAllSongs(){
            for(let song in songs){
                songs[song].stop();
            }
        }
        function stopAllAudio(){
            stopAllSounds();
            stopAllSongs();
        }
        stopAllAudio();
        
        //link game sounds
        /*
        for(let i = 1; i <= 7; i++){
            let s = songs["gameplay"+(i !== 1 ? i : "")];
            s.n = ((i+1) % 8);
            s.onEnd = function(){
                songs["gameplay"+(this.n ? this.n : "")].play();
            };
        }*/
    
    </script>

    <!--Backgrounds-->
    <script type>

        let backgrounds = {
            farm: [5, 6, 6, 6],
            food: [3, ],
            forest: [
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
            ],
            industrial: [
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
            ],
        }
        for(let b in backgrounds){
            let back = backgrounds[b];
            // let dScript = document.createElement('script');
            // dScript.src = 'https://cdn.jsdelivr.net/gh/CataclysmicCode/de_block_2/Audio/'+audioNames[i]+'.min.js';
            // document.body.appendChild(dScript);
        }

    </script>

    <!--Loader-->
    <script type>

        document.addEventListener("DOMContentLoaded", () => {

            const progressBar = document.getElementById("progress-bar");

            function updateProgress(percentage) {
                progressBar.style.width = percentage + "%";
            }

            let totalResources = 0;
            let loadedResources = 0;

            function resourceLoaded() {
                loadedResources++;
                const percentLoaded = Math.round((loadedResources / totalResources) * 100);
                updateProgress(percentLoaded);
            }

            // Find all resources to be loaded
            const resources = document.querySelectorAll("img, script, link[rel='stylesheet']");
            totalResources = resources.length-8;

            resources.forEach(resource => {
                if (resource.complete) {
                    resourceLoaded();
                } else {
                    resource.addEventListener("load", resourceLoaded);
                    resource.addEventListener("error", resourceLoaded); // in case of loading error
                }
            });

        });
    
    </script>

    <!--Art Bitmaps-->
    <script type="text/javascript" src="art.js"></script>
    
    <!--Main-->
    <script type="application/javascript">function program(){

/** Predefs **/
// [

smooth();
size(600, 600);

let instantLoad = true;

let entities = [],
    enemies = [],
    player,
    keys = {},
    levelW = 0,
    levelH = 0;

// Constants
const blockW = 40,
    blockH = 40,
    GRAVITY = Math.PI/10,
    PADDING_Y = height * 2, // Padding around the y axis of a level
    PADDING_X = width * 2, // Padding around the x axis of a level
    MAX_DIST = 20; // Maximum distance for the player's pathfinder to check

// ]

/** Camera **/
// [

let cam = {
    x: 0,
    y: 0,
    scale: 1,
    speed: 20,
    moveTo: function(obj) {
        this.x += ((obj.x+obj.w/2)-this.x-(width/(2*this.scale)))/this.speed;
        this.y += ((obj.y+obj.h/2)-this.y-(height/(2*this.scale)))/this.speed;
    }
};
window.cam = cam;

// ]

/** Functions **/
// [

// Screen size adjustments
function tx(x){
    // Coded on 600 width, but it works on anything
    return (x/600)*width;
}
function ty(y) {
    // Coded on 600 height, but it works on anything
    return (y/600)*height;
}
function T(t) {
    // Minimum squashing
    return (t/600)*min(width, height);
}
function Dist(d1, d2){
    return ((d1-d2)||1);
}
function easeOut(d1, d2, speed){
    return Dist(d1, d2)/speed;
}

// To grid
function toGrid(x, y, w = 0, h = 0) {
    return {
        x: min(max(floor((x + (w / 2) + PADDING_X) / blockW), 0), blocks[0].length-1),
        y: min(max(floor((y + (h / 2) + PADDING_Y) / blockH), 0), blocks.length-1)
    };
}
function collide(p1, p2) {
    return p1.x + p1.w > p2.x && p2.x + p2.w > p1.x && p1.y + p1.h > p2.y && p2.y + p2.h > p1.y;
}

// Random color
function randomColor() {
    return color(random(0, 255), random(0, 255), random(0, 255));
}

// ]

/** Mouse **/
// [

const mouse = {

    // Store mouse Status
    clicked: false,
    pressed: false, // Same as clicked
    released: false,

    // Mouse coordinates (not very useful lol)
    x: mouseX,
    y: mouseY,

    // Release the mouse
    release: function() {

        this.clicked = false;
        this.pressed = false;
        this.released = true;

    },

    // Use the mouse (for some action)
    use: function() {

        this.clicked = false;
        this.pressed = false;
        this.released = true;

    },

    // Update the mouse (call at the end of the draw loop)
    update: function() {

        this.x = mouseX;
        this.y = mouseY;
        this.released = false;

    },

    // Press the mouse
    press: function() {
        this.clicked = true;
        this.pressed = true;
    }

};

// ]

/** Art **/
// [

function createProcessingImage(base64String) {
    const dataUrl = 'data:image/png;base64,' + base64String;

    loadImage(dataUrl, (img) => {
        image(img, 0, 0);
    });
}

const colors = {
    // white black and all shades of gray
    "-": color(-1, 0),
    "+": color(-1),
    "0": color(231),
    "1": color(207.9),
    "2": color(184.8),
    "3": color(161.7),
    "4": color(138.6),
    "5": color(115.5),
    "6": color(92.4),
    "7": color(69.3),
    "8": color(46.2),
    "9": color(23.1),
    ".": color(0),
    // pinki
    "p": color(240, 40, 240),
    "P": color(190, 40, 190),
    "w": color(240, 80, 240),
    // yellow
    "y": color(220, 220, 30),
    "Y": color(170, 170, 30),
    "W": color(230, 230, 70),
    // green
    "g": color(30, 200, 30),
    "G": color(30, 150, 30),
    "t": color(30, 220, 30),
    // brown
    "b": color(100, 50, 0),
    "B": color(70, 40, 0),
    // orange
    "o": color(255, 127.5, 0),
    "O": color(220, 110, 0),
    "T": color(255, 140, 70),
    // red
    "r": color(255, 0, 0),
    "R": color(222.5, 0, 0),
    "e": color(100, 0, 0),
    "E": color(255, 100, 100),
    // blue
    "u": color(40, 40, 220),
    "U": color(40, 40, 150),
    "i": color(70, 70, 230),
    "^": color(20, 120, 240),
    "v": color(20 / 1.15, 120 / 1.15, 240 / 1.15),
    "V": color(20 / 1.3, 120 / 1.3, 240 / 1.3),
    // purpur
    "q": color(127.5, 0, 255),
    "Q": color(90, 0, 180),
    "I": color(150, 50, 255),
};

// Make other pools
const colorSub = "blue,uU yellow,yY orange,oO green,gG purple,pP brown,bB".split(" ");
for(let a = 0; a < colorSub.length; a++){
    
    // Pool
    let colorArt = [], name = colorSub[a].split(",")[0], symbols = colorSub[a].split(",")[1];
    for(let i = 0; i < art.redPool.length; i++){
        let colorImage = [];
        for(let j = 0; j < art.redPool[i].length; j++){
            colorImage.push(art.redPool[i][j].replaceAll("r", symbols[0]).replaceAll("R", symbols[1]));
        }
        colorArt.push(colorImage);
    }
    art[name+"Pool"] = colorArt;

    // Pool top
    colorArt = [];
    name = colorSub[a].split(",")[0];
    symbols = colorSub[a].split(",")[1];
    for(let i = 0; i < art.redPoolTop.length; i++){
        let colorImage = [];
        for(let j = 0; j < art.redPoolTop[i].length; j++){
            colorImage.push(art.redPoolTop[i][j].replaceAll("r", symbols[0]).replaceAll("R", symbols[1]));
        }
        colorArt.push(colorImage);
    }
    art[name+"PoolTop"] = colorArt;

}

if(instantLoad){

    // Render art
    noStroke();
    for(let a in art){
        if(typeof art[a][0] === "string"){
            background(0, 0);
            let pixelW = 400/art[a][0].length,
                pixelH = 400/art[a].length;
            for(let i = 0; i < art[a].length; i++){
                for(let j = 0; j < art[a][i].length; j++){
                    fill(colors[art[a][i][j]]);
                    rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                }
            }
            art[a] = get(0, 0, 400, 400);
        }else{
            for(let t = 0; t < art[a].length; t++){
                background(0, 0);
                let pixelW = 400/art[a][t][0].length,
                    pixelH = 400/art[a][t].length;
                for(let i = 0; i < art[a][t].length; i++){
                    for(let j = 0; j < art[a][t][i].length; j++){
                        fill(colors[art[a][t][i][j]]);
                        rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                    }
                }
                art[a][t] = get(0, 0, 400, 400);
            }
        }
    }
    for(let s in sprites){
        background(0, 0);
        if(typeof sprites[s][0] === "string"){
            background(0, 0);
            let pixelW = 400/sprites[s][0].length,
                pixelH = height/sprites[s].length;
            for(let i = 0; i < sprites[s].length; i++){
                for(let j = 0; j < sprites[s][i].length; j++){
                    fill(colors[sprites[s][i][j]]);
                    rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                }
            }
            sprites[s] = get(0, 0, 400, 400);
        }else{
            for(let t = 0; t < sprites[s].length; t++){
                background(0, 0);
                let pixelW = 400/sprites[s][t][0].length,
                    pixelH = 400/sprites[s][t].length;
                for(let i = 0; i < sprites[s][t].length; i++){
                    for(let j = 0; j < sprites[s][t][i].length; j++){
                        fill(colors[sprites[s][t][i][j]]);
                        rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                    }
                }
                sprites[s][t] = get(0, 0, 400, 400);
            }
        }
    }
    console.log('---Images loaded---');

}

// ]

/** Pixel character (font) class **/
// [

// The amazing pixel art font in bitmap form(ish)
const pixelFont = {
    "0": "011110,111111,110011,110011,110011,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "1": "001100,111100,111100,001100,001100,001100,001100,001100,001100,111111,111111,000000,000000,000000,".split(","),
    "2": "011110,111111,110011,000011,000011,000111,001110,011100,111000,111111,111111,000000,000000,000000,".split(","),
    "3": "011110,111111,110011,000011,001110,001111,000011,000011,110011,111111,011110,000000,000000,000000,".split(","),
    "4": "110011,110011,110011,110011,110011,111111,011111,000011,000011,000011,000011,000000,000000,000000,".split(","),
    "5": "111111,111111,110000,110000,111110,111111,000011,000011,000011,111111,111110,000000,000000,000000,".split(","),
    "6": "011110,111111,110011,110000,111110,111111,110011,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "7": "111111,111111,000011,000011,000111,000110,001110,001100,001100,001100,001100,000000,000000,000000,".split(","),
    "8": "011110,111111,110011,110011,011110,111111,110011,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "9": "011110,111111,110011,110011,110011,111111,011111,000011,110011,111111,011110,000000,000000,000000,".split(","),
    "a": "000000,000000,000000,111110,111111,000011,011111,111111,110011,111111,011111,000000,000000,000000,".split(","),
    "b": "110000,110000,110000,111110,111111,110011,110011,110011,110011,111111,111110,000000,000000,000000,".split(","),
    "c": "000000,000000,000000,011111,111111,110000,110000,110000,110000,111111,011111,000000,000000,000000,".split(","),
    "d": "000011,000011,000011,011111,111111,110011,110011,110011,110011,111111,011111,000000,000000,000000,".split(","),
    "e": "000000,000000,000000,011110,111111,110011,111111,111111,110000,111111,011111,000000,000000,000000,".split(","),
    "f": "001111,011111,011000,111110,111110,011000,011000,011000,011000,011000,011000,000000,000000,000000,".split(","),
    "g": "000000,000000,000000,011110,111111,110011,110011,110011,110011,111111,011111,000011,111111,111110,".split(","),
    "h": "110000,110000,110000,111110,111111,110011,110011,110011,110011,110011,110011,000000,000000,000000,".split(","),
    "i": "11,11,00,11,11,11,11,11,11,11,11,00,00,00,".split(","),
    "j": "000011,000011,000000,000011,000011,000011,000011,000011,000011,000011,000011,110011,111111,011110,".split(","),
    "k": "110000,110000,110000,110011,110011,110110,111100,111100,110110,110011,110011,000000,000000,000000,".split(","),
    "l": "11,11,11,11,11,11,11,11,11,11,11,00,00,00,".split(","),
    "m": "00000000,00000000,00000000,11111110,11111111,11011011,11011011,11011011,11011011,11011011,11011011,00000000,00000000,00000000,".split(","),
    "n": "000000,000000,000000,111110,111111,110011,110011,110011,110011,110011,110011,000000,000000,000000,".split(","),
    "o": "000000,000000,000000,011110,111111,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "p": "000000,000000,000000,111110,111111,110011,110011,110011,110011,111111,111110,110000,110000,110000,".split(","),
    "q": "000000,000000,000000,011111,111111,110011,110011,110011,110011,110011,011111,000011,000011,000011,".split(","),
    "r": "000000,000000,000000,110111,111111,111000,110000,110000,110000,110000,110000,000000,000000,000000,".split(","),
    "s": "000000,000000,000000,011111,111111,110000,111110,011111,000011,111111,111110,000000,000000,000000,".split(","),
    "t": "011000,011000,011000,111111,111111,011000,011000,011000,011000,011111,001111,000000,000000,000000,".split(","),
    "u": "000000,000000,000000,110011,110011,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "v": "000000,000000,000000,110011,110011,110011,110011,011110,011110,001100,001100,000000,000000,000000,".split(","),
    "w": "00000000,00000000,00000000,11011011,11011011,11011011,11011011,11011011,11011011,11111111,11111110,00000000,00000000,00000000,".split(","),
    "x": "0000000,0000000,0000000,1100011,1100011,0110110,0011100,0011100,0110110,1100011,1100011,0000000,0000000,0000000,".split(","),
    "y": "000000,000000,000000,110011,110011,110011,110011,110011,110011,111111,011111,000011,111111,111110,".split(","),
    "z": "000000,000000,000000,111111,111111,000111,001110,011100,111000,111111,111111,000000,000000,000000,".split(","),
    "A": "011110,111111,110011,110011,110011,111111,111111,110011,110011,110011,110011,000000,000000,000000,".split(","),
    "B": "111110,111111,110011,110011,111110,111111,110011,110011,110011,111111,111110,000000,000000,000000,".split(","),
    "C": "011111,111111,110000,110000,110000,110000,110000,110000,110000,111111,011111,000000,000000,000000,".split(","),
    "D": "111110,111111,110011,110011,110011,110011,110011,110011,110011,111111,111110,000000,000000,000000,".split(","),
    "E": "011111,111111,110000,110000,111110,111110,110000,110000,110000,111111,011111,000000,000000,000000,".split(","),
    "F": "011111,111111,110000,110000,111110,111110,110000,110000,110000,110000,110000,000000,000000,000000,".split(","),
    "G": "011111,111111,110000,110000,110000,110111,110111,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "H": "110011,110011,110011,110011,111111,111111,110011,110011,110011,110011,110011,000000,000000,000000,".split(","),
    "I": "111111,111111,001100,001100,001100,001100,001100,001100,001100,111111,111111,000000,000000,000000,".split(","),
    "J": "111111,111111,000110,000110,000110,000110,000110,110110,110110,111110,011100,000000,000000,000000,".split(","),
    "K": "110011,110011,110110,110110,111100,111100,111100,110110,110110,110011,110011,000000,000000,000000,".split(","),
    "L": "110000,110000,110000,110000,110000,110000,110000,110000,110000,111111,011111,000000,000000,000000,".split(","),
    "M": "11111110,11111111,11011011,11011011,11011011,11011011,11011011,11000011,11000011,11000011,11000011,00000000,00000000,00000000,".split(","),
    "N": "111110,111111,110011,110011,110011,110011,110011,110011,110011,110011,110011,000000,000000,000000,".split(","),
    "O": "111110,111111,110011,110011,110011,110011,110011,110011,110011,111111,011111,000000,000000,000000,".split(","),
    "P": "111110,111111,110011,110011,111111,111110,110000,110000,110000,110000,110000,000000,000000,000000,".split(","),
    "Q": "0111100,1111110,1100110,1100110,1100110,1100110,1100110,1100110,1100110,1111110,0111111,0000011,0000000,0000000,".split(","),
    "R": "111110,111111,110011,110011,111111,111110,110111,110011,110011,110011,110011,000000,000000,000000,".split(","),
    "S": "011111,111111,110000,110000,111110,011111,000011,000011,000011,111111,111110,000000,000000,000000,".split(","),
    "T": "111111,111111,001100,001100,001100,001100,001100,001100,001100,001100,001100,000000,000000,000000,".split(","),
    "U": "110011,110011,110011,110011,110011,110011,110011,110011,110011,111111,011110,000000,000000,000000,".split(","),
    "V": "1100011,1100011,1100011,1100011,0110110,0110110,0110110,0110110,0011100,0011100,0011100,0000000,0000000,0000000,".split(","),
    "W": "11000011,11000011,11000011,11000011,11011011,11011011,11011011,11011011,11011011,11111111,01111110,00000000,00000000,00000000,".split(","),
    "X": "11000011,11000011,11000011,01100110,00111100,00011000,00111100,01100110,11000011,11000011,11000011,00000000,00000000,00000000,".split(","),
    "Y": "110011,110011,110011,110011,110011,111111,011110,001100,001100,001100,001100,000000,000000,000000,".split(","),
    "Z": "111111,111111,000011,000011,000110,001100,011000,110000,110000,111111,111111,000000,000000,000000,".split(","),
    " ": "000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,000000,".split(","),
    ".": "00,00,00,00,00,00,00,00,00,11,11,00,00,00,".split(","),
    ",": "00,00,00,00,00,00,00,00,00,11,11,01,10,00,".split(","),
    ":": "00,00,00,11,11,00,00,00,00,11,11,00,00,00,".split(","),
    ";": "00,00,00,11,11,00,00,00,00,11,11,01,10,00,".split(","),
    "!": "11,11,11,11,11,11,11,11,00,11,11,00,00,00,".split(","),
    "?": "011110,111111,110011,000011,000110,001100,001100,001100,000000,001100,001100,000000,000000,000000,".split(","),
    "(": "0111,1111,1100,1100,1100,1100,1100,1100,1100,1100,1100,1111,0111,0000,".split(","),
    ")": "1110,1111,0011,0011,0011,0011,0011,0011,0011,0011,0011,1111,1110,0000,".split(","),
    "[": "11111,11111,11000,11000,11000,11000,11000,11000,11000,11000,11000,11111,11111,00000,".split(","),
    "]": "11111,11111,00011,00011,00011,00011,00011,00011,00011,00011,00011,11111,11111,00000,".split(","),
    "{": "0001111,0011111,0011000,0011000,0110000,0110000,1100000,0110000,0110000,0011000,0011000,0011111,0001111,0000000,".split(","),
    "}": "1111000,1111100,0001100,0001100,0000110,0000110,0000011,0000110,0000110,0001100,0001100,1111100,1111000,0000000,".split(","),
    "+": "000000,000000,000000,000000,001100,001100,111111,111111,001100,001100,000000,000000,000000,000000,".split(","),
    "-": "000000,000000,000000,000000,000000,000000,111111,111111,000000,000000,000000,000000,000000,000000,".split(","),
    "=": "000000,000000,000000,000000,111111,111111,000000,111111,111111,000000,000000,000000,000000,000000,".split(","),
    "@": "00111111100,01111111110,11100000111,11001110011,11011111011,11011011011,11011111011,11001111011,11100011111,01111001110,00111100000,00000000000,00000000000,00000000000,".split(","),
    "#": "0011001100,0011001100,1111111111,1111111111,0011001100,0011001100,0011001100,1111111111,1111111111,0011001100,0011001100,0000000000,0000000000,0000000000,".split(","),
    "$": "001100,001100,011111,111111,110000,111110,011111,000011,111111,111110,001100,001100,000000,000000,".split(","),
    "%": "000000011000,000000011000,011000110000,100100110000,100101100000,011001100110,000001101001,000011001001,000011000110,000110000000,000110000000,000000000000,000000000000,000000000000,".split(","),
    "^": "00011000,00111100,01100110,11000011,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,".split(","),
    "&": "0011110000,0111111000,0110011000,0110011000,0011110000,0011100000,0110110100,1100011100,1100001100,1111111110,0111111011,0000000000,0000000000,0000000000,".split(","),
    "*": "10101,01110,11111,01110,10101,00000,00000,00000,00000,00000,00000,00000,00000,00000,".split(","),
    "_": "0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,0000000,1111111,0000000,0000000,".split(","),
    "<": "0000,0000,0000,0001,0011,0110,1100,1100,0110,0011,0001,0000,0000,0000,".split(","),
    ">": "0000,0000,0000,1000,1100,0110,0011,0011,0110,1100,1000,0000,0000,0000,".split(","),
    "`": "110,011,001,000,000,000,000,000,000,000,000,000,000,000,".split(","),
    "~": "000000,000000,000000,000000,000000,011000,111101,101111,000110,000000,000000,000000,000000,000000,".split(","),
    "\\": "110000,110000,011000,011000,001100,001100,001100,000110,000110,000011,000011,000000,000000,000000,".split(","),
    "/": "000011,000011,000110,000110,001100,001100,001100,011000,011000,110000,110000,000000,000000,000000,".split(","),
    "|": "11,11,11,11,11,00,11,11,11,11,11,00,00,00,".split(","),
    "'": "11,11,01,00,00,00,00,00,00,00,00,00,00,00,".split(","),
    "\"": "11011,11011,01001,00000,00000,00000,00000,00000,00000,00000,00000,00000,00000,00000,".split(","),
};

// Render the pixel art font
for (let letter in pixelFont) {
    
    const data = pixelFont[letter];

    // Empty current spot in the array for reusability
    pixelFont[letter] = [];

    background(0, 0);
    strokeWeight(1);

    // Two different colors
    const fontColors = [
        30,
        255
    ];
    for (let a = 0; a < 2; a++) {

        fill(fontColors[a]);
        stroke(fontColors[a]);
        const pixelSize = 20;
        for (let i = 0; i < data.length; i++) {
            for (let j = 0; j < data[i].length; j++) {
                if (data[i][j] === "1") {
                    rect(j * pixelSize, i * pixelSize, pixelSize, pixelSize);
                }
            }
        }
        
        // Store the current letter in the pixel art array
        pixelFont[letter].push(get(0, 0, pixelSize * data[0].length, pixelSize * data.length));

    }

}

/**
 * Pixelized Character
 * 
 * A single pixelized letter that can be animated and used
 * in combination with more of itself to form strings
 * 
 * @param {object} params - Contains the Character's parameters.
 *     @param {string} char - A single character representing the character
 **/
class Character {

    constructor(params) {

        this.char = " ";
        this.size = 10;
        this.index = 0;

        for (var param in params) {
            this[param] = params[param];
        }

    }

    /**
     * Display the letter at the specified size & color
     **/
    display(size, color) {

        // Nope
        if (!pixelFont[this.char]) return;

        // Do it
        const data = pixelFont[this.char][color];
        const width = size * (data.width / data.height), height = size;
        pushMatrix();
            // translate(width / 2, height / 2);
            // rotate(cos((frameCount * 2) + (this.index * 10)) * 10);
            // image(data, -width / 2, -height / 2, width, height);
            image(data, 0, 0, width, height);
        popMatrix();

    }

    /**
     * Get the width and height of the character
     **/
    get height() {

        if (!pixelFont[this.char]) return 0;
        return pixelFont[this.char][0].height;

    }
    get width() {
        
        if (!pixelFont[this.char]) return 0;
        return pixelFont[this.char][0].width;

    }

}

// ]

/** Pixel text class **/
// [

/**
 * Pixelized Text
 * 
 * A string of pixelized text that can be displayed on the screen
 * 
 * @param {object} params - Contains the Texts's parameters.
 *     @param {string} string - A string representation of the text
 *     @param {number} size - How big the text is
 *     @param {bool} color - What color the letter is (0 = black, anything else = white)
 *     @param {number} rotation - In degrees
 **/
class PixelText {
    
    constructor(params) {

        // Coincide with each other
        this.chars = [];
        this._string = "";
        this._rows = "";

        // For center align, stores the offset of each row
        this.rowWidths = [];

        // Display stuffs
        this.x = 0;
        this.y = 0;
        this.size = 10;
        this.color = 0;
        this.rotation = 0;
        this.align = CORNER;

        for (var param in params) {
            this[param] = params[param];
        }

    }

    /**
     * A sneaky way to easily update the contents of the text
     **/
    get string() {
        return this._string;
    }
    set string(value) {
        this._string = value;
        this.setChars(value);
    }

    /**
     * Update the characters stored based off of a passed string
     **/
    setChars(string) {

        this.width = 0;
        this.height = 0;
        this.chars = [];
        this.rowWidths = [];

        // Nothing to do
        if (!string.length) return;

        this._rows = string.split("\n");
        let index = 0;
        for (var i = 0; i < this._rows.length; i++) {
            
            // Nothing in this row
            this.chars.push([]);
            if (!this._rows[i].length) {
                this.rowWidths.push(0);
                continue;
            }

            let rowWidth = 0;
            for (let j = 0; j < this._rows[i].length; j++) {
                this.chars[this.chars.length - 1].push(new Character({
                    char: this._rows[i][j],
                    size: this.size,
                    index: index
                }));
                index++;
                rowWidth += this.chars[i][j].width / this.chars[i][j].height || 0;
            }
            this.rowWidths.push(rowWidth);

        }

    }

    /**
     * Display the text
     **/
    display() {

        imageMode(CORNER);
        pushMatrix();
            translate(this.x, this.y);
            rotate(this.rotation);

            const spaceX = this.size / 10,
                spaceY = this.size / 10;
            
            if (this.align === CENTER) {
                translate(0, -((this.chars.length * this.size / 2) + ((this.chars.length - 1) * spaceY / 2)));
            }
            for (let i = 0; i < this.chars.length; i++) {
                pushMatrix();
                    if (this.align === CENTER) {
                        translate(-((this.size * this.rowWidths[i] / 2) + ((this.chars[i].length - 1) * spaceX / 2)), 0);
                    }
                    for (let j = 0; j < this.chars[i].length; j++) {
                        const char = this.chars[i][j];
                        char.display(this.size, this.color);
                        translate(this.size * (char.width / char.height) + spaceX, 0);
                    }
                popMatrix();
                translate(0, this.size + spaceY);
            }

        popMatrix();


    }

}

// ]

/** Pages class **/
// [

/**
 * Page
 * 
 * A scene that can be displayed and has some helpful methods
 * 
 * @param {object} params - Contains the page's parameters.
 *     @param {boolean} visible - Whether the page is visible or not.
 *     @param {function} draw - Called every frame the page is visible for.
 *     @param {function} onSwitch - Called whenever the page's visibily state is changed.
 *     @param {function} onLeave - Called when the page becomes invisible
 *     @param {function} onEnter - Called when the page becomes visible
 **/
class Page {
    constructor(params) {
        this.visible = false;
        this.draw = () => {};
        this.onSwitch = () => {};
        this.onLeave = () => {};
        this.onEnter = () => {};
        for (let i in params) {
            this[i] = params[i];
        }
    }
    
    hide() {
        this.visible = false;
    }
    show() {
        this.visible = true;
    }
    update() {
        try {
            if(this.visible) this.draw();
        } catch(err) {
            println(err);
        }
    }
}

/**
 * Pages
 * 
 * Contains all the pages for the game.
 * 
 * @param {object} params - Contains the parameters for the pages.
 *     @param {object} pages - The object of pages
 *     @param {string} page - A string representing the name of the current visible page
 *     @param {string} lastPage - A string representing the name of the last visible page
 **/
class Pages {
    constructor(params) {
        this.pages = {};
        this.page = undefined;
        this.lastPage = undefined;
        this.Page = undefined;
        for (let i in params) {
            this[i] = params[i];
        }
        for (let i in this.pages) {
            this.pages[i].name = i;
        }
    }
    
    /**
     * Hide a single page
     * 
     * @param {string / object} page - a string or object representing the page to hide
     **/
    hidePage(page) {
        // Hide page
        if (typeof page === "string") {
            // String passed
            this.pages[page].hide();
            if (this.page === page) this.page = undefined;
        } else {
            // Object passed
            page.hide();
            if (this.page === page.name) this.page = undefined;
        }
    }
    
    /**
     * Hide all the pages
     **/
    hidePages() {
        for (let i in this.pages) {
            this.hidePage(i);
        }
    }
    
    /**
     * Hide a single page
     * 
     * @param {string / object} page - a string or object representing the page to show
     **/
    showPage(page) {
        try {
            this.hidePages();
            // Show one page
            if (typeof page === "string") {
                // String passed
                this.pages[page].show();
                this.page = page;
                this.Page = this.pages[page];
            } else {
                // Object passed
                page.show();
                this.page = page.name;
                this.Page = page;
            }
        } catch(err) {
            println(err);
        }
    }
    
    /**
     * Update the pages
     **/
    update() {
        this.lastPage = this.page;
        for (let i in this.pages) {
            this.pages[i].update();
        }
        if (this.lastPage !== this.page) {
            this.pages[this.page].onSwitch();
            this.pages[this.lastPage].onSwitch();
            this.pages[this.page].onEnter();
            this.pages[this.page].onLeave();
        }
    }
}

// ]

/** Light class **/
// [

class Light {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.numRays = 360;
        this.color = color(255, 25);
        this.strength = 255;
        this.rays = [];
        this.visibleRays = [];
        for (let i = 0; i <= this.numRays + 1; i++ && this.visibleRays.push({x:0, y:0})) {}

    }

    castRays(blocks) {
        this.rays = [];
        const step = (2 * Math.PI) / this.numRays;

        for (let angle = 0; angle < 2 * Math.PI; angle += step) {
            this.castRay(angle, blocks);
        }
    }
	castRay(angle, blocks) {
        
        const rayLength = 400;
        const blockSize = 40;
		const dx = Math.cos(angle);
		const dy = Math.sin(angle);

        const compensation = (max(width, height) / rayLength) * 2;

		let t = 0;
		while (t < rayLength) {
			const rayX = this.x + t * dx;
			const rayY = this.y + t * dy;

			const blockX = floor(rayX / blockSize);
			const blockY = floor(rayY / blockSize);

			// Find relative X & Y positions within the current block
			const left = rayX - (blockX * blockSize);
			const top = rayY - (blockY * blockSize);
			const right = blockSize - left;
			const bottom = blockSize - top;
			
			const checks = [
				blockX, blockY,
				blockX+1, blockY,
				blockX, blockY+1,
				blockX-1, blockY,
				blockX, blockY-1
			];
			for (let i = 0; i < checks.length; i += 2) {
				const x = (checks[i] * blockSize), y = (checks[i+1] * blockSize);
				if (
					checks[i] >= 0 &&
					checks[i] < blocks[0].length &&
					checks[i+1] >= 0 &&
					checks[i+1] < blocks.length &&
					rayX >= x && rayX <= x + blockSize &&
					rayY >= y && rayY <= y + blockSize) {

					if (blocks[checks[i+1]][checks[i]].canCollide) {
						this.rays.push({ x: rayX, y: rayY });
						return;
					} else {
						blocks[checks[i+1]][checks[i]].setLight((1 - (t / rayLength)) * this.strength);
					}

				}
			}
			
			const stepX = dx > 0 ? right / abs(dx) : left / abs(dx);
			const stepY = dy > 0 ? bottom / abs(dy) : top / abs(dy);
			
			t += min((stepX || 1), (stepY || 1));

			if (t >= rayLength) {
                this.rays.push({x: this.x + rayLength * dx * compensation, y: this.y + rayLength * dy * compensation});
                return;
			}
		}
	}

    draw() {
		
		fill(this.color, 25);
        // stroke(this.color, 25);
        // strokeWeight(3);
        noStroke();
        beginShape();
            // Subtle animation
            this.visibleRays.forEach((v, i) => {
                this.visibleRays[i].x += (this.rays[i].x - this.visibleRays[i].x) / 4;
                this.visibleRays[i].y += (this.rays[i].y - this.visibleRays[i].y) / 4;
                vertex(v.x - PADDING_X, v.y - PADDING_Y);
            });
        endShape();
		
    }
}

// ]

/** Enemy class **/
// [

class Enemy {
    constructor (params) {
        this.x = 0;
        this.y = 0;
        this.vy = 0;
        this.vx = 0;
        this.w = blockW;
        this.h = blockH;

        this.transition = random(0, 999999);
        this.animateSpeed = 10;
        this.type = "basic";
        this.index = 0;
        this.attacking = false;

        this.inLiquid = false;
        this.isGrounded = false;
        this.isNear = false;
        this.isTouching = false;

        this.strength = -1;
        
        for (let i in params) {
            this[i] = params[i];
        }
    }
    
    /**
     * Efficient collisions
     * 
     * Only check the closest blocks for collisions and ignore all others
     **/
    collide(vx, vy) {
        let X = floor((this.x + PADDING_X) / blockW)-1,
            Y = floor((this.y + PADDING_Y) / blockH)-1,
            toX, toY;
        for (let y = max(Y, 0); y < min(Y+4, blocks.length); y++) {
            for (let x = max(X, 0); x < min(X+4, blocks[y].length); x++) {
                
                let block = blocks[y][x],
                    overlapX = this.x-block.x < 0?(this.w+(this.x-block.x)):(block.w-(this.x-block.x)),
                    overlapY = this.y-block.y < 0?(this.h+(this.y-block.y)):(block.h-(this.y-block.y)),
                    touching = (overlapY > this.h/2) && (overlapX > this.w/2);
                if(block.canCollide) this.isNear = true;
                if (
                    this.x + this.w > block.x &&
                    this.y + this.h > block.y &&
                    block.x + block.w > this.x &&
                    block.y + block.h > this.y
                    ) {
                    
                    // Handle collision
                    if (block.canCollide) {
                        this.isTouching = true;
                        if(vx > 0) {
                            this.vx = 0;
                            toX = block.x - this.w;
                        }
                        if(vx < 0) {
                            this.vx = 0;
                            toX = block.x + block.w;
                        }
                        if(vy > 0) {
                            this.isGrounded = true;
                            this.vy = 0;
                            toY = block.y - this.h;
                        }
                        if(vy < 0) {
                            this.vy = 0;
                            toY = block.y + block.h;
                        }
                    }
                    if (block.isLiquid) {
                        this.inLiquid = true;
                    }
                    block.setColor(this.strength, "none");

                }
                
            }
        }
        
        if(toX !== undefined){
            this.x = toX;
        }
        if(toY !== undefined){
            this.y = toY;
        }
    }

    applyForce(fx, fy) {
        this.vx += fx;
        this.vy += fy;
    }

    /**
     * Reset frame
     * 
     * To be called every frame before the enemy is updated to reset some complex-logic variables
     **/
    resetFrame() {
        this.isTouching = false;
        this.isNear = false;
        this.attacking = false;
        this.transition++;
    }
    
    update() {
        this.logic();
        this.isGrounded = false;
        this.inLiquid = false;
        this.move();
        this.draw();
    }
    draw() {
        let mapped = floor((this.transition/this.animateSpeed)%sprites[this.type].length);
        pushMatrix();
            translate(this.x, this.y);
            image(sprites[this.type][mapped], 0, 0, this.w+1, this.h+1);
        popMatrix();
    }
    logic() {
        this.x += this.vx;
        this.y += this.vy;
    }
    move() {

    }
}

// ]

/** Rottweiler class **/
// [

class Rottweiler extends Enemy {
    constructor (params) {
        super(params);
        this.mv = 5;
        this.type = "rottweiler";
        this.strength = -1;
        this.animateSpeed = 4;
        this.health = 100;
        // this.x += random(-1, 1);
        // this.y += random(-1, 1);
    }
    
    draw() {
        if (this.attacking) {
            let mapped = floor((this.transition / this.animateSpeed) % (sprites[this.type].length - 1)) + 1;
            pushMatrix();
                translate(this.x + this.w / 2, this.y + this.h / 2);
                if (this.vx > 0) {
                    scale(1, -1);
                    rotate(atan2(this.vx, this.vy) + 90);
                } else {
                    rotate(atan2(-this.vx, this.vy) - 90);
                }
                image(sprites[this.type][mapped], -this.w / 2, -this.h / 2, this.w + 1, this.h + 1);
            popMatrix();
        } else {
            pushMatrix();
                translate(this.x, this.y);
                image(sprites[this.type][0], 0, 0, this.w + 1, this.h + 1);
            popMatrix();
        }
    }
    logic() {

        // repulse from other rottweilers
        const repulsionDistance = max(this.w, this.h);
        const repulsionForce = 0.1;
        for (let j = this.index + 1; j < enemies.length; j++) {
            if (enemies[j].type === this.type) {
                const dx = enemies[j].x - this.x;
                const dy = enemies[j].y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                if (distance < repulsionDistance) {
                    this.isTouching = true;
                    const force = repulsionForce * (repulsionDistance - distance) / distance;
                    const fx = force * dx;
                    const fy = force * dy;
                    this.applyForce(-fx, -fy);
                    enemies[j].applyForce(fx, fy);
                }
            }
		}

        // Follow the player's pathfinder
        this.gridPos = toGrid(this.x, this.y, this.w, this.h);
        let p = player.pathfinder,
            g = this.gridPos,
            d = p[g.y][g.x];

        // Calculate the movement velocity
        this.mv = min(map(dist(player.x, player.y, this.x, this.y), 0, 600, 1, 25), 25);
        
        // Find path in the X axis
        let c = [MAX_DIST + 1, {}];
        [
            {x: g.x+1, y: g.y},
            {x: g.x-1, y: g.y},
        ].filter((v) => {
            return v.y < blocks.length && v.y >= 0 && v.x < blocks[0].length && v.x >= 0;
        }).forEach((v) => {
            if (p[v.y][v.x] < c[0] && p[v.y][v.x] !== 0) {
                c[0] = p[v.y][v.x];
                c[1] = v;
            }
        });
        if (c[0] !== MAX_DIST + 1) {
            this.attacking = true;
            this.vx = min(max(this.vx + (c[1].x - g.x) / 5, -this.mv), this.mv);
        }

        // Find path in the Y axis
        c = [MAX_DIST + 1, {}];
        [
            {x: g.x, y: g.y+1},
            {x: g.x, y: g.y-1},
        ].filter((v) => {
            return v.y < blocks.length && v.y >= 0 && v.x < blocks[0].length && v.x >= 0;
        }).forEach((v) => {
            if (p[v.y][v.x] < c[0] && p[v.y][v.x] !== 0) {
                c[0] = p[v.y][v.x];
                c[1] = v;
            }
        });
        if (c[0] !== MAX_DIST + 1) {
            this.attacking = true;
            if (this.isTouching) {
                this.vy = min(max(this.vy + (c[1].y - g.y) / 3, -this.mv), this.mv);
            }
        }

        // Prevent a failed path finding attempt due to lack of velocity
        if (abs(this.vx) < 1) {
            this.vx *= 1.2
        }

        // Drain the player's health
        if (collide(this, player)) {
            player.colorStrength = max(player.colorStrength - 0.1, -100);

            // Drain this rottweiler's own health
            if (player.colorStrength > 0) {
                this.health -= player.colorStrength / 100;
            }
        }

        // Convert when touching liquid or dead
        if (this.inLiquid || this.health <= 0 || this.y > levelH - PADDING_Y) {
            entities.push(new GoodRottweiler({
                x: this.x,
                y: this.y,
                w: this.w,
                h: this.h,
                vx: this.vx,
                vy: this.vy
            }));
            this.dead = true;
        }

    }
    move() {
        
        // Collide x
        this.x += this.vx;
        this.collide(this.vx, 0);
        
        // Collide y
        this.y += this.vy;
        this.collide(0, this.vy);

        // Friction
        const f = 0.01;
        if (this.vx > 0) this.vx = max(this.vx - f, 0);
        if (this.vx < 0) this.vx = min(this.vx + f, 0);
        if (this.vy > 0) this.vy = max(this.vy - f, 0);
        if (this.vy < 0) this.vy = min(this.vy + f, 0);

        this.vy += GRAVITY;
    }

}

// ]

/** Good Rottweiler class **/
// [

class GoodRottweiler {
    constructor (params) {
        
        this.x = 0;
        this.y = 0;
        this.vy = 0;
        this.vx = 0;

        this.w = blockW;
        this.h = blockH;

        this.animateSpeed = 5;
        this.transition = 0;
        this.dead = false;

        this.speed = random(0.5, 1);
        
        for (let i in params) {
            this[i] = params[i];
        }
        
    }
    
    update() {
        
        this.logic();
        this.draw();
        
    }
    draw() {
        
        let mapped = floor(min(this.transition / this.animateSpeed, sprites.goodRottweiler.length - 1));
        pushMatrix();
                translate(this.x + this.w / 2, this.y + this.h / 2);
                if (this.vx > 0) {
                    scale(1, -1);
                    rotate(atan2(this.vx, this.vy) + 90 - this.transition);
                } else {
                    rotate(atan2(-this.vx, this.vy) - 90 + this.transition);
                }
                image(sprites.goodRottweiler[mapped], -this.w / 2, -this.h / 2, this.w + 1, this.h + 1);
            popMatrix();
    }
    logic() {
        
        this.transition++;

        // Keep moving in the original direction, but make the total speed = this.speed
        this.vx = this.vx * (this.speed / sqrt(this.vx * this.vx + this.vy * this.vy));
        this.vy = this.vy * (this.speed / sqrt(this.vx * this.vx + this.vy * this.vy));

        this.x += this.vx;
        this.y += this.vy;

        if(this.x > levelW) this.dead = true;
    
    }
}

// ]

/** Bird class **/
// [

class Bird {
    constructor (params) {
        
        this.x = 0;
        this.y = 0;
        this.vy = 0;
        this.vx = 0;

        this.w = blockW;
        this.h = blockH;

        this.animateSpeed = 10;
        this.transition = random(0, 999999);
        this.dead = false;
        
        for (let i in params) {
            this[i] = params[i];
        }
        
    }
    
    update() {
        
        this.logic();
        this.draw();
        
    }
    draw() {
        
        let mapped = floor((this.transition / this.animateSpeed) % sprites.bird.length);
        image(sprites.bird[mapped], this.x, this.y, this.w+1, this.h+1);
        
    }
    logic() {
        
        this.transition++;
        this.vy = -(noise(this.transition / 100) - 0.4) * 10;
        this.vx = min(this.vx + 0.02, 2);
    
        this.x += this.vx;
        this.y += this.vy;

        if(this.x > levelW) this.dead = true;
    
    }
}

// ]

/** Block class **/
// [

/**
 * Block
 * 
 * @param {object} params - Contains the block's parameters.
 *     @param {number} x/y - The block's coordinates.
 *     @param {string} type - The name of the block, aka the type of block.
 **/
class Block {
    constructor (params) {
        
        this.x = 0;
        this.y = 0;
        this.type = "air";
        this.animateSpeed = 10;
        this.playerDist = 0;
        
        // Color handling
        this.strength = 0;
        this.canSpread = false;
        this.colorName = "none";
        
        // Transition
        this.transSpeed = 50;
        this.transition = -100;
        
        // Light strength
        this.light = 0;
        this.lowest = 0;
        this.displayLowest = 0;
        
        for (let i in params) {
            this[i] = params[i];
        }
        
        this.data = blockData[this.symbol];
    
        for(let i in this.data){
            this[i] = this.data[i];
        }
        
    }
    
    /**
     * Display the block
     * 
     * Display: display the image of the block
     * Draw: handle animations
     **/
    display(art, x, y, w, h) {
        image(art, x, y, w+1, h+1);
    }
    draw() {
        if (art[this.type].length) {
            if (this.canInfiniteAnimate) {
                let mapped = floor((abs(this.transition)/this.animateSpeed)%art[this.type].length);
                this.display(art[this.type][mapped], this.x, this.y, this.w, this.h);
            } else {

                // A block is being colored!
                if (this.strength > 0) {
                    let mapped = round(map(this.transition, this.transSpeed, 0, art[this.type].length-1, 0));
                    if (this.transition < 0) {
                        mapped = art[this.type].length-1;
                    }
                    this.display(art[this.type][constrain(mapped, 0, art[this.type].length-1)], this.x, this.y, this.w, this.h);
                }

                // A block is decaying...
                else {
                    let mapped = round(map(this.transition, -this.transSpeed, 0, art[this.type].length-1, 0));
                    if (this.transition < -this.transSpeed) {
                        mapped = art[this.type].length-1;
                    }
                    this.display(art[this.type][constrain(mapped, 0, art[this.type].length-1)], this.x, this.y, this.w, this.h);
                }

            }
        } else {
            this.display(art[this.type], this.x, this.y, this.w, this.h);
        }
        
        if (!this.canAnimate && this.canChangeColor) {
            
            // A block is being colored!
            if (this.strength > 0) {
                rectMode(CENTER);
                colorMode(HSB);
                
                    noFill();
                    let amount = 20;
                    strokeWeight((this.w/amount)/2);
                    for(let i = 0; i < amount; i++){
                        let size = i*(this.transSpeed/amount);
                        if(this.transition+size > 0 && this.transition+size < this.transSpeed){
                            stroke(map(i, 0, amount, 0, 255), 180, 180, 200);
                            rect(
                                this.x+this.w/2,
                                this.y+this.h/2,
                                map(this.transition+size, this.transSpeed, 0, 0, this.w),
                                map(this.transition+size, this.transSpeed, 0, 0, this.h));
                        }
                    }
                    
                rectMode(CORNER);
                colorMode(RGB);
            }
            
            // A block is decaying...
            else if (this.strength <= 0) {
                rectMode(CENTER);
                
                    noFill();
                    let amount = 20;
                    strokeWeight((this.w/amount)/2);
                    for (let i = 0; i < amount; i++) {
                        let size = i*(this.transSpeed/amount);
                        if (this.transition+size > 0 && this.transition+size < this.transSpeed) {
                            stroke(map(i, 0, amount, 255, 0));
                            rect(
                                this.x+this.w/2,
                                this.y+this.h/2,
                                map(this.transition+size, this.transSpeed, 0, 0, this.w),
                                map(this.transition+size, this.transSpeed, 0, 0, this.h));
                        }
                    }
                    
                rectMode(CORNER);
            }

        }
    }
    shadow() {
        noStroke();
        fill(0, min(255-this.light, 255-this.displayLowest));
        rect(this.x, this.y, this.w, this.h);
        this.light = 0;
    }

    /**
     * Change states
     **/
    changeTo(type) {
        this.canInfiniteAnimate = 0;
        for(let i in this.data){
            this[i] = 0;
        }
        this.onChange = () => {};

        for(let i in blockData[type]){
            this[i] = blockData[type][i];
        }

        if(this.onChange) {
            this.onChange(this);
        }
    }
    setColor(strength, colorName) {
        // Sadly, no
        if (!this.canChangeColor) return;

        if (colorName) this.colorName = colorName;

        // Colorize!
        if (strength > 0) {

            // No point, color is less than this
            if (strength < this.strength) return;

            // Decay transition in progress, maybe later
            if (this.transition >= -this.transSpeed && this.canColor()) return;

            // Set color for the first time
            if (this.canColor()) {
                this.transition = this.transSpeed;
                player.colorStrength = max(player.colorStrength - player.colorDecrease, 0);
                player.hasColored++;
            }

            this.strength = strength;
            this.setLowLight(255);
            this.spread();

        }

        // Decayizeâ¢ï¸...
        else if (strength <= 0) {

            // No point, it's already too far gone );
            if (strength > this.strength) return;

            // Color transition in progress, maybe later
            if (this.transition >= -this.transSpeed && this.canDecay()) return;
            
            // Start decaying for the first time
            if (this.canDecay()) {
                this.transition = this.transSpeed;
                player.hasColored--;
            }

            this.strength = strength;
            this.spread();

        }
    }

    /**
     * Light modification
     * 
     * @param {number} light - Number between 255-0 representing the light level to change to
     **/
    setLight(light) {
		this.light = max(max(this.light, light), 0);
		if (this.light <= 0) return;
		
		const decrease = this.light - (this.canCollide ? (255 / 3) : (255 / 8));
		if (this.index[1] !== blocks[0].length - 1 && blocks[this.index[0]][this.index[1]+1].light < decrease) blocks[this.index[0]][this.index[1]+1].setLight(decrease);
		if (this.index[1] !== 0 && blocks[this.index[0]][this.index[1]-1].light < decrease) blocks[this.index[0]][this.index[1]-1].setLight(decrease);
		if (this.index[0] !== blocks.length - 1  && blocks[this.index[0]+1][this.index[1]].light < decrease) blocks[this.index[0]+1][this.index[1]].setLight(decrease);
		if (this.index[0] !== 0 && blocks[this.index[0]-1][this.index[1]].light < decrease) blocks[this.index[0]-1][this.index[1]].setLight(decrease);
	}
    setLowLight(light) {
        this.lowest = max(max(this.lowest, light), 0);
        if (this.lowest <= 0) return;
        
        const decrease = this.lowest - (this.canCollide ? (255 / 5) : (255 / 10));
        if (this.index[1] !== blocks[0].length - 1 && blocks[this.index[0]][this.index[1]+1].lowest < decrease) blocks[this.index[0]][this.index[1]+1].setLowLight(decrease);
        if (this.index[1] !== 0 && blocks[this.index[0]][this.index[1]-1].lowest < decrease) blocks[this.index[0]][this.index[1]-1].setLowLight(decrease);
        if (this.index[0] !== blocks.length - 1  && blocks[this.index[0]+1][this.index[1]].lowest < decrease) blocks[this.index[0]+1][this.index[1]].setLowLight(decrease);
        if (this.index[0] !== 0 && blocks[this.index[0]-1][this.index[1]].lowest < decrease) blocks[this.index[0]-1][this.index[1]].setLowLight(decrease);
    }

    /**
     * Check the status of the block.
     * 
     * canDecay: Can the block become a decayed block?
     * canColor: Can the block become a colored block?
     **/
    canDecay() {
        return this.strength > 0;
    }
    canColor() {
        return this.strength <= 0;
    }
    isDecayed() {
        return this.strength < 0;
    }
    isColored() {
        return this.strength > 0;
    }

    /**
     * Spread color or decay depending on the block's state
     **/
    spread() {
        let touching = [
            [this.index[0]+1, this.index[1]],
            [this.index[0]-1, this.index[1]],
            [this.index[0], this.index[1]+1],
            [this.index[0], this.index[1]-1]
        ].filter((v) => {
            return v[0] < blocks.length && v[0] >= 0 && v[1] < blocks[0].length && v[1] >= 0;
        });
        
        this.spreadDecay(touching);
        this.spreadColor(touching);
    }
    spreadDecay(touching) {

        // Spread the death
        touching.forEach((v) => {
            if((this.strength + 1) <= blocks[v[0]][v[1]].strength && this.strength < 0) blocks[v[0]][v[1]].setColor(this.strength + 1, this.colorName);
        });

    }
    spreadColor(touching) {

        // Spread the joy
        touching.forEach((v) => {
            if((this.strength - 1) >= blocks[v[0]][v[1]].strength && this.strength > 0) blocks[v[0]][v[1]].setColor(this.strength - 1, this.colorName);
        });

    }

    /**
     * Update the block
     **/
    update() {
        this.logic();
        this.draw();
    }
    logic() {

        // Animation
        if(this.transition === 0){
            if(this.nextType){
                this.changeTo(this.nextType);
            }
        }
        this.transition--;

        // Turn dirt to grass
        let blockAbove = blocks[max(this.index[0]-1, 0)][this.index[1]];
        if(this.type === "grayGrassBlock" && blockAbove){
            if(blockAbove.canCollide && blockAbove.id !== this.id){
                this.changeTo("D");
            }
        }
        if(this.type === "grassBlock"  && blockAbove){
            if(blockAbove.canCollide && blockAbove.id !== this.id){
                this.changeTo("d");
            }
        }
        
        // Add tops to liquid
        if(this.isLiquid  && blockAbove && this.nextType){
            if(blockAbove.type === "air" || blockAbove.id === this.id){
                this.changeTo(this.nextType);
            }
        }
        
        // Update the displayed lowest light smoothly
        this.lowest = (player.hasColored / player.mustColor) * 255;
        this.lowest = player.colorStrength < 0 ? 0 : this.lowest;
        this.displayLowest += (this.lowest - this.displayLowest) / 20;

    }
}

// ]

/** Player class **/
// [

class Player {
    constructor (params) {
        
        // Physics
        this.vx = 0;
        this.vy = 0;
        this.canJump = false;
        this.inLiquid = false;
        this.wasInLiquid = false;
    
        // Color stuff
        this.lastColorStrength = 0;
        this.colorStrength = 0;
        this.colorDecrease = 0.15;
        this.timeSinceColorChange = 0;
        this.lastColor = color(255, 0, 0);
        this.color = color(255, 0, 0);
        this.colorName = "red";

        this.light = new Light(0, 0);
        this.nearDark = {};
        this.pathfinder = [];
        this.blankPathfinder = [];

        // Wonder wut this does
        this.dead = false;
    
        // Counters
        this.hasColored = 0;
        this.mustColor = 0;
        
        for (let i in params) {
            this[i] = params[i];
        }
    
        this.startX = this.x;
        this.startY = this.y;
        
    }
    
    updateHud() {
        // Health bar
        noStroke();
        fill(100);
        rect(100, 20, 400, 10);
        fill(this.lastColorStrength > 0 ? (this.lerpedColor): 0);
        rect(100, 20, map(abs(this.lastColorStrength), 0, 100, 0, 400), 10);
        rectMode(CENTER);
        fill(0);
        for (let i = 100 /5 ; i < 100; i += 100 / 5) {
            rect(map(i, 0, 100, 100, 500), 25, 5, 10);
        }
        rectMode(CORNER);

        // Darkness arrow
        let block = this.nearDark.block;
        if (block && (block.x-cam.x+block.w < 0 || block.x-cam.x > width || block.y-cam.y+block.h < 0 || block.y-cam.y > height)) {
            textAlign(CENTER, CENTER);
            pushMatrix();
                const x = constrain(block.x - cam.x + (block.w / 2), 50, width - 50), y = constrain(block.y - cam.y + (block.w / 2), 50, height - 50);
                translate(x, y);
                rotate(-atan2(x - (block.x - cam.x + (block.w / 2)), y - (block.y - cam.y + (block.h / 2))) - 90);
                let txt = new PixelText({
                    x: 0,
                    y: 0,
                    string: ">",
                    size: 40,
                    color: 0,
                    align: CENTER
                });
                txt.display();
                txt.color = 1;
                txt.size = 30;
                txt.display();
            popMatrix();
        }
    
        // Amount left
        textSize(25, 20, 30);
        fill(100);
        text(this.hasColored+"/"+this.mustColor, 500, 550);  
    }
    
    /**
     * Efficient collisions
     * 
     * Only check the closest blocks for collisions and ignore all others
     **/
    collide(vx, vy) {
        let X = floor((this.x + PADDING_X) / blockW)-1,
            Y = floor((this.y + PADDING_Y) / blockH)-1,
            toX, toY;
        for(let y = max(Y, 0); y < min(Y+4, blocks.length); y++) {
            for(let x = max(X, 0); x < min(X+4, blocks[y].length); x++) {
                
                let block = blocks[y][x],
                    overlapX = max(0, min(this.x + this.w, block.x + block.w) - max(this.x, block.x)),
                    overlapY = max(0, min(this.y + this.h, block.y + block.h) - max(this.y, block.y)),
                    touching = (overlapY > this.h/4) && (overlapX > this.w/4);
                if(
                    this.x + this.w > block.x &&
                    this.y + this.h > block.y &&
                    block.x + block.w > this.x &&
                    block.y + block.h > this.y
                    ) {
                    
                    // Handle collision
                    if(block.canCollide){
                        if(vx > 0) {
                            this.vx = 0;
                            toX = block.x - this.w;
                        }
                        if(vx < 0) {
                            this.vx = 0;
                            toX = block.x + block.w;
                        }
                        if(vy > 0) {
                            if (this.colorStrength > 0 && this.vy > 1) {
                                for(let i = 0; i < (this.vy * (this.colorStrength / 20)) / 2; i++){
                                    pages.Page.particles.add(new Particle({
                                        x: random(this.x, this.x+this.w),
                                        y: this.y+this.h,
                                        vx: random(-3, 3),
                                        vy: random(-3, -5),
                                        w: blockW/10,
                                        color: this.mixedColor,
                                        fade: true,
                                        health: round(random(30, 50)),
                                        image: "ellipse",
                                        onUpdate: function(){
                                            this.vy += GRAVITY;
                                        }
                                    }));
                                }
                            }
                            this.canJump = true;
                            if (this.vy > 15) {
                                sounds["hard_landing"].play();
                            }else if (this.vy > 2) {
                                sounds["landing"].setVolume(map(this.vy, 1, 15, 0.1, 3));
                                sounds["landing"].play();
                            }
                            this.vy = 0;
                            toY = block.y - this.h;
                        }
                        if(vy < 0) {
                            this.vy = 0;
                            toY = block.y + block.h;
                        }
                    }
                    if(block.isLiquid && touching){
                        this.inLiquid = block;
                        this.colorName = block.name;
                        this.canJump = true;
                    }
                    
                    if(this.colorStrength !== 0) block.setColor(ceil(this.colorStrength/20), this.colorName);
                    
                }
                
            }
        }
        
        if(toX !== undefined){
            this.x = toX;
        }
        if(toY !== undefined){
            this.y = toY;
        }
    }
    
    /**
     * 
     * Find the nearest uncolored block
     * 
     **/
    findNearDark() {
        this.nearDark = {};
        if (this.hasColored < this.mustColor) {
            for (let i = 0; i < blocks.length; i++) {
                for (let j = 0; j < blocks[i].length; j++) {
                    let block = blocks[i][j];
                    if (block.canChangeColor && block.strength <= 0) {
                        let d = dist(this.x, this.y, block.x, block.y);
                        if(this.nearDark.block) {
                            if (this.nearDark.dist > d) {
                                this.nearDark.block = blocks[i][j];
                                this.nearDark.dist = d;
                            }
                        } else {
                            this.nearDark.block = blocks[i][j];
                            this.nearDark.dist = d;
                        }
                    }
                }
            }
        }
    }
    reset() {
        this.x = this.startX;
        this.y = this.startY;
        this.vx = 0;
        this.vy = 0;
        this.nearDark = {};
        this.pathfinder = this.blankPathfinder.map(innerArray => [...innerArray]);
    }

    /**
     * Path finding
     * 
     * Calculate the path around the player by a certain radius
     **/
    findPath() {
        this.pathfinder = this.blankPathfinder.map(innerArray => [...innerArray]);
        const pos = toGrid(this.x, this.y, this.w, this.h);
        this.pathfinder[pos.y][pos.x] = 1;
        this.movePath(pos, 2, MAX_DIST);
    }
    movePath(p, a, m) {
        if (a > m) return;
        
        [
            {x: p.x+1, y: p.y},
            {x: p.x-1, y: p.y},
            {x: p.x, y: p.y+1},
            {x: p.x, y: p.y-1}
        ].filter((v) => {
            return v.y < blocks.length && v.y >= 0 && v.x < blocks[0].length && v.x >= 0 && !blocks[v.y][v.x].canCollide && (this.pathfinder[v.y][v.x] === 0 || this.pathfinder[v.y][v.x] > a);
        }).forEach((v) => {
            blocks[v.y][v.x].n = a;
            this.pathfinder[v.y][v.x] = a;
            this.movePath(v, a + 1, m);
        });
    }

    update() {
        this.move();
        this.logic();
        this.draw();
    }
    draw() {
        noStroke();
        fill(this.mixedColor);
        quad(
            this.x + this.vx * 1.5, this.y,
            this.x + this.w + this.vx * 1.5, this.y,
            this.x + this.w, this.y + this.h,
            this.x, this.y + this.h
        );
    }
    move() {
        // Gravity keeps pulling me down down down
        this.vy += GRAVITY;
    
        // Animate color strength bar
        this.lastColorStrength += easeOut(this.colorStrength, this.lastColorStrength, 10);
        
        this.timeSinceColorChange++;
        let acc = 0.7, fri = 0.35, spd = Math.PI+Math.PI/2;
        if(this.inLiquid){
            
            // Handle movement
            if(keys[37] || keys[65]) {
                // Move left
                this.vx -= acc;
            }
            if(keys[39] || keys[68]) {
                // Move right
                this.vx += acc;
            }
            if(keys[38] || keys[87]) {
                // Move up
                this.vy -= acc;
                this.vy = max(this.vy, -4);
            }else{
                this.vy = max(this.vy, -1);
            }
            if(keys[40] || keys[83]) {
                // Move down
                this.vy += acc;
                this.vy = min(this.vy, 4);
            }else{
                this.vy = min(this.vy, 1);
            }
            this.vx = constrain(this.vx, -4, 4);
    
            // Gain strength
            this.colorStrength = min(this.colorStrength+0.5, 100);
            if(this.inLiquid.color !== this.color) {
                this.timeSinceColorChange = 0;
                this.lastColor = this.color;
                this.color = this.inLiquid.color;
            }
        }else{
    
            // Handle movement
            if(keys[37] || keys[65]) {
                // Move left
                this.vx = max(this.vx - acc, -spd);
            }
            if(keys[39] || keys[68]) {
                // Move right
                this.vx = min(this.vx + acc, spd);
            }
            if((keys[38] || keys[87]) && this.canJump) {
                // Jump
                this.canJump = false;
                this.vy = -Math.PI*3;
            }

        }

        if (keys[82]) this.dead = true;

        // Duh
        this.wasInLiquid = this.inLiquid;
        this.inLiquid = false;

        // Collide x
        this.x += this.vx;
        this.collide(this.vx, 0);
        
        // Collide y
        this.y += this.vy;
        this.collide(0, this.vy);
        
        // Friction
        this.vx = this.vx > 0 ? max(this.vx - fri, 0) : min(this.vx + fri, 0);
    }
    logic() {
        // Cache the lerped
        this.lerpedColor = lerpColor(
            this.lastColor,
            this.color,
            min(this.timeSinceColorChange/100, 1)
        );
        this.mixedColor = this.lastColorStrength > 0 ? lerpColor(
            color(100),
            this.lerpedColor,
            min((this.lastColorStrength/100), 1)
        ) : lerpColor(
            color(100),
            color(0),
            min(-(this.lastColorStrength/100), 1)
        );

        // Light up the world (or else)
        this.light.x = round(PADDING_X + this.x + this.w / 2);
        this.light.y = round(PADDING_Y + this.y + this.h / 2);
        this.light.color = color(this.colorStrength >= 0 ? lerpColor(this.mixedColor, color(-1, 1), this.hasColored / this.mustColor) : 0);
        this.light.strength = this.colorStrength >= 0 ? map(this.colorStrength, 100, 0, 255, 200) : map(this.colorStrength, 0, -100, 200, 150);
        this.light.castRays(blocks);

        // Calculate the pathfinding grid
        this.findPath();

        // Find the nearest darkened block
        if(frameCount % 100 === 0) {
            this.findNearDark();
        }
        
        // Jumping in
        if((!this.wasInLiquid && this.inLiquid)){
            if(this.vy > 0){
                for(let i = 0; i < abs(this.vy*3); i++){
                    pages.Page.particles.add(new Particle({
                        x: random(this.x, this.x+this.w),
                        y: this.y+this.h,
                        vx: random(-3, 3),
                        vy: -random(this.vy/2, this.vy/1.5),
                        w: blockW/10,
                        color: this.inLiquid.color,
                        health: round(this.vy*5),
                        image: "ellipse",
                        fade: true,
                        onUpdate: function(){
                            this.vy += GRAVITY;
                        }
                    }));
                }
            }
            sounds.splash2.play();
            sounds.underwater.play();
        }
    
        // Jumping out
        if((this.wasInLiquid && !this.inLiquid)){
            if(this.vy < 0){
                for(let i = 0; i < abs(this.vy*3); i++){
                    pages.Page.particles.add(new Particle({
                        x: random(this.x, this.x+this.w),
                        y: this.y,
                        vx: random(-3, 3),
                        vy: random(this.vy, this.vy*2),
                        w: blockW/10,
                        color: this.color,
                        health: round(-this.vy*13),
                        image: "ellipse",
                        fade: true,
                        onUpdate: function(){
                            this.vy += GRAVITY;
                        }
                    }));
                }
            }
            sounds.splash1.play();
            sounds.underwater.fadeOut(1);
        }
        
        // Die you fools!
        if (this.y > levelH - PADDING_Y) {
            sounds.wilhelm.play();
            this.colorStrength = max(this.colorStrength-(100/5), -100);
            this.reset();
        }
        if (this.colorStrength === -100) {
            this.dead = true;
        }
    }
}

// ]

/** Particle class **/
// [

/**
 * Particle System
 * 
 * An easy way to create tons of particles with
 * three simple methods.
 * 
 * @param {object} params - Contains the particle system's parameters.
 *     @param {array} particles - The list of particles in the system.
 **/
class ParticleSystem {
    constructor(params){
        
        this.particles = [];

        for(let param in params){
            this[param] = params[param];
        }
        
    }

    /**
     * Update all the particles in this system.
     **/
    update(){
        
        for(let i = this.particles.length-1; i >= 0; i--){
            let p = this.particles[i];
            p.update();
            if(p.dead){
                p.onDeath();
                this.particles.splice(i, 1);
            }
        }
        
    }
    
    /**
     * Adds a particle to the system.
     * 
     * @param {object} particle - An instance of Particle
     **/
    add(particle){
        
        this.particles.push(particle);
        
    }
    
    /**
     * Remove all particles in this system.
     **/
    reset(){
        
        Delete(this.particles);
        
    }
}

/**
 * Particle
 * 
 * A dynamic particle with lots of customization options
 * 
 * @param {object} params - Contains the particle's parameters.
 *     @param {number} x/y - Coordinates.
 *     @param {number} w/h - Dimentions.
 *     @param {number} rx/ry/rz - Rotation x, y and z respectively.
 *     @param {number} rvx/rvy/rvz - Rotation velocity x, y and z respectively.
 *     @param {number} vx/vx - Position velocity.
 *     @param {number} vw/vh - Dimention velocity.
 *     @param {number} toX/toY - Move to coordinates.
 *     @param {number} toRx/toRy/toRz - Rotation to move to. X, y and x respectively.
 *     @param {number} toW/toH - Move to dimentions.
 *     @param {number} toX/toY - Move to coordinates.
 *     @param {boolean} fade - Fade to 0% opacity as death nears.
 *     @param {string} image - Either "rect", "ellipse" or and instance of image.
 *     @param {number} health - Represents how many frames the particle has left to live. (-1 if it never dies)
 *     @param {number} pause - How many frames the particle should ignore moveTo commands. (0 if it shouldn't)
 *     @param {number} strokeWeight - The thickness of the particle's border.
 *     @param {color} color/stroke - The particle's color and border color respectively.
 *     @param {function} onArrive - Called when the particle reaches it's moveTo destination.
 *     @param {function} onUpdate - Called whenever the particle is updated.
 *     @param {function} onDeath - Called when the particle dies.
 * 
 **/
class Particle {
    
    constructor(params){
        
        // Positions
        this.x = width/2;
        this.y = height/2;
        this.w = 0;
        this.h = 0;
        this.rx = 0;
        this.ry = 0;
        this.rz = 0;
        
        // Velocities
        this.rvx = 0;
        this.rvy = 0;
        this.rvz = 0;
        this.vx = 0;
        this.vy = 0;
        this.vw = 0;
        this.vh = 0;
        
        // To positions
        this.toX = 0;
        this.toY = 0;
        this.toRx = 0;
        this.toRy = 0;
        this.toRz = 0;
        this.toSpeed = 10;
        this.toRSpeed = 0;
        this.toW = 0;
        this.toH = 0;
        
        // Misc settings
        this.fade = false;
        this.image = "rect";
        this.health = 100;
        this.dead = false;
        this.pause = 0;
        
        // Display
        this.strokeWeight = 0;
        this.color = color(0);
        this.stroke = color(0);
        
        // Events
        this.onArrive = function(){};
        this.onUpdate = function(){};
        this.onDeath = function(){};
    
        for(let param in params){
            this[param] = params[param];
        }
        
        // Background logic
        this.life = this.health;
        if(!this.h && this.image.width && this.image.height){
            this.h = map(this.w, 0, this.image.width, 0, this.image.height);
        }
        
    }
    
    /**
     * Update the size of the particle taking into acount the size of the image, if there is one
     * 
     * @param {number} w - The width of the particle
     * @param {number} h - The height of the particle
     **/
    setSize(w, h){
        
        this.w = w;
        this.h = h||w;
        if(!h && this.image.width && this.image.height){
            this.h = map(this.w, 0, this.image.width, 0, this.image.height);
        }
        
    }
    
    /**
     * Update the particle.
     **/
    update(){
        
        this.logic();
        this.display();
        
    }
    display(){
        fill(this.fade ? lerpColor(color(-1, 1), this.color, constrain(this.health / this.life, 0, 1)) : this.color);
        stroke(this.fade ? lerpColor(color(-1, 1), this.stroke, constrain(this.health / this.life, 0, 1)) : this.stroke);
        this.strokeWeight ? strokeWeight(this.strokeWeight):noStroke();
    
        pushMatrix();
            translate(this.x, this.y);
            rotate(this.rx);
            scale(cos(this.ry), cos(this.rz));
    
            let w = this.w, h = this.h||this.w;
            switch(this.image){
                case "rect":
                    rect(0, 0, w, h);
                    break;
                case "ellipse":
                    ellipse(0, 0, w, h);
                    break;
                default:
                    image(this.image, 0, 0, w, h);
                    break;
            }
        
        popMatrix();
    
    }
    logic(){
    
        this.onUpdate();
        if(this.pause){
            this.pause--;
        }else{
            if(round(this.x-this.toX) === 0 && round(this.y-this.toY) === 0){
                this.onArrive();
            }
            if(this.toX) this.x += easeOut(this.toX, this.x, this.toSpeed);
            if(this.toY) this.y += easeOut(this.toY, this.y, this.toSpeed);
            if(this.toW) this.w += easeOut(this.toW, this.w, this.toSpeed);
            if(this.toH) this.h += easeOut(this.toH, this.h, this.toSpeed);
            if(this.toRx) this.rx += easeOut(this.toRx % 360, this.rx, this.toRSpeed||this.toSpeed);
            if(this.toRy) this.ry += easeOut(this.toRy % 360, this.ry, this.toRSpeed||this.toSpeed);
            if(this.toRz) this.rz += easeOut(this.toRz % 360, this.rz, this.toRSpeed||this.toSpeed);
            if(!this.health) this.dead = true;
            this.health--;
        }
    
        this.x += this.vx;
        this.y += this.vy;
        this.w += this.vw;
        this.h += this.vh;
        this.rx += this.rvx;
        this.ry += this.rvy;
        this.rz += this.rvz;
    
    }
    
}

// ]

/** Extreme walker class **/
// [

/**
 * Extreme Walker
 * 
 * A cool spreading effect for the homescreen
 * 
 * @param {object} params - Contains the extreme walker's parameters.
 *     @param {number} amount - How many pixels are in the walker (both width & height)
 **/
class ExtremeWalker {

    constructor(params) {
        this.grid = [];
        this.color = randomColor();
        this.pending = [];
        this.finished = false;
        this.amount = 200;

        for (let param in params) {
            this[param] = params[param];
        }
        this.reset(this.amount);
    }

    /**
     * Add a pixel to the pending list to add in the future
     **/
    setPixel(x, y) {
        this.finished = false;
        if (y < this.grid.length && y >= 0 && x < this.grid[y].length && x >= 0 && this.grid[y][x] !== 1) {
            this.pending.push([y, x]);
        }
    }

    /**
     * Update all the pixels in the grid,
     * spreading each solid pixel randomly,
     * unless it's already spread in all four directions
     **/
    update() {

        // No need to continue
        if (this.finished) return;

        // Setup
        noStroke();
        fill(this.color);

        // Assume the grid is finished spreading
        this.finished = true;

        this.grid.forEach((v2, y, a) => {
            v2.forEach((v, x, a2) => {
                if (v === 1) {
                    
                    // Draw a rectangle at the current pixel's position
                    rect(round(x * (width / a2.length)), round(y * (height / a.length)), round(width / a2.length) + 1, round(height / a.length) + 1);
                    
                    // Choose a random direction to spread in
                    let r = floor(random(0, 5));
                    switch (r) {
                        case 1:
                            this.setPixel(x + 1, y, a, a2);
                            break;
                        case 2:
                            this.setPixel(x, y + 1, a, a2);
                            break;
                        case 3:
                            this.setPixel(x - 1, y, a, a2);
                            break;
                        case 4:
                            this.setPixel(x, y - 1, a, a2);
                            break;
                    }
                    
                    // Check if the current pixel has spread in all directions
                    if (
                        ((!this.grid[y + 1]) || this.grid[y + 1][x] !== 0) &&
                        ((!this.grid[y - 1]) || this.grid[y - 1][x] !== 0) &&
                        ((!this.grid[y][x + 1]) || this.grid[y][x + 1] !== 0) &&
                        ((!this.grid[y][x - 1]) || this.grid[y][x - 1] !== 0)
                    ) {
                        this.grid[y][x] = 2;
                    }
                    
                }
                
                // The grid is not finished spreading
                if (v === 0) {
                    this.finished = false;
                }
            });
        });
        
        // Add all pending pixels to the grid
        for (let j = this.pending.length - 1; j >= 0; j--) {
            this.grid[this.pending[j][0]][this.pending[j][1]] = 1;
            this.pending.splice(j, 1);
        }

    }

    /**
     * Reset the grid
     **/
    reset(amount) {
        this.grid = Array.from({ length: amount }, function() { return Array(amount).fill(0); });
    }

}

// ]

/** Cataclysmic intro class **/
// [

class CataclysmicIntro {

    constructor() {
        
        // [

        this.data = "1m7n1n7n1o7n1p7n1q7n1r7n1s7n1t7n1u7n1v7n1w7n9l7n9m7n9n7n9o7n9p7n9q7n9r7n9s7n9t7nbt7nbu7nbv7nbw7nbx7nby7nbz7nc07nc17nc27nc37n1j7o1k7o1l7o1m7o1n7o1o7o1p7o1q7o1r7o1s7o1t7o1u7o1v7o1w7o1x7o1y7o1z7o5r7o5s7o5t7o5u7o5v7o5w7o5x7o5y7o5z7o607o9k7o9l7o9m7o9n7o9o7o9p7o9q7o9r7o9s7o9t7obq7obr7obs7obt7obu7obv7obw7obx7oby7obz7oc07oc17oc27oc37oc47oc57oc67oe87oe97oea7oeb7oec7oed7oee7oef7oeg7oeh7o1h7p1i7p1j7p1k7p1l7p1m7p1n7p1o7p1p7p1q7p1r7p1s7p1t7p1u7p1v7p1w7p1x7p1y7p1z7p207p217p5r7p5s7p5t7p5u7p5v7p5w7p5x7p5y7p5z7p607p9k7p9l7p9m7p9n7p9o7p9p7p9q7p9r7p9s7p9t7pbo7pbp7pbq7pbr7pbs7pbt7pbu7pbv7pbw7pbx7pby7pbz7pc07pc17pc27pc37pc47pc57pc67pc77pc87pe87pe97pea7peb7pec7ped7pee7pef7peg7peh7p1f7q1g7q1h7q1i7q1j7q1k7q1l7q1m7q1n7q1o7q1p7q1q7q1r7q1s7q1t7q1u7q1v7q1w7q1x7q1y7q1z7q207q217q227q237q3f7q3g7q3h7q3i7q3j7q3k7q3l7q3m7q3n7q5r7q5s7q5t7q5u7q5v7q5w7q5x7q5y7q5z7q607q9k7q9l7q9m7q9n7q9o7q9p7q9q7q9r7q9s7q9t7qbm7qbn7qbo7qbp7qbq7qbr7qbs7qbt7qbu7qbv7qbw7qbx7qby7qbz7qc07qc17qc27qc37qc47qc57qc67qc77qc87qc97qca7qe87qe97qea7qeb7qec7qed7qee7qef7qeg7qeh7q1e7r1f7r1g7r1h7r1i7r1j7r1k7r1l7r1m7r1n7r1o7r1p7r1q7r1r7r1s7r1t7r1u7r1v7r1w7r1x7r1y7r1z7r207r217r227r237r247r3e7r3f7r3g7r3h7r3i7r3j7r3k7r3l7r3m7r3n7r5r7r5s7r5t7r5u7r5v7r5w7r5x7r5y7r5z7r607r9k7r9l7r9m7r9n7r9o7r9p7r9q7r9r7r9s7r9t7rbl7rbm7rbn7rbo7rbp7rbq7rbr7rbs7rbt7rbu7rbv7rbw7rbx7rby7rbz7rc07rc17rc27rc37rc47rc57rc67rc77rc87rc97rca7rcb7re87re97rea7reb7rec7red7ree7ref7reg7reh7r1d7s1e7s1f7s1g7s1h7s1i7s1j7s1k7s1l7s1m7s1n7s1o7s1p7s1q7s1r7s1s7s1t7s1u7s1v7s1w7s1x7s1y7s1z7s207s217s227s237s247s257s3e7s3f7s3g7s3h7s3i7s3j7s3k7s3l7s3m7s3n7s5r7s5s7s5t7s5u7s5v7s5w7s5x7s5y7s5z7s607s9k7s9l7s9m7s9n7s9o7s9p7s9q7s9r7s9s7s9t7sbk7sbl7sbm7sbn7sbo7sbp7sbq7sbr7sbs7sbt7sbu7sbv7sbw7sbx7sby7sbz7sc07sc17sc27sc37sc47sc57sc67sc77sc87sc97sca7scb7scc7se87se97sea7seb7sec7sed7see7sef7seg7seh7s1c7t1d7t1e7t1f7t1g7t1h7t1i7t1j7t1k7t1l7t1m7t1n7t1o7t1p7t1q7t1r7t1s7t1t7t1u7t1v7t1w7t1x7t1y7t1z7t207t217t227t237t247t257t267t3e7t3f7t3g7t3h7t3i7t3j7t3k7t3l7t3m7t3n7t5r7t5s7t5t7t5u7t5v7t5w7t5x7t5y7t5z7t607t9k7t9l7t9m7t9n7t9o7t9p7t9q7t9r7t9s7t9t7tbj7tbk7tbl7tbm7tbn7tbo7tbp7tbq7tbr7tbs7tbt7tbu7tbv7tbw7tbx7tby7tbz7tc07tc17tc27tc37tc47tc57tc67tc77tc87tc97tca7tcb7tcc7tcd7te87te97tea7teb7tec7ted7tee7tef7teg7teh7t1b7u1c7u1d7u1e7u1f7u1g7u1h7u1i7u1j7u1k7u1l7u1m7u1n7u1o7u1p7u1q7u1r7u1s7u1t7u1u7u1v7u1w7u1x7u1y7u1z7u207u217u227u237u247u257u267u277u3e7u3f7u3g7u3h7u3i7u3j7u3k7u3l7u3m7u3n7u5r7u5s7u5t7u5u7u5v7u5w7u5x7u5y7u5z7u607u9k7u9l7u9m7u9n7u9o7u9p7u9q7u9r7u9s7u9t7ubi7ubj7ubk7ubl7ubm7ubn7ubo7ubp7ubq7ubr7ubs7ubt7ubu7ubv7ubw7ubx7uby7ubz7uc07uc17uc27uc37uc47uc57uc67uc77uc87uc97uca7ucb7ucc7ucd7uce7ue87ue97uea7ueb7uec7ued7uee7uef7ueg7ueh7u1b7v1c7v1d7v1e7v1f7v1g7v1h7v1i7v1j7v1k7v1l7v1m7v1n7v1o7v1p7v1q7v1r7v1s7v1t7v1u7v1v7v1w7v1x7v1y7v1z7v207v217v227v237v247v257v267v277v287v3e7v3f7v3g7v3h7v3i7v3j7v3k7v3l7v3m7v3n7v5r7v5s7v5t7v5u7v5v7v5w7v5x7v5y7v5z7v607v9k7v9l7v9m7v9n7v9o7v9p7v9q7v9r7v9s7v9t7vbi7vbj7vbk7vbl7vbm7vbn7vbo7vbp7vbq7vbr7vbs7vbt7vbu7vbv7vbw7vbx7vby7vbz7vc07vc17vc27vc37vc47vc57vc67vc77vc87vc97vca7vcb7vcc7vcd7vce7vcf7ve87ve97vea7veb7vec7ved7vee7vef7veg7veh7v1a7w1b7w1c7w1d7w1e7w1f7w1g7w1h7w1i7w1j7w1k7w1l7w1m7w1n7w1o7w1t7w1u7w1v7w1w7w1x7w1y7w1z7w207w217w227w237w247w257w267w277w287w3e7w3f7w3g7w3h7w3i7w3j7w3k7w3l7w3m7w3n7w5r7w5s7w5t7w5u7w5v7w5w7w5x7w5y7w5z7w607w9k7w9l7w9m7w9n7w9o7w9p7w9q7w9r7w9s7w9t7wbh7wbi7wbj7wbk7wbl7wbm7wbn7wbo7wbp7wbq7wbr7wbs7wbt7wbu7wbv7wc07wc17wc27wc37wc47wc57wc67wc77wc87wc97wca7wcb7wcc7wcd7wce7wcf7we87we97wea7web7wec7wed7wee7wef7weg7weh7w1a7x1b7x1c7x1d7x1e7x1f7x1g7x1h7x1i7x1j7x1k7x1l7x1m7x1w7x1x7x1y7x1z7x207x217x227x237x247x257x267x277x287x297x3e7x3f7x3g7x3h7x3i7x3j7x3k7x3l7x3m7x3n7x5r7x5s7x5t7x5u7x5v7x5w7x5x7x5y7x5z7x607xbh7xbi7xbj7xbk7xbl7xbm7xbn7xbo7xbp7xbq7xbr7xbs7xbt7xc37xc47xc57xc67xc77xc87xc97xca7xcb7xcc7xcd7xce7xcf7xcg7xe87xe97xea7xeb7xec7xed7xee7xef7xeg7xeh7x197y1a7y1b7y1c7y1d7y1e7y1f7y1g7y1h7y1i7y1j7y1k7y1l7y1y7y1z7y207y217y227y237y247y257y267y277y287y297y2o7y2p7y2q7y2r7y2s7y2t7y2u7y3e7y3f7y3g7y3h7y3i7y3j7y3k7y3l7y3m7y3n7y467y477y487y497y4a7y4b7y4c7y557y567y577y587y597y5a7y5r7y5s7y5t7y5u7y5v7y5w7y5x7y5y7y5z7y607y7g7y7h7y7i7y7j7y7k7y7l7y7m7y8j7y8k7y8l7y8m7y917y927y937y947y957yac7yad7yae7yaf7yag7yah7ybg7ybh7ybi7ybj7ybk7ybl7ybm7ybn7ybo7ybp7ybq7ybr7ybs7yc57yc67yc77yc87yc97yca7ycb7ycc7ycd7yce7ycf7ycg7ycw7ycx7ycy7ycz7yd07yd17yd27yd37yd47yd57ydx7ydy7ydz7ye07ye17ye87ye97yea7yeb7yec7yed7yee7yef7yeg7yeh7yey7yez7yf07yf17yf27yf37yf47y197z1a7z1b7z1c7z1d7z1e7z1f7z1g7z1h7z1i7z1j7z1k7z1z7z207z217z227z237z247z257z267z277z287z297z2l7z2m7z2n7z2o7z2p7z2q7z2r7z2s7z2t7z2u7z2v7z2w7z2x7z2y7z2z7z3a7z3b7z3c7z3d7z3e7z3f7z3g7z3h7z3i7z3j7z3k7z3l7z3m7z3n7z3o7z3p7z3q7z3r7z3s7z437z447z457z467z477z487z497z4a7z4b7z4c7z4d7z4e7z4f7z4g7z4h7z517z527z537z547z557z567z577z587z597z5a7z5b7z5c7z5d7z5e7z5r7z5s7z5t7z5u7z5v7z5w7z5x7z5y7z5z7z607z657z667z677z687z697z6a7z6b7z6c7z6d7z6e7z6f7z6s7z6t7z6u7z6v7z6w7z6x7z6y7z6z7z707z717z7c7z7d7z7e7z7f7z7g7z7h7z7i7z7j7z7k7z7l7z7m7z7n7z7o7z7p7z7q7z837z847z857z867z877z887z897z8a7z8b7z8c7z8g7z8h7z8i7z8j7z8k7z8l7z8m7z8n7z8o7z8p7z8q7z8y7z8z7z907z917z927z937z947z957z967z977z987z9k7z9l7z9m7z9n7z9o7z9p7z9q7z9r7z9s7z9t7za87za97zaa7zab7zac7zad7zae7zaf7zag7zah7zai7zaj7zak7zal7zbg7zbh7zbi7zbj7zbk7zbl7zbm7zbn7zbo7zbp7zbq7zbr7zc67zc77zc87zc97zca7zcb7zcc7zcd7zce7zcf7zcg7zct7zcu7zcv7zcw7zcx7zcy7zcz7zd07zd17zd27zd37zd47zd57zd67zd77zd87zdt7zdu7zdv7zdw7zdx7zdy7zdz7ze07ze17ze27ze37ze47ze87ze97zea7zeb7zec7zed7zee7zef7zeg7zeh7zeu7zev7zew7zex7zey7zez7zf07zf17zf27zf37zf47zf57zf67zf77zf87z188019801a801b801c801d801e801f801g801h801i801j801z8020802180228023802480258026802780288029802j802k802l802m802n802o802p802q802r802s802t802u802v802w802x802y802z803080318032803a803b803c803d803e803f803g803h803i803j803k803l803m803n803o803p803q803r803s804180428043804480458046804780488049804a804b804c804d804e804f804g804h804i804j804k804z8050805180528053805480558056805780588059805a805b805c805d805e805f805g805h805r805s805t805u805v805w805x805y805z806080658066806780688069806a806b806c806d806e806f806r806s806t806u806v806w806x806y806z80708071807a807b807c807d807e807f807g807h807i807j807k807l807m807n807o807p807q807r807s807t8083808480858086808780888089808a808b808c808e808f808g808h808i808j808k808l808m808n808o808p808q808r808w808x808y808z8090809180928093809480958096809780988099809a809k809l809m809n809o809p809q809r809s809t80a680a780a880a980aa80ab80ac80ad80ae80af80ag80ah80ai80aj80ak80al80am80an80ao80bf80bg80bh80bi80bj80bk80bl80bm80bn80bo80bp80bq80c680c780c880c980ca80cb80cc80cd80ce80cf80cg80cr80cs80ct80cu80cv80cw80cx80cy80cz80d080d180d280d380d480d580d680d780d880d980da80ds80dt80du80dv80dw80dx80dy80dz80e080e180e280e380e480e580e680e880e980ea80eb80ec80ed80ee80ef80eg80eh80et80eu80ev80ew80ex80ey80ez80f080f180f280f380f480f580f680f780f880f980fa80188119811a811b811c811d811e811f811g811h811i811j8120812181228123812481258126812781288129812a812h812i812j812k812l812m812n812o812p812q812r812s812t812u812v812w812x812y812z8130813181328133813a813b813c813d813e813f813g813h813i813j813k813l813m813n813o813p813q813r813s813z8140814181428143814481458146814781488149814a814b814c814d814e814f814g814h814i814j814k814l814y814z8150815181528153815481558156815781588159815a815b815c815d815e815f815g815h815i815r815s815t815u815v815w815x815y815z816081658166816781688169816a816b816c816d816e816f816r816s816t816u816v816w816x816y816z817081718179817a817b817c817d817e817f817g817h817i817j817k817l817m817n817o817p817q817r817s817t817u8183818481858186818781888189818a818b818c818d818e818f818g818h818i818j818k818l818m818n818o818p818q818r818s818v818w818x818y818z8190819181928193819481958196819781988199819a819b819k819l819m819n819o819p819q819r819s819t81a581a681a781a881a981aa81ab81ac81ad81ae81af81ag81ah81ai81aj81ak81al81am81an81ao81ap81bf81bg81bh81bi81bj81bk81bl81bm81bn81bo81bp81bq81c781c881c981ca81cb81cc81cd81ce81cf81cg81ch81cq81cr81cs81ct81cu81cv81cw81cx81cy81cz81d081d181d281d381d481d581d681d781d881d981da81db81dc81dq81dr81ds81dt81du81dv81dw81dx81dy81dz81e081e181e281e381e481e581e681e781e881e981ea81eb81ec81ed81ee81ef81eg81eh81er81es81et81eu81ev81ew81ex81ey81ez81f081f181f281f381f481f581f681f781f881f981fa81fb81188219821a821b821c821d821e821f821g821h821i8220822182228223822482258226822782288229822a822g822h822i822j822k822l822m822n822o822p822q822r822s822t822u822v822w822x822y822z82308231823282338234823a823b823c823d823e823f823g823h823i823j823k823l823m823n823o823p823q823r823s823y823z8240824182428243824482458246824782488249824a824b824c824d824e824f824g824h824i824j824k824l824m824x824y824z8250825182528253825482558256825782588259825a825b825c825d825e825f825g825h825i825j825r825s825t825u825v825w825x825y825z82608266826782688269826a826b826c826d826e826f826g826r826s826t826u826v826w826x826y826z827082788279827a827b827c827d827e827f827g827h827i827j827k827l827m827n827o827p827q827r827s827t827u827v8283828482858286828782888289828a828b828c828d828e828f828g828h828i828j828k828l828m828n828o828p828q828r828s828t828u828v828w828x828y828z8290829182928293829482958296829782988299829a829b829k829l829m829n829o829p829q829r829s829t82a482a582a682a782a882a982aa82ab82ac82ad82ae82af82ag82ah82ai82aj82ak82al82am82an82ao82ap82aq82bf82bg82bh82bi82bj82bk82bl82bm82bn82bo82bp82c782c882c982ca82cb82cc82cd82ce82cf82cg82ch82cp82cq82cr82cs82ct82cu82cv82cw82cx82cy82cz82d082d182d282d382d482d582d682d782d882d982da82db82dc82dd82dp82dq82dr82ds82dt82du82dv82dw82dx82dy82dz82e082e182e282e382e482e582e682e782e882e982ea82eb82ec82ed82ee82ef82eg82eh82eq82er82es82et82eu82ev82ew82ex82ey82ez82f082f182f282f382f482f582f682f782f882f982fa82fb82fc82188319831a831b831c831d831e831f831g831h831i8320832183228323832483258326832783288329832a832g832h832i832j832k832l832m832n832o832p832q832r832s832t832u832v832w832x832y832z833083318332833383348335833a833b833c833d833e833f833g833h833i833j833k833l833m833n833o833p833q833r833s833y833z8340834183428343834483458346834783488349834a834b834c834d834e834f834g834h834i834j834k834l834m834n834w834x834y834z8350835183528353835483558356835783588359835a835b835c835d835e835f835g835h835i835j835k835r835s835t835u835v835w835x835y835z83608366836783688369836a836b836c836d836e836f836g836r836s836t836u836v836w836x836y836z8370837783788379837a837b837c837d837e837f837g837h837i837j837k837l837m837n837o837p837q837r837s837t837u837v8383838483858386838783888389838a838b838c838d838e838f838g838h838i838j838k838l838m838n838o838p838q838r838s838t838u838v838w838x838y838z8390839183928393839483958396839783988399839a839b839c839k839l839m839n839o839p839q839r839s839t83a383a483a583a683a783a883a983aa83ab83ac83ad83ae83af83ag83ah83ai83aj83ak83al83am83an83ao83ap83aq83ar83bf83bg83bh83bi83bj83bk83bl83bm83bn83bo83bp83c783c883c983ca83cb83cc83cd83ce83cf83cg83ch83co83cp83cq83cr83cs83ct83cu83cv83cw83cx83cy83cz83d083d183d283d383d483d583d683d783d883d983da83db83dc83dd83dp83dq83dr83ds83dt83du83dv83dw83dx83dy83dz83e083e183e283e383e483e583e683e783e883e983ea83eb83ec83ed83ee83ef83eg83eh83ep83eq83er83es83et83eu83ev83ew83ex83ey83ez83f083f183f283f383f483f583f683f783f883f983fa83fb83fc83fd831784188419841a841b841c841d841e841f841g841h842f842g842h842i842j842k842l842m842n842o842p842q842r842s842t842u842v842w842x842y842z843084318432843384348435843a843b843c843d843e843f843g843h843i843j843k843l843m843n843o843p843q843r843s843x843y843z8440844184428443844484458446844784488449844a844b844c844d844e844f844g844h844i844j844k844l844m844n844v844w844x844y844z8450845184528453845484558456845784588459845a845b845c845d845e845f845g845h845i845j845k845l845r845s845t845u845v845w845x845y845z84608466846784688469846a846b846c846d846e846f846g846q846r846s846t846u846v846w846x846y846z84708476847784788479847a847b847c847d847e847f847g847h847i847j847k847l847m847n847o847p847q847r847s847t847u847v847w8483848484858486848784888489848a848b848c848d848e848f848g848h848i848j848k848l848m848n848o848p848q848r848s848t848u848v848w848x848y848z8490849184928493849484958496849784988499849a849b849c849k849l849m849n849o849p849q849r849s849t84a284a384a484a584a684a784a884a984aa84ab84ac84ad84ae84af84ag84ah84ai84aj84ak84al84am84an84ao84ap84aq84ar84as84be84bf84bg84bh84bi84bj84bk84bl84bm84bn84bo84cn84co84cp84cq84cr84cs84ct84cu84cv84cw84cx84cy84cz84d084d184d284d384d484d584d684d784d884d984da84db84dc84dd84de84do84dp84dq84dr84ds84dt84du84dv84dw84dx84dy84dz84e084e184e284e384e484e584e684e784e884e984ea84eb84ec84ed84ee84ef84eg84eh84eo84ep84eq84er84es84et84eu84ev84ew84ex84ey84ez84f084f184f284f384f484f584f684f784f884f984fa84fb84fc84fd84fe841785188519851a851b851c851d851e851f851g851h852f852g852h852i852j852k852l852m852n852o852p852q852r852s852t852u852v852w852x852y852z853085318532853385348535853a853b853c853d853e853f853g853h853i853j853k853l853m853n853o853p853q853r853s853x853y853z8540854185428543854485458546854785488549854a854b854c854d854e854f854g854h854i854j854k854l854m854n854v854w854x854y854z8550855185528553855485558556855785588559855a855b855c855d855e855f855g855h855i855j855k855l855r855s855t855u855v855w855x855y855z8560856785688569856a856b856c856d856e856f856g856h856q856r856s856t856u856v856w856x856y856z8576857785788579857a857b857c857d857e857f857g857h857i857j857k857l857m857n857o857p857q857r857s857t857u857v857w8583858485858586858785888589858a858b858c858d858e858f858g858h858i858j858k858l858m858n858o858p858q858r858s858t858u858v858w858x858y858z8590859185928593859485958596859785988599859a859b859c859d859k859l859m859n859o859p859q859r859s859t85a285a385a485a585a685a785a885a985aa85ab85ac85ad85ae85af85ag85ah85ai85aj85ak85al85am85an85ao85ap85aq85ar85as85be85bf85bg85bh85bi85bj85bk85bl85bm85bn85bo85cn85co85cp85cq85cr85cs85ct85cu85cv85cw85cx85cy85cz85d085d185d285d385d485d585d685d785d885d985da85db85dc85dd85de85df85dn85do85dp85dq85dr85ds85dt85du85dv85dw85dx85dy85dz85e085e185e285e385e485e585e685e785e885e985ea85eb85ec85ed85ee85ef85eg85eh85eo85ep85eq85er85es85et85eu85ev85ew85ex85ey85ez85f085f185f285f385f485f585f685f785f885f985fa85fb85fc85fd85fe851786188619861a861b861c861d861e861f861g861h862f862g862h862i862j862k862l862m862n862o862p862q862r862s862t862u862v862w862x862y862z863086318632863386348635863a863b863c863d863e863f863g863h863i863j863k863l863m863n863o863p863q863r863s863x863y863z8640864186428643864486458646864786488649864a864b864c864d864e864f864g864h864i864j864k864l864m864n864u864v864w864x864y864z8650865186528653865486558656865786588659865a865b865c865d865e865f865g865h865i865j865k865l865r865s865t865u865v865w865x865y865z8660866786688669866a866b866c866d866e866f866g866h866q866r866s866t866u866v866w866x866y866z8676867786788679867a867b867c867d867e867f867g867m867n867o867p867q867r867s867t867u867v867w867x8683868486858686868786888689868a868b868c868d868e868f868g868h868i868j868k868l868m868n868o868p868q868r868s868t868u868v868w868x868y868z8690869186928693869486958696869786988699869a869b869c869d869k869l869m869n869o869p869q869r869s869t86a186a286a386a486a586a686a786a886a986aa86ab86ac86ad86ae86af86ag86ah86ai86aj86ak86al86am86an86ao86ap86aq86ar86as86be86bf86bg86bh86bi86bj86bk86bl86bm86bn86bo86cm86cn86co86cp86cq86cr86cs86ct86cu86cv86cw86cx86cy86cz86d086d186d286d386d486d586d686d786d886d986da86db86dc86dd86de86df86dn86do86dp86dq86dr86ds86dt86du86dv86dw86dx86dy86dz86e086e186e286e386e486e586e686e786e886e986ea86eb86ec86ed86ee86ef86eg86eh86en86eo86ep86eq86er86es86et86eu86ev86ew86ex86ey86ez86f086f186f286f386f486f586f686f786f886f986fa86fb86fc86fd86fe86ff861787188719871a871b871c871d871e871f871g871h872e872f872g872h872i872j872k872l872m872n872o872w872x872y872z8730873187328733873487358736873e873f873g873h873i873j873k873l873m873n873w873x873y873z8740874187428743874487458746874e874f874g874h874i874j874k874l874m874n874o874u874v874w874x874y874z875087518752875387548755875b875c875d875e875f875g875h875i875j875k875l875m875r875s875t875u875v875w875x875y875z8760876787688769876a876b876c876d876e876f876g876h876p876q876r876s876t876u876v876w876x876y876z87758776877787788779877a877b877c877d877e877n877o877p877q877r877s877t877u877v877w877x8783878487858786878787888789878a878b878c878d878e878f878j878k878l878m878n878o878p878q878r878s878t878u878v878w878x87928793879487958796879787988799879a879b879c879d879k879l879m879n879o879p879q879r879s879t87a187a287a387a487a587a687a787a887a987aa87ab87ac87ai87aj87ak87al87am87an87ao87ap87aq87ar87as87at87be87bf87bg87bh87bi87bj87bk87bl87bm87bn87bo87cm87cn87co87cp87cq87cr87cs87ct87cu87cv87cw87cx87d487d587d687d787d887d987da87db87dc87dd87de87df87dg87dm87dn87do87dp87dq87dr87ds87dt87du87dv87dw87dx87dy87dz87e387e487e587e687e787e887e987ea87eb87ec87ed87ee87ef87eg87eh87en87eo87ep87eq87er87es87et87eu87ev87ew87ex87ey87f487f587f687f787f887f987fa87fb87fc87fd87fe87ff871788188819881a881b881c881d881e881f881g881h882e882f882g882h882i882j882k882l882m882n882x882y882z8830883188328833883488358836883e883f883g883h883i883j883k883l883m883n883w883x883y883z884088418842884388448845884f884g884h884i884j884k884l884m884n884o884t884u884v884w884x884y884z88508851885288538854885c885d885e885f885g885h885i885j885k885l885m885r885s885t885u885v885w885x885y885z886088688869886a886b886c886d886e886f886g886h886p886q886r886s886t886u886v886w886x886y88758876887788788879887a887b887c887d887e887o887p887q887r887s887t887u887v887w887x8883888488858886888788888889888a888b888c888d888k888l888m888n888o888p888q888r888s888t888u888v888w8893889488958896889788988899889a889b889c889d889k889l889m889n889o889p889q889r889s889t88a088a188a288a388a488a588a688a788a888a988aa88ab88aj88ak88al88am88an88ao88ap88aq88ar88as88at88be88bf88bg88bh88bi88bj88bk88bl88bm88bn88bo88cl88cm88cn88co88cp88cq88cr88cs88ct88cu88cv88cw88d588d688d788d888d988da88db88dc88dd88de88df88dg88dm88dn88do88dp88dq88dr88ds88dt88du88dv88dw88dx88e588e688e788e888e988ea88eb88ec88ed88ee88ef88eg88eh88en88eo88ep88eq88er88es88et88eu88ev88ew88ex88f588f688f788f888f988fa88fb88fc88fd88fe88ff881789188919891a891b891c891d891e891f891g891h892e892f892g892h892i892j892k892l892m892n892w892x892y892z8930893189328933893489358936893e893f893g893h893i893j893k893l893m893n893w893x893y893z894089418942894389448945894e894f894g894h894i894j894k894l894m894n894o894t894u894v894w894x894y894z8950895189528953895c895d895e895f895g895h895i895j895k895l895m895r895s895t895u895v895w895x895y895z896089688969896a896b896c896d896e896f896g896h896i896p896q896r896s896t896u896v896w896x896y89758976897789788979897a897b897c897d897e897f897o897p897q897r897s897t897u897v897w897x8983898489858986898789888989898a898b898c898d898l898m898n898o898p898q898r898s898t898u898v899489958996899789988999899a899b899c899d899k899l899m899n899o899p899q899r899s899t89a089a189a289a389a489a589a689a789a889a989aa89aj89ak89al89am89an89ao89ap89aq89ar89as89at89be89bf89bg89bh89bi89bj89bk89bl89bm89bn89bo89cl89cm89cn89co89cp89cq89cr89cs89ct89cu89cv89d689d789d889d989da89db89dc89dd89de89df89dg89dm89dn89do89dp89dq89dr89ds89dt89du89dv89dw89e689e789e889e989ea89eb89ec89ed89ee89ef89eg89eh89em89en89eo89ep89eq89er89es89et89eu89ev89ew89f689f789f889f989fa89fb89fc89fd89fe89ff89fg89178a188a198a1a8a1b8a1c8a1d8a1e8a1f8a1g8a1h8a2e8a2f8a2g8a2h8a2i8a2j8a2k8a2l8a2m8a2n8a2w8a2x8a2y8a2z8a308a318a328a338a348a358a368a3e8a3f8a3g8a3h8a3i8a3j8a3k8a3l8a3m8a3n8a3w8a3x8a3y8a3z8a408a418a428a438a448a458a4e8a4f8a4g8a4h8a4i8a4j8a4k8a4l8a4m8a4n8a4o8a4t8a4u8a4v8a4w8a4x8a4y8a4z8a508a518a528a538a5d8a5e8a5f8a5g8a5h8a5i8a5j8a5k8a5l8a5m8a5r8a5s8a5t8a5u8a5v8a5w8a5x8a5y8a5z8a608a688a698a6a8a6b8a6c8a6d8a6e8a6f8a6g8a6h8a6i8a6p8a6q8a6r8a6s8a6t8a6u8a6v8a6w8a6x8a6y8a758a768a778a788a798a7a8a7b8a7c8a7d8a7e8a7f8a7g8a7h8a7i8a838a848a858a868a878a888a898a8a8a8b8a8c8a8l8a8m8a8n8a8o8a8p8a8q8a8r8a8s8a8t8a8u8a8v8a948a958a968a978a988a998a9a8a9b8a9c8a9d8a9k8a9l8a9m8a9n8a9o8a9p8a9q8a9r8a9s8a9t8aa08aa18aa28aa38aa48aa58aa68aa78aa88aa98aaa8aak8aal8aam8aan8aao8aap8aaq8aar8aas8aat8abe8abf8abg8abh8abi8abj8abk8abl8abm8abn8abo8acl8acm8acn8aco8acp8acq8acr8acs8act8acu8acv8ad78ad88ad98ada8adb8adc8add8ade8adf8adg8adh8adm8adn8ado8adp8adq8adr8ads8adt8adu8adv8adw8ae78ae88ae98aea8aeb8aec8aed8aee8aef8aeg8aeh8aem8aen8aeo8aep8aeq8aer8aes8aet8aeu8aev8af78af88af98afa8afb8afc8afd8afe8aff8afg8a178b188b198b1a8b1b8b1c8b1d8b1e8b1f8b1g8b1h8b2s8b2t8b2u8b2v8b2w8b2x8b2y8b2z8b308b318b328b338b348b358b368b3e8b3f8b3g8b3h8b3i8b3j8b3k8b3l8b3m8b3n8b4a8b4b8b4c8b4d8b4e8b4f8b4g8b4h8b4i8b4j8b4k8b4l8b4m8b4n8b4o8b4t8b4u8b4v8b4w8b4x8b4y8b4z8b508b518b528b5d8b5e8b5f8b5g8b5h8b5i8b5j8b5k8b5l8b5m8b5r8b5s8b5t8b5u8b5v8b5w8b5x8b5y8b5z8b608b698b6a8b6b8b6c8b6d8b6e8b6f8b6g8b6h8b6i8b6o8b6p8b6q8b6r8b6s8b6t8b6u8b6v8b6w8b6x8b758b768b778b788b798b7a8b7b8b7c8b7d8b7e8b7f8b7g8b7h8b7i8b7j8b7k8b7l8b7m8b7n8b838b848b858b868b878b888b898b8a8b8b8b8c8b8m8b8n8b8o8b8p8b8q8b8r8b8s8b8t8b8u8b8v8b948b958b968b978b988b998b9a8b9b8b9c8b9d8b9k8b9l8b9m8b9n8b9o8b9p8b9q8b9r8b9s8b9t8ba08ba18ba28ba38ba48ba58ba68ba78ba88ba98bak8bal8bam8ban8bao8bap8baq8bar8bas8bat8bbe8bbf8bbg8bbh8bbi8bbj8bbk8bbl8bbm8bbn8bbo8bcl8bcm8bcn8bco8bcp8bcq8bcr8bcs8bct8bcu8bd78bd88bd98bda8bdb8bdc8bdd8bde8bdf8bdg8bdh8bdl8bdm8bdn8bdo8bdp8bdq8bdr8bds8bdt8bdu8bdv8be78be88be98bea8beb8bec8bed8bee8bef8beg8beh8bem8ben8beo8bep8beq8ber8bes8bet8beu8bev8bf78bf88bf98bfa8bfb8bfc8bfd8bfe8bff8bfg8b178c188c198c1a8c1b8c1c8c1d8c1e8c1f8c1g8c1h8c2m8c2n8c2o8c2p8c2q8c2r8c2s8c2t8c2u8c2v8c2w8c2x8c2y8c2z8c308c318c328c338c348c358c368c3e8c3f8c3g8c3h8c3i8c3j8c3k8c3l8c3m8c3n8c448c458c468c478c488c498c4a8c4b8c4c8c4d8c4e8c4f8c4g8c4h8c4i8c4j8c4k8c4l8c4m8c4n8c4o8c4t8c4u8c4v8c4w8c4x8c4y8c4z8c508c518c528c5r8c5s8c5t8c5u8c5v8c5w8c5x8c5y8c5z8c608c698c6a8c6b8c6c8c6d8c6e8c6f8c6g8c6h8c6i8c6j8c6o8c6p8c6q8c6r8c6s8c6t8c6u8c6v8c6w8c6x8c768c778c788c798c7a8c7b8c7c8c7d8c7e8c7f8c7g8c7h8c7i8c7j8c7k8c7l8c7m8c7n8c7o8c7p8c7q8c838c848c858c868c878c888c898c8a8c8b8c8c8c8m8c8n8c8o8c8p8c8q8c8r8c8s8c8t8c8u8c8v8c948c958c968c978c988c998c9a8c9b8c9c8c9d8c9k8c9l8c9m8c9n8c9o8c9p8c9q8c9r8c9s8c9t8ca08ca18ca28ca38ca48ca58ca68ca78ca88ca98cbe8cbf8cbg8cbh8cbi8cbj8cbk8cbl8cbm8cbn8cbo8cck8ccl8ccm8ccn8cco8ccp8ccq8ccr8ccs8cct8ccu8cd88cd98cda8cdb8cdc8cdd8cde8cdf8cdg8cdh8cdl8cdm8cdn8cdo8cdp8cdq8cdr8cds8cdt8cdu8cdv8ce78ce88ce98cea8ceb8cec8ced8cee8cef8ceg8ceh8cem8cen8ceo8cep8ceq8cer8ces8cet8ceu8cev8cew8cex8cey8cez8cf08cf18cf28cf38cf48cf58cf68cf78cf88cf98cfa8cfb8cfc8cfd8cfe8cff8cfg8c178d188d198d1a8d1b8d1c8d1d8d1e8d1f8d1g8d1h8d2j8d2k8d2l8d2m8d2n8d2o8d2p8d2q8d2r8d2s8d2t8d2u8d2v8d2w8d2x8d2y8d2z8d308d318d328d338d348d358d368d3e8d3f8d3g8d3h8d3i8d3j8d3k8d3l8d3m8d3n8d418d428d438d448d458d468d478d488d498d4a8d4b8d4c8d4d8d4e8d4f8d4g8d4h8d4i8d4j8d4k8d4l8d4m8d4n8d4o8d4s8d4t8d4u8d4v8d4w8d4x8d4y8d4z8d508d518d528d5r8d5s8d5t8d5u8d5v8d5w8d5x8d5y8d5z8d608d698d6a8d6b8d6c8d6d8d6e8d6f8d6g8d6h8d6i8d6j8d6o8d6p8d6q8d6r8d6s8d6t8d6u8d6v8d6w8d6x8d768d778d788d798d7a8d7b8d7c8d7d8d7e8d7f8d7g8d7h8d7i8d7j8d7k8d7l8d7m8d7n8d7o8d7p8d7q8d7r8d7s8d7t8d838d848d858d868d878d888d898d8a8d8b8d8c8d8m8d8n8d8o8d8p8d8q8d8r8d8s8d8t8d8u8d8v8d948d958d968d978d988d998d9a8d9b8d9c8d9d8d9k8d9l8d9m8d9n8d9o8d9p8d9q8d9r8d9s8d9t8d9z8da08da18da28da38da48da58da68da78da88da98dbe8dbf8dbg8dbh8dbi8dbj8dbk8dbl8dbm8dbn8dbo8dck8dcl8dcm8dcn8dco8dcp8dcq8dcr8dcs8dct8dcu8dd88dd98dda8ddb8ddc8ddd8dde8ddf8ddg8ddh8ddl8ddm8ddn8ddo8ddp8ddq8ddr8dds8ddt8ddu8ddv8de88de98dea8deb8dec8ded8dee8def8deg8deh8dem8den8deo8dep8deq8der8des8det8deu8dev8dew8dex8dey8dez8df08df18df28df38df48df58df68df78df88df98dfa8dfb8dfc8dfd8dfe8dff8dfg8d178e188e198e1a8e1b8e1c8e1d8e1e8e1f8e1g8e1h8e2h8e2i8e2j8e2k8e2l8e2m8e2n8e2o8e2p8e2q8e2r8e2s8e2t8e2u8e2v8e2w8e2x8e2y8e2z8e308e318e328e338e348e358e368e3e8e3f8e3g8e3h8e3i8e3j8e3k8e3l8e3m8e3n8e3z8e408e418e428e438e448e458e468e478e488e498e4a8e4b8e4c8e4d8e4e8e4f8e4g8e4h8e4i8e4j8e4k8e4l8e4m8e4n8e4o8e4s8e4t8e4u8e4v8e4w8e4x8e4y8e4z8e508e518e528e5r8e5s8e5t8e5u8e5v8e5w8e5x8e5y8e5z8e608e6a8e6b8e6c8e6d8e6e8e6f8e6g8e6h8e6i8e6j8e6n8e6o8e6p8e6q8e6r8e6s8e6t8e6u8e6v8e6w8e768e778e788e798e7a8e7b8e7c8e7d8e7e8e7f8e7g8e7h8e7i8e7j8e7k8e7l8e7m8e7n8e7o8e7p8e7q8e7r8e7s8e7t8e7u8e838e848e858e868e878e888e898e8a8e8b8e8c8e8m8e8n8e8o8e8p8e8q8e8r8e8s8e8t8e8u8e8v8e948e958e968e978e988e998e9a8e9b8e9c8e9d8e9k8e9l8e9m8e9n8e9o8e9p8e9q8e9r8e9s8e9t8e9z8ea08ea18ea28ea38ea48ea58ea68ea78ea88ea98ebe8ebf8ebg8ebh8ebi8ebj8ebk8ebl8ebm8ebn8ebo8eck8ecl8ecm8ecn8eco8ecp8ecq8ecr8ecs8ect8ecu8ed88ed98eda8edb8edc8edd8ede8edf8edg8edh8edl8edm8edn8edo8edp8edq8edr8eds8edt8edu8ee88ee98eea8eeb8eec8eed8eee8eef8eeg8eeh8eem8een8eeo8eep8eeq8eer8ees8eet8eeu8eev8eew8eex8eey8eez8ef08ef18ef28ef38ef48ef58ef68ef78ef88ef98efa8efb8efc8efd8efe8eff8efg8e178f188f198f1a8f1b8f1c8f1d8f1e8f1f8f1g8f1h8f2g8f2h8f2i8f2j8f2k8f2l8f2m8f2n8f2o8f2p8f2q8f2r8f2s8f2t8f2u8f2v8f2w8f2x8f2y8f2z8f308f318f328f338f348f358f368f3e8f3f8f3g8f3h8f3i8f3j8f3k8f3l8f3m8f3n8f3y8f3z8f408f418f428f438f448f458f468f478f488f498f4a8f4b8f4c8f4d8f4e8f4f8f4g8f4h8f4i8f4j8f4k8f4l8f4m8f4n8f4o8f4s8f4t8f4u8f4v8f4w8f4x8f4y8f4z8f508f518f528f5r8f5s8f5t8f5u8f5v8f5w8f5x8f5y8f5z8f608f6a8f6b8f6c8f6d8f6e8f6f8f6g8f6h8f6i8f6j8f6n8f6o8f6p8f6q8f6r8f6s8f6t8f6u8f6v8f6w8f778f788f798f7a8f7b8f7c8f7d8f7e8f7f8f7g8f7h8f7i8f7j8f7k8f7l8f7m8f7n8f7o8f7p8f7q8f7r8f7s8f7t8f7u8f7v8f838f848f858f868f878f888f898f8a8f8b8f8c8f8m8f8n8f8o8f8p8f8q8f8r8f8s8f8t8f8u8f8v8f948f958f968f978f988f998f9a8f9b8f9c8f9d8f9k8f9l8f9m8f9n8f9o8f9p8f9q8f9r8f9s8f9t8f9z8fa08fa18fa28fa38fa48fa58fa68fa78fa88fa98fbe8fbf8fbg8fbh8fbi8fbj8fbk8fbl8fbm8fbn8fbo8fck8fcl8fcm8fcn8fco8fcp8fcq8fcr8fcs8fct8fd88fd98fda8fdb8fdc8fdd8fde8fdf8fdg8fdh8fdl8fdm8fdn8fdo8fdp8fdq8fdr8fds8fdt8fdu8fe88fe98fea8feb8fec8fed8fee8fef8feg8feh8fem8fen8feo8fep8feq8fer8fes8fet8feu8fev8few8fex8fey8fez8ff08ff18ff28ff38ff48ff58ff68ff78ff88ff98ffa8ffb8ffc8ffd8ffe8fff8ffg8f178g188g198g1a8g1b8g1c8g1d8g1e8g1f8g1g8g1h8g208g218g228g238g248g258g268g278g288g298g2a8g2f8g2g8g2h8g2i8g2j8g2k8g2l8g2m8g2n8g2o8g2p8g2q8g2r8g2s8g2t8g2u8g2v8g2w8g2x8g2y8g2z8g308g318g328g338g348g358g368g3e8g3f8g3g8g3h8g3i8g3j8g3k8g3l8g3m8g3n8g3x8g3y8g3z8g408g418g428g438g448g458g468g478g488g498g4a8g4b8g4c8g4d8g4e8g4f8g4g8g4h8g4i8g4j8g4k8g4l8g4m8g4n8g4o8g4s8g4t8g4u8g4v8g4w8g4x8g4y8g4z8g508g518g528g5r8g5s8g5t8g5u8g5v8g5w8g5x8g5y8g5z8g608g6b8g6c8g6d8g6e8g6f8g6g8g6h8g6i8g6j8g6k8g6n8g6o8g6p8g6q8g6r8g6s8g6t8g6u8g6v8g788g798g7a8g7b8g7c8g7d8g7e8g7f8g7g8g7h8g7i8g7j8g7k8g7l8g7m8g7n8g7o8g7p8g7q8g7r8g7s8g7t8g7u8g7v8g7w8g838g848g858g868g878g888g898g8a8g8b8g8c8g8m8g8n8g8o8g8p8g8q8g8r8g8s8g8t8g8u8g8v8g948g958g968g978g988g998g9a8g9b8g9c8g9d8g9k8g9l8g9m8g9n8g9o8g9p8g9q8g9r8g9s8g9t8g9z8ga08ga18ga28ga38ga48ga58ga68ga78ga88ga98gbe8gbf8gbg8gbh8gbi8gbj8gbk8gbl8gbm8gbn8gbo8gc78gc88gc98gca8gcb8gcc8gcd8gce8gcf8gcg8gch8gck8gcl8gcm8gcn8gco8gcp8gcq8gcr8gcs8gct8gcu8gd88gd98gda8gdb8gdc8gdd8gde8gdf8gdg8gdh8gdl8gdm8gdn8gdo8gdp8gdq8gdr8gds8gdt8gdu8ge88ge98gea8geb8gec8ged8gee8gef8geg8geh8gem8gen8geo8gep8geq8ger8ges8get8geu8gev8gew8gex8gey8gez8gf08gf18gf28gf38gf48gf58gf68gf78gf88gf98gfa8gfb8gfc8gfd8gfe8gff8gfg8g188h198h1a8h1b8h1c8h1d8h1e8h1f8h1g8h1h8h1i8h208h218h228h238h248h258h268h278h288h298h2a8h2e8h2f8h2g8h2h8h2i8h2j8h2k8h2l8h2m8h2n8h2o8h2p8h2q8h2r8h2s8h2t8h2u8h2v8h2w8h2x8h2y8h2z8h308h318h328h338h348h358h368h3e8h3f8h3g8h3h8h3i8h3j8h3k8h3l8h3m8h3n8h3w8h3x8h3y8h3z8h408h418h428h438h448h458h468h478h488h498h4a8h4b8h4c8h4d8h4e8h4f8h4g8h4h8h4i8h4j8h4k8h4l8h4m8h4n8h4o8h4s8h4t8h4u8h4v8h4w8h4x8h4y8h4z8h508h518h528h5r8h5s8h5t8h5u8h5v8h5w8h5x8h5y8h5z8h608h6b8h6c8h6d8h6e8h6f8h6g8h6h8h6i8h6j8h6k8h6n8h6o8h6p8h6q8h6r8h6s8h6t8h6u8h6v8h7a8h7b8h7c8h7d8h7e8h7f8h7g8h7h8h7i8h7j8h7k8h7l8h7m8h7n8h7o8h7p8h7q8h7r8h7s8h7t8h7u8h7v8h7w8h7x8h838h848h858h868h878h888h898h8a8h8b8h8c8h8m8h8n8h8o8h8p8h8q8h8r8h8s8h8t8h8u8h8v8h948h958h968h978h988h998h9a8h9b8h9c8h9d8h9k8h9l8h9m8h9n8h9o8h9p8h9q8h9r8h9s8h9t8h9z8ha08ha18ha28ha38ha48ha58ha68ha78ha88ha98hbf8hbg8hbh8hbi8hbj8hbk8hbl8hbm8hbn8hbo8hbp8hc78hc88hc98hca8hcb8hcc8hcd8hce8hcf8hcg8hch8hck8hcl8hcm8hcn8hco8hcp8hcq8hcr8hcs8hct8hcu8hd88hd98hda8hdb8hdc8hdd8hde8hdf8hdg8hdh8hdl8hdm8hdn8hdo8hdp8hdq8hdr8hds8hdt8hdu8he88he98hea8heb8hec8hed8hee8hef8heg8heh8hem8hen8heo8hep8heq8her8hes8het8heu8hev8hew8hex8hey8hez8hf08hf18hf28hf38hf48hf58hf68hf78hf88hf98hfa8hfb8hfc8hfd8hfe8hff8hfg8h188i198i1a8i1b8i1c8i1d8i1e8i1f8i1g8i1h8i1i8i208i218i228i238i248i258i268i278i288i298i2a8i2e8i2f8i2g8i2h8i2i8i2j8i2k8i2l8i2m8i2n8i2o8i2p8i2q8i2r8i2s8i2x8i2y8i2z8i308i318i328i338i348i358i368i3e8i3f8i3g8i3h8i3i8i3j8i3k8i3l8i3m8i3n8i3w8i3x8i3y8i3z8i408i418i428i438i448i458i468i478i488i498i4a8i4f8i4g8i4h8i4i8i4j8i4k8i4l8i4m8i4n8i4o8i4s8i4t8i4u8i4v8i4w8i4x8i4y8i4z8i508i518i528i5r8i5s8i5t8i5u8i5v8i5w8i5x8i5y8i5z8i608i6b8i6c8i6d8i6e8i6f8i6g8i6h8i6i8i6j8i6k8i6m8i6n8i6o8i6p8i6q8i6r8i6s8i6t8i6u8i6v8i7c8i7d8i7e8i7f8i7g8i7h8i7i8i7j8i7k8i7l8i7m8i7n8i7o8i7p8i7q8i7r8i7s8i7t8i7u8i7v8i7w8i7x8i838i848i858i868i878i888i898i8a8i8b8i8c8i8m8i8n8i8o8i8p8i8q8i8r8i8s8i8t8i8u8i8v8i948i958i968i978i988i998i9a8i9b8i9c8i9d8i9k8i9l8i9m8i9n8i9o8i9p8i9q8i9r8i9s8i9t8i9z8ia08ia18ia28ia38ia48ia58ia68ia78ia88ia98ibf8ibg8ibh8ibi8ibj8ibk8ibl8ibm8ibn8ibo8ibp8ic78ic88ic98ica8icb8icc8icd8ice8icf8icg8ich8ick8icl8icm8icn8ico8icp8icq8icr8ics8ict8icu8id88id98ida8idb8idc8idd8ide8idf8idg8idh8idl8idm8idn8ido8idp8idq8idr8ids8idt8idu8idv8ie88ie98iea8ieb8iec8ied8iee8ief8ieg8ieh8iem8ien8ieo8iep8ieq8ier8ies8iet8ieu8iev8iew8iex8iey8iez8if08if18if28if38if48if58if68if78if88if98ifa8ifb8ifc8ifd8ife8iff8ifg8i188j198j1a8j1b8j1c8j1d8j1e8j1f8j1g8j1h8j1i8j1j8j1z8j208j218j228j238j248j258j268j278j288j298j2d8j2e8j2f8j2g8j2h8j2i8j2j8j2k8j2l8j2m8j2n8j2o8j2x8j2y8j2z8j308j318j328j338j348j358j368j3e8j3f8j3g8j3h8j3i8j3j8j3k8j3l8j3m8j3n8j3v8j3w8j3x8j3y8j3z8j408j418j428j438j448j458j468j4f8j4g8j4h8j4i8j4j8j4k8j4l8j4m8j4n8j4o8j4s8j4t8j4u8j4v8j4w8j4x8j4y8j4z8j508j518j528j5d8j5e8j5f8j5g8j5h8j5i8j5j8j5k8j5l8j5m8j5r8j5s8j5t8j5u8j5v8j5w8j5x8j5y8j5z8j608j6c8j6d8j6e8j6f8j6g8j6h8j6i8j6j8j6k8j6l8j6m8j6n8j6o8j6p8j6q8j6r8j6s8j6t8j6u8j7f8j7g8j7h8j7i8j7j8j7k8j7l8j7m8j7n8j7o8j7p8j7q8j7r8j7s8j7t8j7u8j7v8j7w8j7x8j838j848j858j868j878j888j898j8a8j8b8j8c8j8m8j8n8j8o8j8p8j8q8j8r8j8s8j8t8j8u8j8v8j948j958j968j978j988j998j9a8j9b8j9c8j9d8j9k8j9l8j9m8j9n8j9o8j9p8j9q8j9r8j9s8j9t8j9z8ja08ja18ja28ja38ja48ja58ja68ja78ja88ja98jak8jal8jam8jan8jao8jap8jaq8jar8jas8jat8jbf8jbg8jbh8jbi8jbj8jbk8jbl8jbm8jbn8jbo8jbp8jbq8jc68jc78jc88jc98jca8jcb8jcc8jcd8jce8jcf8jcg8jck8jcl8jcm8jcn8jco8jcp8jcq8jcr8jcs8jct8jcu8jd88jd98jda8jdb8jdc8jdd8jde8jdf8jdg8jdh8jdl8jdm8jdn8jdo8jdp8jdq8jdr8jds8jdt8jdu8jdv8je78je88je98jea8jeb8jec8jed8jee8jef8jeg8jeh8jem8jen8jeo8jep8jeq8jer8jes8jet8jeu8jev8j188k198k1a8k1b8k1c8k1d8k1e8k1f8k1g8k1h8k1i8k1j8k1z8k208k218k228k238k248k258k268k278k288k298k2d8k2e8k2f8k2g8k2h8k2i8k2j8k2k8k2l8k2m8k2n8k2w8k2x8k2y8k2z8k308k318k328k338k348k358k368k3e8k3f8k3g8k3h8k3i8k3j8k3k8k3l8k3m8k3n8k3v8k3w8k3x8k3y8k3z8k408k418k428k438k448k458k4e8k4f8k4g8k4h8k4i8k4j8k4k8k4l8k4m8k4n8k4o8k4t8k4u8k4v8k4w8k4x8k4y8k4z8k508k518k528k5d8k5e8k5f8k5g8k5h8k5i8k5j8k5k8k5l8k5m8k5r8k5s8k5t8k5u8k5v8k5w8k5x8k5y8k5z8k608k6c8k6d8k6e8k6f8k6g8k6h8k6i8k6j8k6k8k6l8k6m8k6n8k6o8k6p8k6q8k6r8k6s8k6t8k6u8k7j8k7k8k7l8k7m8k7n8k7o8k7p8k7q8k7r8k7s8k7t8k7u8k7v8k7w8k7x8k7y8k838k848k858k868k878k888k898k8a8k8b8k8c8k8m8k8n8k8o8k8p8k8q8k8r8k8s8k8t8k8u8k8v8k948k958k968k978k988k998k9a8k9b8k9c8k9d8k9k8k9l8k9m8k9n8k9o8k9p8k9q8k9r8k9s8k9t8ka08ka18ka28ka38ka48ka58ka68ka78ka88ka98kak8kal8kam8kan8kao8kap8kaq8kar8kas8kat8kbf8kbg8kbh8kbi8kbj8kbk8kbl8kbm8kbn8kbo8kbp8kbq8kc68kc78kc88kc98kca8kcb8kcc8kcd8kce8kcf8kcg8kcl8kcm8kcn8kco8kcp8kcq8kcr8kcs8kct8kcu8kd78kd88kd98kda8kdb8kdc8kdd8kde8kdf8kdg8kdh8kdl8kdm8kdn8kdo8kdp8kdq8kdr8kds8kdt8kdu8kdv8ke78ke88ke98kea8keb8kec8ked8kee8kef8keg8keh8kem8ken8keo8kep8keq8ker8kes8ket8keu8kev8k198l1a8l1b8l1c8l1d8l1e8l1f8l1g8l1h8l1i8l1j8l1k8l1y8l1z8l208l218l228l238l248l258l268l278l288l298l2d8l2e8l2f8l2g8l2h8l2i8l2j8l2k8l2l8l2m8l2w8l2x8l2y8l2z8l308l318l328l338l348l358l368l3e8l3f8l3g8l3h8l3i8l3j8l3k8l3l8l3m8l3n8l3v8l3w8l3x8l3y8l3z8l408l418l428l438l448l4e8l4f8l4g8l4h8l4i8l4j8l4k8l4l8l4m8l4n8l4o8l4t8l4u8l4v8l4w8l4x8l4y8l4z8l508l518l528l538l5d8l5e8l5f8l5g8l5h8l5i8l5j8l5k8l5l8l5m8l5r8l5s8l5t8l5u8l5v8l5w8l5x8l5y8l5z8l608l6c8l6d8l6e8l6f8l6g8l6h8l6i8l6j8l6k8l6l8l6m8l6n8l6o8l6p8l6q8l6r8l6s8l6t8l6u8l748l758l768l778l788l798l7a8l7b8l7c8l7d8l7n8l7o8l7p8l7q8l7r8l7s8l7t8l7u8l7v8l7w8l7x8l7y8l838l848l858l868l878l888l898l8a8l8b8l8c8l8m8l8n8l8o8l8p8l8q8l8r8l8s8l8t8l8u8l8v8l948l958l968l978l988l998l9a8l9b8l9c8l9d8l9k8l9l8l9m8l9n8l9o8l9p8l9q8l9r8l9s8l9t8la08la18la28la38la48la58la68la78la88la98laa8lak8lal8lam8lan8lao8lap8laq8lar8las8lat8lbg8lbh8lbi8lbj8lbk8lbl8lbm8lbn8lbo8lbp8lbq8lbr8lc58lc68lc78lc88lc98lca8lcb8lcc8lcd8lce8lcf8lcg8lcl8lcm8lcn8lco8lcp8lcq8lcr8lcs8lct8lcu8lcv8ld78ld88ld98lda8ldb8ldc8ldd8lde8ldf8ldg8ldh8ldm8ldn8ldo8ldp8ldq8ldr8lds8ldt8ldu8ldv8ldw8le78le88le98lea8leb8lec8led8lee8lef8leg8leh8lem8len8leo8lep8leq8ler8les8let8leu8lev8l198m1a8m1b8m1c8m1d8m1e8m1f8m1g8m1h8m1i8m1j8m1k8m1l8m1x8m1y8m1z8m208m218m228m238m248m258m268m278m288m2d8m2e8m2f8m2g8m2h8m2i8m2j8m2k8m2l8m2m8m2w8m2x8m2y8m2z8m308m318m328m338m348m358m368m3e8m3f8m3g8m3h8m3i8m3j8m3k8m3l8m3m8m3n8m3v8m3w8m3x8m3y8m3z8m408m418m428m438m448m4e8m4f8m4g8m4h8m4i8m4j8m4k8m4l8m4m8m4n8m4o8m4t8m4u8m4v8m4w8m4x8m4y8m4z8m508m518m528m538m5c8m5d8m5e8m5f8m5g8m5h8m5i8m5j8m5k8m5l8m5m8m5r8m5s8m5t8m5u8m5v8m5w8m5x8m5y8m5z8m608m6d8m6e8m6f8m6g8m6h8m6i8m6j8m6k8m6l8m6m8m6n8m6o8m6p8m6q8m6r8m6s8m6t8m748m758m768m778m788m798m7a8m7b8m7c8m7d8m7o8m7p8m7q8m7r8m7s8m7t8m7u8m7v8m7w8m7x8m7y8m838m848m858m868m878m888m898m8a8m8b8m8c8m8m8m8n8m8o8m8p8m8q8m8r8m8s8m8t8m8u8m8v8m948m958m968m978m988m998m9a8m9b8m9c8m9d8m9k8m9l8m9m8m9n8m9o8m9p8m9q8m9r8m9s8m9t8ma08ma18ma28ma38ma48ma58ma68ma78ma88ma98maa8maj8mak8mal8mam8man8mao8map8maq8mar8mas8mat8mbg8mbh8mbi8mbj8mbk8mbl8mbm8mbn8mbo8mbp8mbq8mbr8mbs8mc48mc58mc68mc78mc88mc98mca8mcb8mcc8mcd8mce8mcf8mcl8mcm8mcn8mco8mcp8mcq8mcr8mcs8mct8mcu8mcv8md68md78md88md98mda8mdb8mdc8mdd8mde8mdf8mdg8mdm8mdn8mdo8mdp8mdq8mdr8mds8mdt8mdu8mdv8mdw8me68me78me88me98mea8meb8mec8med8mee8mef8meg8meh8mem8men8meo8mep8meq8mer8mes8met8meu8mev8mew8mf68mf78mf88mf98mfa8mfb8mfc8mfd8mfe8mff8mfg8m1a8n1b8n1c8n1d8n1e8n1f8n1g8n1h8n1i8n1j8n1k8n1l8n1m8n1n8n1v8n1w8n1x8n1y8n1z8n208n218n228n238n248n258n268n278n288n2d8n2e8n2f8n2g8n2h8n2i8n2j8n2k8n2l8n2m8n2v8n2w8n2x8n2y8n2z8n308n318n328n338n348n358n368n3e8n3f8n3g8n3h8n3i8n3j8n3k8n3l8n3m8n3n8n3v8n3w8n3x8n3y8n3z8n408n418n428n438n448n4d8n4e8n4f8n4g8n4h8n4i8n4j8n4k8n4l8n4m8n4n8n4o8n4t8n4u8n4v8n4w8n4x8n4y8n4z8n508n518n528n538n548n5c8n5d8n5e8n5f8n5g8n5h8n5i8n5j8n5k8n5l8n5m8n5r8n5s8n5t8n5u8n5v8n5w8n5x8n5y8n5z8n608n6d8n6e8n6f8n6g8n6h8n6i8n6j8n6k8n6l8n6m8n6n8n6o8n6p8n6q8n6r8n6s8n6t8n748n758n768n778n788n798n7a8n7b8n7c8n7d8n7e8n7p8n7q8n7r8n7s8n7t8n7u8n7v8n7w8n7x8n7y8n838n848n858n868n878n888n898n8a8n8b8n8c8n8m8n8n8n8o8n8p8n8q8n8r8n8s8n8t8n8u8n8v8n948n958n968n978n988n998n9a8n9b8n9c8n9d8n9k8n9l8n9m8n9n8n9o8n9p8n9q8n9r8n9s8n9t8na08na18na28na38na48na58na68na78na88na98naa8nab8naj8nak8nal8nam8nan8nao8nap8naq8nar8nas8nat8nbh8nbi8nbj8nbk8nbl8nbm8nbn8nbo8nbp8nbq8nbr8nbs8nbt8nbu8nc28nc38nc48nc58nc68nc78nc88nc98nca8ncb8ncc8ncd8nce8ncf8ncl8ncm8ncn8nco8ncp8ncq8ncr8ncs8nct8ncu8ncv8ncw8nd58nd68nd78nd88nd98nda8ndb8ndc8ndd8nde8ndf8ndg8ndm8ndn8ndo8ndp8ndq8ndr8nds8ndt8ndu8ndv8ndw8ndx8ne58ne68ne78ne88ne98nea8neb8nec8ned8nee8nef8neg8neh8nen8neo8nep8neq8ner8nes8net8neu8nev8new8nex8nf68nf78nf88nf98nfa8nfb8nfc8nfd8nfe8nff8nfg8n1a8o1b8o1c8o1d8o1e8o1f8o1g8o1h8o1i8o1j8o1k8o1l8o1m8o1n8o1o8o1p8o1q8o1r8o1s8o1t8o1u8o1v8o1w8o1x8o1y8o1z8o208o218o228o238o248o258o268o278o2d8o2e8o2f8o2g8o2h8o2i8o2j8o2k8o2l8o2m8o2n8o2u8o2v8o2w8o2x8o2y8o2z8o308o318o328o338o348o358o368o3e8o3f8o3g8o3h8o3i8o3j8o3k8o3l8o3m8o3n8o3v8o3w8o3x8o3y8o3z8o408o418o428o438o448o458o4c8o4d8o4e8o4f8o4g8o4h8o4i8o4j8o4k8o4l8o4m8o4n8o4o8o4u8o4v8o4w8o4x8o4y8o4z8o508o518o528o538o548o558o5a8o5b8o5c8o5d8o5e8o5f8o5g8o5h8o5i8o5j8o5k8o5l8o5r8o5s8o5t8o5u8o5v8o5w8o5x8o5y8o5z8o608o6d8o6e8o6f8o6g8o6h8o6i8o6j8o6k8o6l8o6m8o6n8o6o8o6p8o6q8o6r8o6s8o6t8o748o758o768o778o788o798o7a8o7b8o7c8o7d8o7e8o7f8o7o8o7p8o7q8o7r8o7s8o7t8o7u8o7v8o7w8o7x8o7y8o838o848o858o868o878o888o898o8a8o8b8o8c8o8m8o8n8o8o8o8p8o8q8o8r8o8s8o8t8o8u8o8v8o948o958o968o978o988o998o9a8o9b8o9c8o9d8o9k8o9l8o9m8o9n8o9o8o9p8o9q8o9r8o9s8o9t8oa18oa28oa38oa48oa58oa68oa78oa88oa98oaa8oab8oac8oah8oai8oaj8oak8oal8oam8oan8oao8oap8oaq8oar8oas8obh8obi8obj8obk8obl8obm8obn8obo8obp8obq8obr8obs8obt8obu8obv8obw8obx8oby8obz8oc08oc18oc28oc38oc48oc58oc68oc78oc88oc98oca8ocb8occ8ocd8oce8ocm8ocn8oco8ocp8ocq8ocr8ocs8oct8ocu8ocv8ocw8ocx8ocy8od38od48od58od68od78od88od98oda8odb8odc8odd8ode8odf8odg8odm8odn8odo8odp8odq8odr8ods8odt8odu8odv8odw8odx8ody8odz8oe38oe48oe58oe68oe78oe88oe98oea8oeb8oec8oed8oee8oef8oeg8oeh8oen8oeo8oep8oeq8oer8oes8oet8oeu8oev8oew8oex8oey8of48of58of68of78of88of98ofa8ofb8ofc8ofd8ofe8off8o1b8p1c8p1d8p1e8p1f8p1g8p1h8p1i8p1j8p1k8p1l8p1m8p1n8p1o8p1p8p1q8p1r8p1s8p1t8p1u8p1v8p1w8p1x8p1y8p1z8p208p218p228p238p248p258p268p278p2d8p2e8p2f8p2g8p2h8p2i8p2j8p2k8p2l8p2m8p2n8p2o8p2s8p2t8p2u8p2v8p2w8p2x8p2y8p2z8p308p318p328p338p348p358p368p3e8p3f8p3g8p3h8p3i8p3j8p3k8p3l8p3m8p3n8p3o8p3p8p3q8p3r8p3s8p3v8p3w8p3x8p3y8p3z8p408p418p428p438p448p458p468p4a8p4b8p4c8p4d8p4e8p4f8p4g8p4h8p4i8p4j8p4k8p4l8p4m8p4n8p4o8p4u8p4v8p4w8p4x8p4y8p4z8p508p518p528p538p548p558p568p578p588p598p5a8p5b8p5c8p5d8p5e8p5f8p5g8p5h8p5i8p5j8p5k8p5l8p5r8p5s8p5t8p5u8p5v8p5w8p5x8p5y8p5z8p608p6e8p6f8p6g8p6h8p6i8p6j8p6k8p6l8p6m8p6n8p6o8p6p8p6q8p6r8p6s8p758p768p778p788p798p7a8p7b8p7c8p7d8p7e8p7f8p7g8p7h8p7i8p7j8p7l8p7m8p7n8p7o8p7p8p7q8p7r8p7s8p7t8p7u8p7v8p7w8p7x8p838p848p858p868p878p888p898p8a8p8b8p8c8p8m8p8n8p8o8p8p8p8q8p8r8p8s8p8t8p8u8p8v8p948p958p968p978p988p998p9a8p9b8p9c8p9d8p9k8p9l8p9m8p9n8p9o8p9p8p9q8p9r8p9s8p9t8pa18pa28pa38pa48pa58pa68pa78pa88pa98paa8pab8pac8pad8pae8paf8pag8pah8pai8paj8pak8pal8pam8pan8pao8pap8paq8par8pas8pbi8pbj8pbk8pbl8pbm8pbn8pbo8pbp8pbq8pbr8pbs8pbt8pbu8pbv8pbw8pbx8pby8pbz8pc08pc18pc28pc38pc48pc58pc68pc78pc88pc98pca8pcb8pcc8pcd8pce8pcm8pcn8pco8pcp8pcq8pcr8pcs8pct8pcu8pcv8pcw8pcx8pcy8pcz8pd08pd18pd28pd38pd48pd58pd68pd78pd88pd98pda8pdb8pdc8pdd8pde8pdf8pdn8pdo8pdp8pdq8pdr8pds8pdt8pdu8pdv8pdw8pdx8pdy8pdz8pe08pe18pe28pe38pe48pe58pe68pe78pe88pe98pea8peb8pec8ped8pee8pef8peg8peh8pen8peo8pep8peq8per8pes8pet8peu8pev8pew8pex8pey8pez8pf08pf18pf28pf38pf48pf58pf68pf78pf88pf98pfa8pfb8pfc8pfd8pfe8pff8p1c8q1d8q1e8q1f8q1g8q1h8q1i8q1j8q1k8q1l8q1m8q1n8q1o8q1p8q1q8q1r8q1s8q1t8q1u8q1v8q1w8q1x8q1y8q1z8q208q218q228q238q248q258q268q2d8q2e8q2f8q2g8q2h8q2i8q2j8q2k8q2l8q2m8q2n8q2o8q2p8q2q8q2r8q2s8q2t8q2u8q2v8q2w8q2x8q2y8q2z8q308q318q328q338q348q358q368q3e8q3f8q3g8q3h8q3i8q3j8q3k8q3l8q3m8q3n8q3o8q3p8q3q8q3r8q3s8q3v8q3w8q3x8q3y8q3z8q408q418q428q438q448q458q468q478q488q498q4a8q4b8q4c8q4d8q4e8q4f8q4g8q4h8q4i8q4j8q4k8q4l8q4m8q4n8q4o8q4u8q4v8q4w8q4x8q4y8q4z8q508q518q528q538q548q558q568q578q588q598q5a8q5b8q5c8q5d8q5e8q5f8q5g8q5h8q5i8q5j8q5k8q5r8q5s8q5t8q5u8q5v8q5w8q5x8q5y8q5z8q608q6e8q6f8q6g8q6h8q6i8q6j8q6k8q6l8q6m8q6n8q6o8q6p8q6q8q6r8q6s8q758q768q778q788q798q7a8q7b8q7c8q7d8q7e8q7f8q7g8q7h8q7i8q7j8q7k8q7l8q7m8q7n8q7o8q7p8q7q8q7r8q7s8q7t8q7u8q7v8q7w8q7x8q838q848q858q868q878q888q898q8a8q8b8q8c8q8m8q8n8q8o8q8p8q8q8q8r8q8s8q8t8q8u8q8v8q948q958q968q978q988q998q9a8q9b8q9c8q9d8q9k8q9l8q9m8q9n8q9o8q9p8q9q8q9r8q9s8q9t8qa18qa28qa38qa48qa58qa68qa78qa88qa98qaa8qab8qac8qad8qae8qaf8qag8qah8qai8qaj8qak8qal8qam8qan8qao8qap8qaq8qar8qbj8qbk8qbl8qbm8qbn8qbo8qbp8qbq8qbr8qbs8qbt8qbu8qbv8qbw8qbx8qby8qbz8qc08qc18qc28qc38qc48qc58qc68qc78qc88qc98qca8qcb8qcc8qcd8qcn8qco8qcp8qcq8qcr8qcs8qct8qcu8qcv8qcw8qcx8qcy8qcz8qd08qd18qd28qd38qd48qd58qd68qd78qd88qd98qda8qdb8qdc8qdd8qde8qdf8qdn8qdo8qdp8qdq8qdr8qds8qdt8qdu8qdv8qdw8qdx8qdy8qdz8qe08qe18qe28qe38qe48qe58qe68qe78qe88qe98qea8qeb8qec8qed8qee8qef8qeg8qeh8qeo8qep8qeq8qer8qes8qet8qeu8qev8qew8qex8qey8qez8qf08qf18qf28qf38qf48qf58qf68qf78qf88qf98qfa8qfb8qfc8qfd8qfe8qff8q1c8r1d8r1e8r1f8r1g8r1h8r1i8r1j8r1k8r1l8r1m8r1n8r1o8r1p8r1q8r1r8r1s8r1t8r1u8r1v8r1w8r1x8r1y8r1z8r208r218r228r238r248r258r2e8r2f8r2g8r2h8r2i8r2j8r2k8r2l8r2m8r2n8r2o8r2p8r2q8r2r8r2s8r2t8r2u8r2v8r2w8r2x8r2y8r2z8r308r318r328r338r348r358r368r3e8r3f8r3g8r3h8r3i8r3j8r3k8r3l8r3m8r3n8r3o8r3p8r3q8r3r8r3s8r3w8r3x8r3y8r3z8r408r418r428r438r448r458r468r478r488r498r4a8r4b8r4c8r4d8r4e8r4f8r4g8r4h8r4i8r4j8r4k8r4l8r4m8r4n8r4o8r4v8r4w8r4x8r4y8r4z8r508r518r528r538r548r558r568r578r588r598r5a8r5b8r5c8r5d8r5e8r5f8r5g8r5h8r5i8r5j8r5k8r5r8r5s8r5t8r5u8r5v8r5w8r5x8r5y8r5z8r608r6e8r6f8r6g8r6h8r6i8r6j8r6k8r6l8r6m8r6n8r6o8r6p8r6q8r6r8r6s8r768r778r788r798r7a8r7b8r7c8r7d8r7e8r7f8r7g8r7h8r7i8r7j8r7k8r7l8r7m8r7n8r7o8r7p8r7q8r7r8r7s8r7t8r7u8r7v8r7w8r7x8r838r848r858r868r878r888r898r8a8r8b8r8c8r8m8r8n8r8o8r8p8r8q8r8r8r8s8r8t8r8u8r8v8r948r958r968r978r988r998r9a8r9b8r9c8r9d8r9k8r9l8r9m8r9n8r9o8r9p8r9q8r9r8r9s8r9t8ra28ra38ra48ra58ra68ra78ra88ra98raa8rab8rac8rad8rae8raf8rag8rah8rai8raj8rak8ral8ram8ran8rao8rap8raq8rar8rbj8rbk8rbl8rbm8rbn8rbo8rbp8rbq8rbr8rbs8rbt8rbu8rbv8rbw8rbx8rby8rbz8rc08rc18rc28rc38rc48rc58rc68rc78rc88rc98rca8rcb8rcc8rco8rcp8rcq8rcr8rcs8rct8rcu8rcv8rcw8rcx8rcy8rcz8rd08rd18rd28rd38rd48rd58rd68rd78rd88rd98rda8rdb8rdc8rdd8rde8rdo8rdp8rdq8rdr8rds8rdt8rdu8rdv8rdw8rdx8rdy8rdz8re08re18re28re38re48re58re68re78re88re98rea8reb8rec8red8ree8ref8reg8reh8rep8req8rer8res8ret8reu8rev8rew8rex8rey8rez8rf08rf18rf28rf38rf48rf58rf68rf78rf88rf98rfa8rfb8rfc8rfd8rfe8r1d8s1e8s1f8s1g8s1h8s1i8s1j8s1k8s1l8s1m8s1n8s1o8s1p8s1q8s1r8s1s8s1t8s1u8s1v8s1w8s1x8s1y8s1z8s208s218s228s238s248s2e8s2f8s2g8s2h8s2i8s2j8s2k8s2l8s2m8s2n8s2o8s2p8s2q8s2r8s2s8s2t8s2u8s2v8s2w8s2x8s2y8s2z8s308s318s328s338s348s358s368s3f8s3g8s3h8s3i8s3j8s3k8s3l8s3m8s3n8s3o8s3p8s3q8s3r8s3s8s3w8s3x8s3y8s3z8s408s418s428s438s448s458s468s478s488s498s4a8s4b8s4c8s4d8s4e8s4f8s4g8s4h8s4i8s4j8s4k8s4l8s4m8s4n8s4o8s4w8s4x8s4y8s4z8s508s518s528s538s548s558s568s578s588s598s5a8s5b8s5c8s5d8s5e8s5f8s5g8s5h8s5i8s5j8s5r8s5s8s5t8s5u8s5v8s5w8s5x8s5y8s5z8s608s6f8s6g8s6h8s6i8s6j8s6k8s6l8s6m8s6n8s6o8s6p8s6q8s6r8s768s778s788s798s7a8s7b8s7c8s7d8s7e8s7f8s7g8s7h8s7i8s7j8s7k8s7l8s7m8s7n8s7o8s7p8s7q8s7r8s7s8s7t8s7u8s7v8s7w8s838s848s858s868s878s888s898s8a8s8b8s8c8s8m8s8n8s8o8s8p8s8q8s8r8s8s8s8t8s8u8s8v8s948s958s968s978s988s998s9a8s9b8s9c8s9d8s9k8s9l8s9m8s9n8s9o8s9p8s9q8s9r8s9s8s9t8sa38sa48sa58sa68sa78sa88sa98saa8sab8sac8sad8sae8saf8sag8sah8sai8saj8sak8sal8sam8san8sao8sap8saq8sbk8sbl8sbm8sbn8sbo8sbp8sbq8sbr8sbs8sbt8sbu8sbv8sbw8sbx8sby8sbz8sc08sc18sc28sc38sc48sc58sc68sc78sc88sc98sca8scb8sco8scp8scq8scr8scs8sct8scu8scv8scw8scx8scy8scz8sd08sd18sd28sd38sd48sd58sd68sd78sd88sd98sda8sdb8sdc8sdd8sdp8sdq8sdr8sds8sdt8sdu8sdv8sdw8sdx8sdy8sdz8se08se18se28se38se48se58se68se78se88se98sea8seb8sec8sed8see8sef8seg8seh8sep8seq8ser8ses8set8seu8sev8sew8sex8sey8sez8sf08sf18sf28sf38sf48sf58sf68sf78sf88sf98sfa8sfb8sfc8sfd8s1e8t1f8t1g8t1h8t1i8t1j8t1k8t1l8t1m8t1n8t1o8t1p8t1q8t1r8t1s8t1t8t1u8t1v8t1w8t1x8t1y8t1z8t208t218t228t238t2f8t2g8t2h8t2i8t2j8t2k8t2l8t2m8t2n8t2o8t2p8t2q8t2r8t2s8t2t8t2u8t2v8t2w8t2x8t2y8t2z8t308t318t328t338t348t358t368t378t3f8t3g8t3h8t3i8t3j8t3k8t3l8t3m8t3n8t3o8t3p8t3q8t3r8t3s8t3x8t3y8t3z8t408t418t428t438t448t458t468t478t488t498t4a8t4b8t4c8t4d8t4e8t4f8t4g8t4h8t4i8t4j8t4k8t4l8t4m8t4n8t4o8t4p8t4x8t4y8t4z8t508t518t528t538t548t558t568t578t588t598t5a8t5b8t5c8t5d8t5e8t5f8t5g8t5h8t5i8t5r8t5s8t5t8t5u8t5v8t5w8t5x8t5y8t5z8t608t6f8t6g8t6h8t6i8t6j8t6k8t6l8t6m8t6n8t6o8t6p8t6q8t6r8t778t788t798t7a8t7b8t7c8t7d8t7e8t7f8t7g8t7h8t7i8t7j8t7k8t7l8t7m8t7n8t7o8t7p8t7q8t7r8t7s8t7t8t7u8t7v8t838t848t858t868t878t888t898t8a8t8b8t8c8t8m8t8n8t8o8t8p8t8q8t8r8t8s8t8t8t8u8t8v8t948t958t968t978t988t998t9a8t9b8t9c8t9d8t9k8t9l8t9m8t9n8t9o8t9p8t9q8t9r8t9s8t9t8ta48ta58ta68ta78ta88ta98taa8tab8tac8tad8tae8taf8tag8tah8tai8taj8tak8tal8tam8tan8tao8tap8tbl8tbm8tbn8tbo8tbp8tbq8tbr8tbs8tbt8tbu8tbv8tbw8tbx8tby8tbz8tc08tc18tc28tc38tc48tc58tc68tc78tc88tc98tca8tcp8tcq8tcr8tcs8tct8tcu8tcv8tcw8tcx8tcy8tcz8td08td18td28td38td48td58td68td78td88td98tda8tdb8tdc8tdq8tdr8tds8tdt8tdu8tdv8tdw8tdx8tdy8tdz8te08te18te28te38te48te58te68te78te88te98tea8teb8tec8ted8tee8tef8teg8teh8teq8ter8tes8tet8teu8tev8tew8tex8tey8tez8tf08tf18tf28tf38tf48tf58tf68tf78tf88tf98tfa8tfb8tfc8t1g8u1h8u1i8u1j8u1k8u1l8u1m8u1n8u1o8u1p8u1q8u1r8u1s8u1t8u1u8u1v8u1w8u1x8u1y8u1z8u208u218u228u2g8u2h8u2i8u2j8u2k8u2l8u2m8u2n8u2o8u2p8u2q8u2r8u2s8u2t8u2u8u2v8u2x8u2y8u2z8u308u318u328u338u348u358u368u378u3g8u3h8u3i8u3j8u3k8u3l8u3m8u3n8u3o8u3p8u3q8u3r8u3s8u3y8u3z8u408u418u428u438u448u458u468u478u488u498u4a8u4b8u4c8u4d8u4f8u4g8u4h8u4i8u4j8u4k8u4l8u4m8u4n8u4o8u4p8u4y8u4z8u508u518u528u538u548u558u568u578u588u598u5a8u5b8u5c8u5d8u5e8u5f8u5g8u5h8u5r8u5s8u5t8u5u8u5v8u5w8u5x8u5y8u5z8u608u6f8u6g8u6h8u6i8u6j8u6k8u6l8u6m8u6n8u6o8u6p8u6q8u6r8u788u798u7a8u7b8u7c8u7d8u7e8u7f8u7g8u7h8u7i8u7j8u7k8u7l8u7m8u7n8u7o8u7p8u7q8u7r8u7s8u7t8u7u8u838u848u858u868u878u888u898u8a8u8b8u8c8u8m8u8n8u8o8u8p8u8q8u8r8u8s8u8t8u8u8u8v8u948u958u968u978u988u998u9a8u9b8u9c8u9d8u9k8u9l8u9m8u9n8u9o8u9p8u9q8u9r8u9s8u9t8ua58ua68ua78ua88ua98uaa8uab8uac8uad8uae8uaf8uag8uah8uai8uaj8uak8ual8uam8uan8uao8ubn8ubo8ubp8ubq8ubr8ubs8ubt8ubu8ubv8ubw8ubx8uby8ubz8uc08uc18uc28uc38uc48uc58uc68uc78uc88uc98ucq8ucr8ucs8uct8ucu8ucv8ucw8ucx8ucy8ucz8ud08ud18ud28ud38ud48ud58ud68ud78ud88ud98uda8udb8udr8uds8udt8udu8udv8udw8udx8udy8udz8ue08ue18ue28ue38ue48ue58ue68ue78ue88ue98uea8ueb8uec8ued8uee8uef8ueg8ueh8ues8uet8ueu8uev8uew8uex8uey8uez8uf08uf18uf28uf38uf48uf58uf68uf78uf88uf98ufa8ufb8u1i8v1j8v1k8v1l8v1m8v1n8v1o8v1p8v1q8v1r8v1s8v1t8v1u8v1v8v1w8v1x8v1y8v1z8v208v2h8v2i8v2j8v2k8v2l8v2m8v2n8v2o8v2p8v2q8v2r8v2s8v2t8v2u8v2y8v2z8v308v318v328v338v348v358v368v378v3h8v3i8v3j8v3k8v3l8v3m8v3n8v3o8v3p8v3q8v3r8v3s8v3z8v408v418v428v438v448v458v468v478v488v498v4a8v4b8v4c8v4g8v4h8v4i8v4j8v4k8v4l8v4m8v4n8v4o8v4p8v4z8v508v518v528v538v548v558v568v578v588v598v5a8v5b8v5c8v5d8v5e8v5f8v5g8v5r8v5s8v5t8v5u8v5v8v5w8v5x8v5y8v5z8v608v6g8v6h8v6i8v6j8v6k8v6l8v6m8v6n8v6o8v6p8v6q8v7a8v7b8v7c8v7d8v7e8v7f8v7g8v7h8v7i8v7j8v7k8v7l8v7m8v7n8v7o8v7p8v7q8v7r8v7s8v7t8v838v848v858v868v878v888v898v8a8v8b8v8c8v8m8v8n8v8o8v8p8v8q8v8r8v8s8v8t8v8u8v8v8v948v958v968v978v988v998v9a8v9b8v9c8v9d8v9k8v9l8v9m8v9n8v9o8v9p8v9q8v9r8v9s8v9t8va68va78va88va98vaa8vab8vac8vad8vae8vaf8vag8vah8vai8vaj8vak8val8vam8van8vbp8vbq8vbr8vbs8vbt8vbu8vbv8vbw8vbx8vby8vbz8vc08vc18vc28vc38vc48vc58vc68vc78vcs8vct8vcu8vcv8vcw8vcx8vcy8vcz8vd08vd18vd28vd38vd48vd58vd68vd78vd88vd98vda8vds8vdt8vdu8vdv8vdw8vdx8vdy8vdz8ve08ve18ve28ve38ve48ve58ve88ve98vea8veb8vec8ved8vee8vef8veg8veh8vet8veu8vev8vew8vex8vey8vez8vf08vf18vf28vf38vf48vf58vf68vf78vf88vf98v1k8w1l8w1m8w1n8w1o8w1p8w1q8w1r8w1s8w1t8w1u8w1v8w1w8w1x8w1y8w2j8w2k8w2l8w2m8w2n8w2o8w2p8w2q8w2r8w2s8w3k8w3l8w3m8w3n8w3o8w3p8w3q8w3r8w3s8w418w428w438w448w458w468w478w488w498w4a8w518w528w538w548w558w568w578w588w598w5a8w5b8w5c8w5d8w6g8w6h8w6i8w6j8w6k8w6l8w6m8w6n8w6o8w6p8w6q8w7c8w7d8w7e8w7f8w7g8w7h8w7i8w7j8w7k8w7l8w7m8w7n8w7o8w7p8w7q8wa88wa98waa8wab8wac8wad8wae8waf8wag8wah8wai8waj8wak8wbr8wbs8wbt8wbu8wbv8wbw8wbx8wby8wbz8wc08wc18wc28wc38wc48wc58wcu8wcv8wcw8wcx8wcy8wcz8wd08wd18wd28wd38wd48wd58wd68wd78wdu8wdv8wdw8wdx8wdy8wdz8we08we18we28we38wev8wew8wex8wey8wez8wf08wf18wf28wf38wf48wf58wf68wf78w1p8x1q8x1r8x1s8x1t8x578x588x6g8x6h8x6i8x6j8x6k8x6l8x6m8x6n8x6o8x6p8x7i8x7j8x7k8xae8xaf8xbw8xbx8xby8xbz8xc08xd08xd18xd28xf18x6g8y6h8y6i8y6j8y6k8y6l8y6m8y6n8y6o8y6p8y6g8z6h8z6i8z6j8z6k8z6l8z6m8z6n8z6o8z6p8z6f906g906h906i906j906k906l906m906n906o9069916a916b916c916d916e916f916g916h916i916j916k916l916m916n916o9169926a926b926c926d926e926f926g926h926i926j926k926l926m926n926o9269936a936b936c936d936e936f936g936h936i936j936k936l936m936n9369946a946b946c946d946e946f946g946h946i946j946k946l946m946n9469956a956b956c956d956e956f956g956h956i956j956k956l956m9569966a966b966c966d966e966f966g966h966i966j966k966l9669976a976b976c976d976e976f976g976h976i976j976k976l9769986a986b986c986d986e986f986g986h986i986j98";

        // ]
        
        this.points = [];
        for (let i = 0; i < this.data.length; i += 4) {
            const x = parseInt(this.data.substr(i, 2), 36);
            const y = parseInt(this.data.substr(i + 2, 2), 36);
            this.points.push([x, y, this.random(0, 200)]);
        }

        this.cam = {

            x: 500,
            y: 300,
            z: 100,
            
            lookX: 300,
            lookY: 300,
            lookZ: 100,

            _startLook: null,
            _startPos: null,
            animationOffset: 0,
            animateLook: function(time, start, stop, x, y, z) {
                
                var time = time + this.animationOffset;
                if (time < start || time > stop) {
                    return;
                }
                
                if (this._startLook === null) {
                    this._startLook = {
                        x: this.lookX,
                        y: this.lookY,
                        z: this.lookZ
                    };
                }
                
                var t = sin(map(time, start, stop, 90, 270));
                
                this.lookX = map(t, 1, -1, this._startLook.x, x);
                this.lookY = map(t, 1, -1, this._startLook.y, y);
                this.lookZ = map(t, 1, -1, this._startLook.z, z);
                
                if (time >= stop) {
                    this._startLook = null;
                }

            },
            animatePos: function(time, start, stop, x, y, z) {

                var time = time + this.animationOffset;
                if (time < start  || time > stop) {
                    return;
                }
                
                if (this._startPos === null) {
                    this._startPos = {
                        x: this.x,
                        y: this.y,
                        z: this.z
                    };
                }
                
                var t = sin(map(time, start, stop, 90, 270));
                
                this.x = map(t, 1, -1, this._startPos.x, x);
                this.y = map(t, 1, -1, this._startPos.y, y);
                this.z = map(t, 1, -1, this._startPos.z, z);
                
                if (time >= stop) {
                    this._startPos = null;
                }

            }
        
        };

        this.time = 0;

    }

    random(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    transformPoint(pt) {
        const px = pt[0] - this.cam.x;
        const py = pt[1] - this.cam.y;
        const pz = pt[2] - this.cam.z;

        const fx = this.cam.lookX - this.cam.x;
        const fy = this.cam.lookY - this.cam.y;
        const fz = this.cam.lookZ - this.cam.z;
        const fMag = Math.sqrt(fx * fx + fy * fy + fz * fz);
        const forward = [fx / fMag, fy / fMag, fz / fMag];

        const worldUp = [0, 1, 0];
        const right = [-forward[2], 0, forward[0]];
        const rMag = Math.sqrt(right[0] * right[0] + right[2] * right[2]);
        const normalizedRight = [right[0] / rMag, 0, right[2] / rMag];

        const up = [
            normalizedRight[1] * forward[2] - normalizedRight[2] * forward[1],
            normalizedRight[2] * forward[0] - normalizedRight[0] * forward[2],
            normalizedRight[0] * forward[1] - normalizedRight[1] * forward[0]
        ];
        const uMag = Math.sqrt(up[0] * up[0] + up[1] * up[1] + up[2] * up[2]);
        const normalizedUp = [up[0] / uMag, up[1] / uMag, up[2] / uMag];

        return {
            x: px * normalizedRight[0] + py * normalizedRight[1] + pz * normalizedRight[2],
            y: px * normalizedUp[0] + py * normalizedUp[1] + pz * normalizedUp[2],
            z: px * forward[0] + py * forward[1] + pz * forward[2]
        };
    }

    logic() {
        this.time++;
        
        // Look around
        this.cam.animateLook(this.time, 0, 100, 300, 300, 200);
        this.cam.animatePos(this.time, 0, 150, 200, 300, 100);
        
        // Position for zoom
        this.cam.animateLook(this.time, 100, 200, 300, 300, 0);
        this.cam.animatePos(this.time, 150, 250, 300, 300, 100);
        
        // Zoom out
        this.cam.animatePos(this.time, 250, 450, 300, 300, 300);
    }

    init() {

        pages.showPage("cataclysmicIntro");
        songs.cataclysmic_intro.play();

        background(-1);

    }

    lerp(a, b, t) {
        return a + (b - a) * t;
    }

    display() {
        
        noStroke();
        fill(0, 50);
        rect(0, 0, width, height);

        stroke(-1, min(this.time, 100));

        // Somewhat failed image data usage
        /*
        that.loadPixels();
        const data = imageData.data;
        if (data) {
            for (let n = 0; n < this.points.length; n++) {
                if (this.time > 360) {
                    this.points[n][2] -= this.points[n][2] / Math.max(720 - this.time, 10);
                    if (this.points[n][2] < 0.1) {
                        this.points[n][2] = 0;
                    }
                }

                const camPoint = this.transformPoint(this.points[n]);
                const f = 300;

                if (camPoint.z > 0) {
                    const screenX = Math.floor(camPoint.x * (f / camPoint.z)) + width / 2;
                    const screenY = Math.floor(camPoint.y * (f / camPoint.z)) + height / 2;

                    const pixelWidth = 1, pixelHeight = 1;
                    for (let w = 0; w < pixelWidth; w++) {
                        for (let h = 0; h < pixelHeight; h++) {
                            if (screenX + w < width && screenX + w > 0 && screenY + h < height && screenY + h > 0) {
                                const i = ((screenX + w) * 4) + ((screenY + h) * 4 * width);
                                data[i] = 255;
                                data[i + 1] = 255;
                                data[i + 2] = 255;
                            }
                        }
                    }
                }
            }
        }
        that.updatePixels();
        */
        
        if (this.time < 700) {

            pushMatrix();
            translate(300, 300);
            for (var n = 0; n < this.points.length; n++) {
            
                if (this.time > 400) {
                    this.points[n][2] -= this.points[n][2] / max(500 - this.time, 10);
                    if (this.points[n][2] < 0.01) {
                        this.points[n][2] = 0;
                    }
                }
                var camPoint = this.transformPoint(this.points[n]);
                
                // f is the focal length (adjust for your view)
                var f = 300;
                
                // Only project if z is positive (in front of the camera).
                if (camPoint.z > 0) {
                    var screenX = camPoint.x * (f / camPoint.z);
                    var screenY = camPoint.y * (f / camPoint.z);
                    strokeWeight(1);
                    
                    let minStroke = 2;
                    let maxStroke = 100;
                    let k = 300;
                    let weight = k / Math.max(camPoint.z, 0.1);  
                    strokeWeight(constrain(weight, minStroke, maxStroke));

                    point(screenX, screenY);
                }
            
            }
            popMatrix();

        }
        if (this.time > 750) {
            this.done = true;
        }

    }

    update() {

        this.logic();
        this.display();
        
    }

}
const cataclysmicIntro = new CataclysmicIntro();

// ]

/** Initiate **/
// [

/**
 * 
 * @param {string} type - 
 * @param {boolean} canChangeColor - 
 * @param {boolean} canAnimate - 
 * @param {string} nextType - 
 * @param {boolean} canInfiniteAnimate - 
 * @param {boolean} canCollide - 
 * @param {function} onChange - 
 * @param {number} animateSpeed - 
 * @param {boolean} isColored - 
 * @param {number} transSpeed - 
 * 
 */
let blockData = {
    "-": {
        type: "air",
    },
    "m": {
        canChangeColor: 1,
        canAnimate: 1,
        type: "grass",
        strength: 1,
        nextType: "M",
    },
    "M": {
        type: "grayGrass",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "m",
    },
    "s": {
        canChangeColor: 1,
        type: "stone",
        canCollide: 1,
        strength: 1,
        nextType: "S",
    },
    "S": {
        type: "grayStone",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "s",
    },
    "o": {
        canChangeColor: 1,
        type: "ore",
        canCollide: 1,
        strength: 1,
        nextType: "O",
    },
    "O": {
        type: "grayOre",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "o"
    },
    "f": {
        canChangeColor: 1,
        canAnimate: 1,
        type: "flower",
        strength: 1,
        nextType: "F",
    },
    "F": {
        type: "grayFlower",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "f"
    },
    "g": {
        canChangeColor: 1,
        type: "grassBlock",
        canCollide: 1,
        strength: 1,
        nextType: "G",
    },
    "G": {
        type: "grayGrassBlock",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "g"
    },
    "d": {
        canChangeColor: 1,
        type: "dirt",
        canCollide: 1,
        strength: 1,
        nextType: "D",
    },
    "D": {
        type: "grayDirt",
        canCollide: 1,
        canChangeColor: 1,
        nextType: "d"
    },
    "t": {
        canChangeColor: 1,
        canAnimate: 1,
        type: "flowerGrass",
        strength: 1,
        nextType: "T",
    },
    "T": {
        type: "grayFlowerGrass",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "t"
    },
    "q": {
        canChangeColor: 1,
        canAnimate: 1,
        type: "doubleFlower",
        strength: 1,
        nextType: "Q",
    },
    "Q": {
        type: "grayDoubleFlower",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "q"
    },
    "e": {
        canChangeColor: 1,
        canAnimate: 1,
        type: "leaves",
        strength: 1,
        nextType: "E",
    },
    "E": {
        type: "grayLeaves",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "e",
        transSpeed: 100
    },

    "0": {
        nextType: "7",
        type: "redPool",
        isLiquid: 1,
        name: "red",
        color: color(255, 0, 0),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "1": {
        nextType: "8",
        type: "bluePool",
        isLiquid: 1,
        name: "blue",
        color: color(50, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "2": {
        nextType: "9",
        type: "yellowPool",
        isLiquid: 1,
        name: "yellow",
        color: color(220, 220, 50),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "3": {
        nextType: "^",
        type: "orangePool",
        isLiquid: 1,
        name: "orange",
        color: color(255, 255/2, 0),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "4": {
        nextType: "<",
        type: "greenPool",
        isLiquid: 1,
        name: "green",
        color: color(50, 200, 50),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "5": {
        nextType: ">",
        type: "purplePool",
        isLiquid: 1,
        name: "purple",
        color: color(200, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "6": {
        nextType: "v",
        type: "brownPool",
        isLiquid: 1,
        name: "brown",
        color: color(100, 50, 0),
        canInfiniteAnimate: 1,
        strength: 1
    },

    "7": {
        type: "redPoolTop",
        isLiquid: 1,
        name: "red",
        color: color(255, 0, 0),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "8": {
        type: "bluePoolTop",
        isLiquid: 1,
        name: "blue",
        color: color(50, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "9": {
        type: "yellowPoolTop",
        isLiquid: 1,
        name: "yellow",
        color: color(220, 220, 50),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "^": {
        type: "orangePoolTop",
        isLiquid: 1,
        name: "orange",
        color: color(255, 255/2, 0),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "<": {
        type: "greenPoolTop",
        isLiquid: 1,
        name: "green",
        color: color(50, 200, 50),
        canInfiniteAnimate: 1,
        strength: 1
    },
    ">": {
        type: "purplePoolTop",
        isLiquid: 1,
        name: "purple",
        color: color(200, 50, 200),
        canInfiniteAnimate: 1,
        strength: 1
    },
    "v": {
        type: "brownPoolTop",
        isLiquid: 1,
        name: "brown",
        color: color(100, 50, 0),
        canInfiniteAnimate: 1,
        strength: 1
    },

    "l": {
        type: "bug",
        canChangeColor: 1,
        canInfiniteAnimate: 1,
        canAnimate: 1,
        animateSpeed: 3,
        strength: 1,
        nextType: "L",
        onChange: function(e){
            sounds["cute"+(floor(random(0, 5))+1)].play();
        },
    },
    "L": {
        canAnimate: 1,
        canChangeColor: 1,
        type: "grayBug",
        nextType: "l"
    },
    "b": {
        canChangeColor: 1,
        type: "bird",
        canAnimate: 1,
        strength: 1,
        onChange: function(e){
            sounds["egg"+(~~random(2)+1)].play();
            entities.push(new Bird({
                x: e.x,
                y: e.y
            }));
        },
        nextType: "B",
    },
    "B": {
        type: "grayBird",
        canChangeColor: 1,
        canAnimate: 1,
        nextType: "b"
    },
    "r": {
        type: "grassGuy",
        canChangeColor: 1,
        canInfiniteAnimate: 1,
        canAnimate: 1,
        animateSpeed: 10,
        strength: 1,
        nextType: "R",
        onChange: function(e){
            sounds["crumble"+(floor(random(0, 2))+1)].play();
        },
    },
    "R": {
        canAnimate: 1,
        canChangeColor: 1,
        type: "grayGrassGuy",
        nextType: "r"
    },
    "y": {
        type: "stoneGuy",
        canChangeColor: 1,
        canInfiniteAnimate: 1,
        canAnimate: 1,
        animateSpeed: 7,
        strength: 1,
        nextType: "Y",
    },
    "Y": {
        canAnimate: 1,
        canChangeColor: 1,
        type: "grayStoneGuy",
        nextType: "y",
        transSpeed: 100
    },
    
    "a": {
        type: "blank",
        canChangeColor: 1,
        canCollide: 1,
    },
    "c": {
        type: "red",
        canChangeColor: 1,
        canCollide: 1,
    },
    "z": {
        type: "green",
        canChangeColor: 1,
        canCollide: 1,
    },
    "h": {
        type: "blue",
        canChangeColor: 1,
        canCollide: 1,
    },
    "i": {
        type: "yellow",
        canChangeColor: 1,
        canCollide: 1,
    },
    "j": {
        type: "purple",
        canChangeColor: 1,
        canCollide: 1,
    },
    "k": {
        type: "orange",
        canChangeColor: 1,
        canCollide: 1,
    },
    "p": {
        type: "brown",
        canChangeColor: 1,
        canCollide: 1,
    },
};
let levels = [
    [
        "G#######@#########-------------------------------------------------------------------------------",
        "G#######G#########-------------------------------------------------------------------------------",
        "G#################-------------------------------------------------------------------------------",
        "G>################-------------------------------------------------------------------------------",
        "G#################-------------------------------------------------------------------------------",
        "G#################-------------------------------------------------------------------------------",
        "G#################@------------------------------------------------------------------------------",
        "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG",
    ],
    [
        "------------------------LMM----------------------------",
        "---------------------FFMGGGFFFMM-----------------------",
        "-@---------------MFLTGGGGGGGGGGGFF---------------------",
        "E-R-MMMM-QQFMLTMTGGGGGGGGGGGGGGGGGFMTFMQTM--QEQEQ--F--M",
        "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG--GGGGG44G00G",
        "GGGGGGGGGGGGGGGGGG---FFFFFFFFFMMMMMMMMMM----GGGGG44G00G",
        "GGGGGGGGGGGGGG-QEQEQEGGGGGGGGGGGGGGGGGGGGGGGGGGGG44G00G",
        "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS",
        "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO--OOOOOOOO",
        "-------------------------------------------------------",
        "-------------------------------------------------------",
        "-------------------------------------------------------",
    ],
    [
        "------------------------lmm----------------------------",
        "---------------------ffmgggfffmm-----------------------",
        "--@--------------mfltgggggggggggff---------------------",
        "e-r-mmmm-qqfmltmtgggggggggggggggggfmtfmqtm--qeqeq--f--m",
        "gggggggggggggggggggggggggggggggggggggggggg--ggggg44g00g",
        "gggggggggggggggggg---fffffffffmmmmmmmmmm----ggggg44g00g",
        "gggggggggggggg-qeqeqegggggggggggggggggggggggggggg44g00g",
        "sssssssssssssssssssssssssssssssssssssssssssssssssssssss",
        "ooooooooooooooooooooooooooooooooooooooooooooo--oooooooo",
        "-------------------------------------------------------",
        "-------------------------------------------------------",
        "-------------------------------------------------------",
    ],
    [
        "-----####################----------",
        "----G####################----------",
        "----G####################----------",
        "@---G####################----------",
        "G333GGGGGGGGGGGGGGGGGGGGMR----GGGGG",
        "G333GGGGGGGGGGGGGGGGGGGGGGGF---GGG-",
        "GG33GGGGGGGGGGGGGGGGGGGGGGGG--MGGEE",
        "GGG3SSSSSSSGGGGGGGGGGGGGGG----GGGGG",
        "SSS3SSSSSSSSSSSGGGGGGGGG---LQGGSGGG",
        "SS----SSSSSSSSSSSSSSGGG--QMGGGSSSGE",
        "SSTT---SSSSSSSSSS--------GGSSSSSSGG",
        "SSGG-------SSSSS-----------SSSSSGG-",
        "SSSG--SS---Y--L---V-L----Y--SSSSGEE",
        "SSSS--SSSSSSSSSSSSSSSSSSSSS-----SGG",
        "OOOOT-SSSSSSSSSSSSSSSSSSSSSSS-L--OO",
        "OOOOG--OOO5555SSSSSSSSSOOOOOOOOO-E-",
        "OOOOGTTM55555OOOOOOOOOOOOOOOOOOOGGG",
        "-OOOOGGGOOOOOOOOOOOOOOOOOOOOOOOGGGG",
    ],
    [
        "------------------------------------------------------------------------------------------------",
        "------------------------------------------------------------------------------------------------",
        "-------------------------------------------------#----------------------------------------------",
        "-------------------------------------------------#----------------------------------------------",
        "-------------------------------------------------#----------------------------------------------",
        "-------------------------------------------------#----------------------------------------------",
        "-------------------------------------------------#----------------------------------------------",
        "@--------aaaaaGGGGGGGGG-GGG----------------------#----------------------------------------------",
        "SSS444444SSSSSSSSSSSSSS-GGGGGG-------------------#----------------------------------------------",
        "SSS444444SSSSSSSSSSSSSS-SSSSGGGGGG-TMT-----------#---------------------------------############G",
        "SSS444444SSSSSSSSSSSSSS-SSSSSSSSSGGGGG-T---------#---------------------------------############G",
        "SSS444SSSSSSSS111-------SSSSSSSSSSSSGGGGM--------#---------------------------------############G",
        "SSSS444SSSSSSSSSS-------R-FM----SSSSSSSGG-TM-----#---------------------------------############G",
        "-SSSS444444SSSSSM-R-FF--GGGGGF--GGSSSSSSGGGGGT---#--------------------------------############GG",
        "--SS444444SSSSSGGGGGGGF---GGGG--R-GGSSSSSGGGGGMT-#--------------------------------###########GGG",
        "---SSSSSS44SSSSSSSSSGGG--FMR-MM-GGGSSSSSSSSSSGGGG#-----------------------------GGGGGGGGGGGGGGGGG",
        "--SSSSSSS4444------------GGGGGGGGGSSSSSSSSSSSSGGG#-G---------------------GGGGGGGGGGGGGGGGGGGGGGG",
        "-SSSSSS-----------------SSSSSSSSSSSSSS------##SSG#GGGGG-----------------------------------------",
        "-SSSS---------------------------------------####S#SSSGGGGG-MMQQ--MQ-MQ-MM--QQMQ-QM-QQ-----------",
        "--SSSSL-------------------L---L-L---LLLL-LLL######SSSSSSSGGGGGGGGGGGGGGGGGGGGGGGGGGGG55555555GGG",
        "----SSSS---LBB-L-BB-L-BBSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS555SSSSS",
        "-----OOO222SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS----SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS55SSSSSS",
        "-------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO-----------------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO",
        "----------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO---------------------OOOOOOOOOOOOOOOOOOOOOOOOOOOO",
    ],
], level = 4;

let blocks = [];
blocks.handle = function(func) {
    for(let y = max(floor((cam.y + PADDING_Y) / blockH) - 2, 0); y < min(floor((cam.y + PADDING_Y + height) / blockH) + 2, this.length); y++){
        for(let x = max(floor((cam.x + PADDING_X) / blockW) - 2, 0); x < min(floor((cam.x + PADDING_X + width) / blockW) + 2, this[y].length); x++){
            this[y][x][func]();
        }
    }
}

function createLevel() {
    
    // Reset
    enemies.length = 0;
    entities.length = 0;
    blocks.length = 0;

    // Loop y axis
    for (let y = 0; y < levels[level].length; y++) {
        
        blocks.push([]);
        
        // Loop x axis
        for (let x = 0; x < levels[level][y].length; x++) {
            let type = levels[level][y][x];
            switch (type) {
                case "@":
                    // Create new player
                    player = new Player({
                        w: blockW * 0.8,
                        h: blockH * 0.8,
                        x: x*blockW,
                        y: y*blockH
                    });
                    type = "-";
                    break;
                case "#":
                    enemies.push(new Rottweiler({
                        w: blockW * 0.8,
                        h: blockH * 0.8,
                        x: x*blockW,
                        y: y*blockH
                    }));
                    type = "-";
                    break;
            }

            blocks[y].push(new Block({
                w: blockW,
                h: blockH,
                x: x*blockW,
                y: y*blockH,
                symbol: type
            }));
        }
    
    }

    // Add air padding
    for (let y = 0; y < (PADDING_Y / blockH); y++) {
        blocks.push([]);
        for (let x = 0; x < blocks[blocks.length-2].length; x++) {
            blocks[blocks.length-1].push(new Block({
                w: blockW,
                h: blockH,
                x: blocks[blocks.length-1].length * blockW,
                y: (blocks.length-1) * blockH,
                symbol: "-"
            }));
        }
    }
    for (let y = 0; y < (PADDING_Y / blockH); y++) {
        blocks.unshift([]);
        for (let x = 0; x < blocks[1].length; x++) {
            blocks[0].push(new Block({
                w: blockW,
                h: blockH,
                x: blocks[0].length * blockW,
                y: (-y - 1) * blockH,
                symbol: "-"
            }));
        }
    }
    for (let y = 0; y < blocks.length; y++) {
        for (let x = 0; x < (PADDING_X / blockW); x++) {
            blocks[y].unshift(new Block({
                w: blockW,
                h: blockH,
                x: (-x - 1) * blockW,
                y: (y * blockH) - PADDING_Y,
                symbol: "-"
            }));
        }
    }
    for (let y = 0; y < blocks.length; y++) {
        for (let x = 0; x < (PADDING_X / blockW); x++) {
            blocks[y].push(new Block({
                w: blockW,
                h: blockH,
                x: (blocks[y].length * blockW) - PADDING_X,
                y: (y * blockH) - PADDING_Y,
                symbol: "-"
            }));
        }
    }

    // Index blocks
    let id = 0;
    for (let y = 0; y < blocks.length; y++) {
        for (let x = 0; x < blocks[y].length; x++) {
            if (y === 0 || x === 0 || y === blocks.length-1 || x === blocks[y].length-1) blocks[y][x].isEnd = true;
            blocks[y][x].index = [y, x];
            blocks[y][x].id = id;
            id++;
            if (blocks[y][x].canChangeColor) {
                if (blocks[y][x].strength > 0) {
                    player.hasColored++;
                }
                player.mustColor++;
            }
        }
    }

    levelW = blockW*blocks[0].length;
    levelH = blockH*blocks.length;
    
    player.blankPathfinder = blocks.map(innerArray => innerArray.map(() => 0));
    player.reset();

}

const pages = new Pages({
    pages: {
        loadImages: new Page({
            artKeys: Object.keys(art),
            spriteKeys: Object.keys(sprites),
            loadedA: 0,
            innerLoad: 0,
            loadedS: 0,
            draw: function() {
                background(0);
                noStroke();
                rectMode(CORNER);
                let img = undefined;
                if(this.loadedA < this.artKeys.length){
                    let a = this.artKeys[this.loadedA];
                    if(typeof art[a][0] === "string"){
                        background(0, 0);
                        let pixelW = 400/art[a][0].length,
                            pixelH = 400/art[a].length;
                        for(let i = 0; i < art[a].length; i++){
                            for(let j = 0; j < art[a][i].length; j++){
                                fill(colors[art[a][i][j]]);
                                rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                            }
                        }
                        art[a] = get(0, 0, 400, 400);
                        img = art[a];
                        this.loadedA++;
                    }else{
                        background(0, 0);
                        let pixelW = 400/art[a][this.innerLoad][0].length,
                            pixelH = 400/art[a][this.innerLoad].length;
                        for(let i = 0; i < art[a][this.innerLoad].length; i++){
                            for(let j = 0; j < art[a][this.innerLoad][i].length; j++){
                                fill(colors[art[a][this.innerLoad][i][j]]);
                                rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                            }
                        }
                        art[a][this.innerLoad] = get(0, 0, 400, 400);
                        img = art[a][this.innerLoad];
                        if(this.innerLoad === art[a].length-1){
                            this.innerLoad = 0;
                            this.loadedA++;
                        }else{
                            this.innerLoad++;
                        }
                    }
                }else{
                    if(this.loadedS < this.spriteKeys.length){
                        let a = this.spriteKeys[this.loadedS];
                        if(typeof sprites[a][0] === "string"){
                            background(0, 0);
                            let pixelW = 400/sprites[a][0].length,
                                pixelH = 400/sprites[a].length;
                            for(let i = 0; i < sprites[a].length; i++){
                                for(let j = 0; j < sprites[a][i].length; j++){
                                    fill(colors[sprites[a][i][j]]);
                                    rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                                }
                            }
                            sprites[a] = get(0, 0, 400, 400);
                            img = sprites[a];
                            this.loadedS++;
                        }else{
                            background(0, 0);
                            let pixelW = 400/sprites[a][this.innerLoad][0].length,
                                pixelH = 400/sprites[a][this.innerLoad].length;
                            for(let i = 0; i < sprites[a][this.innerLoad].length; i++){
                                for(let j = 0; j < sprites[a][this.innerLoad][i].length; j++){
                                    fill(colors[sprites[a][this.innerLoad][i][j]]);
                                    rect(j*pixelW, i*pixelH, pixelW + 1, pixelH + 1);
                                }
                            }
                            sprites[a][this.innerLoad] = get(0, 0, 400, 400);
                            img = sprites[a][this.innerLoad];
                            if(this.innerLoad === sprites[a].length-1){
                                this.innerLoad = 0;
                                this.loadedS++;
                            }else{
                                this.innerLoad++;
                            }
                        }
                    }else{
                        console.log('---Images loaded---');
                        pages.showPage("loadAudio");
                    }
                }
                if (img) {
                    background(0);
                    imageMode(CENTER);
                    image(img, width / 2, height * 0.4);
                }
                new PixelText({
                    x: width / 2,
                    y: height * 0.9,
                    string: "Loading Images" + ("...".slice(0, floor((frameCount / 50) % 4))),
                    size: 40,
                    color: 1,
                    align: CENTER
                }).display();
            }
        }),
        game: new Page({
            dust: new ParticleSystem(),
            particles: new ParticleSystem(),
            draw: function() {
                /*background(lerpColor(
                    color(200),
                    color(255),
                    ((player.hasColored/player.mustColor)||0)
                ));*/
                
/*
                // Update world
                pushMatrix();

                    // Camera translations
                    scale(cam.scale);
                    translate(round(-cam.x), round(-cam.y));

                    // Particles
                    this.dust.update();
                    this.particles.update();

                    // Display blocks
                    blocks.handle("update");
                    
                    // Handle player
                    if (player) {
                        cam.moveTo(player);
                        player.update();
                    }

                    // Enemies and entities
                    entities.forEach((e) => {
                        if (e.resetFrame) e.resetFrame();
                    })
                    for (let i = entities.length - 1; i >= 0; i--) {
                        entities[i].index = i;
                        entities[i].update();
                        if (entities[i].dead) entities.splice(i, 1);
                    }
                    enemies.forEach((e) => {
                        if (e.resetFrame) e.resetFrame();
                    })
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        enemies[i].index = i;
                        enemies[i].update();
                        if (enemies[i].dead) enemies.splice(i, 1);
                    }
                    
                    // Display shadows
                    blocks.handle("shadow");
                    player.light.draw();

                popMatrix();
            
                // Dust
                if(frameCount % 5 === 0){
                    this.dust.add(new Particle({
                        x: width+tx(10)+cam.x,
                        y: random(0, height)+cam.y,
                        vx: tx(-1),
                        w: 4,
                        color: lerpColor(
                            color(0, 10),
                            color(random(0, 255), random(0, 255), random(0, 255), 30),
                            ((player.hasColored/player.mustColor)||0)
                        ),
                        health: width + 20,
                        rvz: random(-0.02, 0.02),
                        rvx: random(-0.02, 0.02),
                        image: round(random(0, 1))?"ellipse":"rect",
                        onUpdate: function(){
                            this.vy = cos(this.health+frameCount)/4;
                        }
                    }));
                }
                
                player.updateHud();

                // Fix this, it is returning the error: TypeError: undefined is not an object (evaluating 'blcks[v0]][v[1]].strength')
                if (player.dead) createLevel();
*/
            }
        }),
        home: new Page({
            walkers: [],
            addWalker: function() {
                this.walkers.push(new ExtremeWalker({
                    amount: 200
                }));
            },
            draw: function() {
                
                pushStyle();
                    fill(0, 5);
                    noStroke();
                    rect(0, 0, width, height);
                popStyle();

                for (let i = this.walkers.length - 1; i >= 0; i--) {
                    this.walkers[i].update();
                    if (this.walkers[i].finished) {
                        this.walkers.splice(i, 1);
                    }
                }

                if (this.walkers.length === 0) {
                    this.addWalker();
                }
                this.walkers[this.walkers.length - 1].setPixel(floor(mouseX / (width / this.walkers[this.walkers.length - 1].grid.length)), floor(mouseY / (height / this.walkers[this.walkers.length - 1].grid.length)));

                if (mouse.released && this.walkers.length < 5) {
                    this.addWalker();
                    mouse.use();
                }
                
                // Alt + shift + 1 for thumbnail
                if (keys[49] && keys[16] && keys[18]) {
                    pages.showPage("thumbnail");
                }

            }
        }),
        loadAudio: new Page({
            draw: function() {
                background(0);
                new PixelText({
                    x: width / 2,
                    y: height * 0.9,
                    string: "Loading Audio" + ("...".slice(0, floor((frameCount / 50) % 4))),
                    size: 40,
                    color: 1,
                    align: CENTER
                }).display();
                if (loadedAudio === totalAudio) {
                    console.log('---Audio loaded---');
                    pages.showPage("game");
                    songs["dark"+(floor(random(0, 4))+1)].play();
                    // songs["happy"+(floor(random(0, 2))+1)].play();
                    // cataclysmicIntro.init();
                }
            }
        }),
        cataclysmicIntro:  new Page({
            draw: function() {
                cataclysmicIntro.update();
                if (cataclysmicIntro.done) {
                    pages.showPage("game");
                    songs["dark"+round(random(1, 4))].play();
                }
            }
        }),
        thumbnail:  new Page({
            draw: function() {
                background(0);
                new PixelText({
                    x: width / 2,
                    y: height * 0.15,
                    string: "~~ COLOR LAND ~~",
                    size: 50,
                    color: 1,
                    align: CENTER
                }).display();
                image(art.homeBg, 0, 0, width, height);
                for (k in keys) {
                    if(keys[k]) {
                        pages.showPage("home");
                    }
                }
            }
        })
    }
});

createLevel();
(!instantLoad) ? pages.showPage("loadImages") : pages.showPage("loadAudio");

// Start audio
// songs["dark"+round(random(1, 4))].play();

// ]

/** Draw loop **/
// [

frameRate(60);
let that = undefined;
function draw (){
    
    that = this;
    frameCount++;
    pages.update();
    mouse.update();

}

// ]

/** Events **/
// [

mousePressed = () => {
    mouse.press();
};
mouseReleased = () => {
    mouse.release();
};
keyPressed = () => {
    keys[keyCode] = true;
};
keyReleased = () => {
    keys[keyCode] = false;
};

// ]

/** End **/
// [
} function init() {

    parseAudio();

    let canvas = document.getElementById("game-canvas");
    let processingInstance = runPJS(program);

    let els = document.getElementsByClassName("loading");
    for(let i = 0; i < els.length; i++){
        els[i].style.display = "none";
    }

};

// ]

    </script>

    <script></script>

</html>
